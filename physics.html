<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Physics Shooter</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #111;
            user-select: none;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none; 
        }
        #ui-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            width: 220px; 
            transition: opacity 0.3s;
        }
        h1 {
            margin: 0;
            font-size: 18px; 
            letter-spacing: 1px;
            color: #ff9d00;
            text-shadow: 1px 1px 0px #000;
        }
        .controls {
            margin-top: 5px;
            font-size: 11px; 
            background: rgba(0,0,0,0.5); 
            padding: 10px;
            border-radius: 6px;
            backdrop-filter: blur(3px);
            border: 1px solid rgba(255,255,255,0.1);
            line-height: 1.4;
        }
        .key {
            display: inline-block;
            background: #444;
            border: 1px solid #666;
            border-radius: 3px;
            padding: 1px 4px;
            font-family: monospace;
            font-weight: bold;
            color: #fff;
            margin: 0 1px;
            font-size: 10px;
        }
        
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px; 
            height: 6px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 4px #000;
            z-index: 10;
        }

        
        .game-menus {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 6px;
            pointer-events: auto;
            z-index: 20;
            align-items: center;
            width: 90%;
        }
        
        /* Specific styling for the Ammo Menu in bottom left */
        #ammo-menu {
            position: absolute;
            bottom: 67px; 
            left: 25px;
            display: flex;
            flex-direction: row; 
            gap: 8px;
            pointer-events: auto;
            z-index: 20;
            align-items: center;
        }

        .button-row {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .ammo-btn {
            padding: 4px 10px;
            background: #1a1a1a;
            color: #aaa;
            border: 1px solid #333;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .ammo-btn.selected {
            background: #ff5500;
            color: white;
            border-color: #ff5500;
            box-shadow: 0 0 8px rgba(255, 85, 0, 0.5);
        }
        /* NEW: Locked State for Ammo Buttons */
        .ammo-btn.locked {
            opacity: 0.3;
            cursor: not-allowed;
            filter: grayscale(100%);
            border-color: #333;
            background: #111;
        }

        
        .slider-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: rgba(0,0,0,0.6);
            padding: 4px 12px;
            border-radius: 15px;
            border: 1px solid #ffaa00;
            color: #ffaa00;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 2px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .slider-container.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .eraser-dist-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: rgba(0,0,0,0.6);
            padding: 4px 12px;
            border-radius: 15px;
            border: 1px solid #ff3333;
            color: #ff3333;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 2px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .eraser-dist-container.visible {
            opacity: 1;
            pointer-events: auto;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 80px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ffaa00;
            cursor: pointer;
        }

        
        .status-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 12px;
            background: #333;
            color: #aaa;
            border-radius: 15px;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        .status-badge.aiming {
            background: #ff9d00;
            color: #000;
            box-shadow: 0 0 10px #ff9d00;
        }
        .status-badge.erasing {
            background: #ff0000;
            color: #fff;
            box-shadow: 0 0 10px #ff0000;
        }
        .slow-mo-badge {
            position: absolute;
            top: 45px;
            right: 10px;
            color: #ffdd00;
            font-weight: bold;
            font-style: italic;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.2s;
            text-shadow: 0 0 8px #ffdd00;
        }

        /* Charge Bar Styles */
        .charge-container {
            position: absolute;
            bottom: 180px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 10px;
            background: rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            display: none;
            overflow: hidden;
            pointer-events: none;
        }
        .charge-container.visible {
            display: block;
        }
        .charge-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffaa00);
            box-shadow: 0 0 10px #ffaa00;
            transition: width 0.1s linear;
        }
        .charge-text {
            position: absolute;
            top: -20px;
            width: 100%;
            text-align: center;
            color: #ffaa00;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 5px #ff0000;
        }


        #esc-notify {
            position: absolute;
            top: 80px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            pointer-events: none;
            transition: opacity 1s ease-out;
            text-shadow: 0 1px 2px black;
        }

        /* Redesigned Main Menu */
        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a0a0a 0%, #2e1a1a 50%, #1a0a0a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            overflow: hidden;
        }

        #main-menu::before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 69, 0, 0.1) 0%, transparent 70%);
            animation: rotate 20s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .menu-content {
            position: relative;
            z-index: 1;
            text-align: center;
            padding: 40px;
        }

        #main-menu h1 {
            font-size: 72px;
            margin-bottom: 15px;
            text-transform: uppercase;
            color: #fff;
            letter-spacing: 12px;
            text-shadow: 0 0 20px #ff4500, 0 0 40px #ff8c00, 0 0 60px #ffae00;
            background: none;
            -webkit-text-fill-color: initial;
            animation: titlePulse 3s infinite ease-in-out;
            font-weight: 900;
        }

        #main-menu p {
            color: #ffb84d;
            margin-bottom: 50px;
            font-size: 16px;
            letter-spacing: 3px;
            text-transform: uppercase;
            font-weight: 600;
            text-shadow: 0 0 10px rgba(255, 184, 77, 0.6);
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .menu-btn {
            padding: 18px 60px;
            font-size: 18px;
            background: linear-gradient(145deg, rgba(255, 102, 0, 0.1) 0%, rgba(255, 69, 0, 0.05) 100%);
            border: 2px solid #ff6600;
            border-radius: 8px; 
            color: #ff6600;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 102, 0, 0.3), inset 0 0 15px rgba(255, 102, 0, 0.1);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            text-transform: uppercase;
            letter-spacing: 3px;
            position: relative;
            overflow: hidden;
            min-width: 280px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .menu-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 102, 0, 0.3), transparent);
            transition: left 0.5s;
        }

        .menu-btn:hover::before {
            left: 100%;
        }

        .menu-btn.primary {
            background: linear-gradient(145deg, rgba(255, 102, 0, 0.2) 0%, rgba(255, 69, 0, 0.1) 100%);
            border-color: #ff6600;
            box-shadow: 0 0 30px rgba(255, 102, 0, 0.4), inset 0 0 20px rgba(255, 102, 0, 0.15);
        }

        .menu-btn.primary:hover {
            background: linear-gradient(145deg, #ff6600 0%, #ff4500 100%);
            color: #000;
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 0 50px rgba(255, 102, 0, 0.8), 0 10px 30px rgba(255, 102, 0, 0.4);
        }

        .menu-btn.secondary {
            background: linear-gradient(145deg, rgba(100, 100, 255, 0.1) 0%, rgba(69, 69, 200, 0.05) 100%);
            border-color: #6464ff;
            color: #6464ff;
            box-shadow: 0 0 20px rgba(100, 100, 255, 0.3), inset 0 0 15px rgba(100, 100, 255, 0.1);
        }

        .menu-btn.secondary:hover {
            background: linear-gradient(145deg, #6464ff 0%, #4545c8 100%);
            color: #fff;
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 0 50px rgba(100, 100, 255, 0.8), 0 10px 30px rgba(100, 100, 255, 0.4);
        }
        
        .menu-btn:active {
            transform: translateY(-2px) scale(1.02);
        }

        .btn-icon {
            font-size: 20px;
        }

        .btn-text {
            font-size: 16px;
        }

        @keyframes titlePulse {
            0%, 100% { 
                text-shadow: 0 0 20px #ff4500, 0 0 40px #ff8c00, 0 0 60px #ffae00;
                transform: scale(1);
            }
            50% { 
                text-shadow: 0 0 30px #ff4500, 0 0 60px #ff8c00, 0 0 80px #ffae00;
                transform: scale(1.02);
            }
        }

        /* Enemies Info Modal */
        .info-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .info-modal-content {
            background: linear-gradient(145deg, rgba(20, 20, 25, 0.95) 0%, rgba(15, 15, 20, 0.98) 100%);
            border: 2px solid rgba(255, 157, 0, 0.3);
            border-radius: 16px;
            width: 90%;
            max-width: 800px;
            max-height: 85vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), 0 0 40px rgba(255, 157, 0, 0.2);
            display: flex;
            flex-direction: column;
        }

        .info-modal-header {
            background: linear-gradient(90deg, rgba(255, 157, 0, 0.2) 0%, rgba(255, 100, 0, 0.1) 100%);
            padding: 20px 30px;
            border-bottom: 2px solid rgba(255, 157, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-modal-header h2 {
            margin: 0;
            color: #ff9d00;
            font-size: 28px;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 15px rgba(255, 157, 0, 0.5);
        }

        .info-close-btn {
            background: transparent;
            border: 2px solid rgba(255, 157, 0, 0.5);
            color: #ff9d00;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 28px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            line-height: 1;
        }

        .info-close-btn:hover {
            background: rgba(255, 157, 0, 0.2);
            transform: rotate(90deg);
            box-shadow: 0 0 20px rgba(255, 157, 0, 0.5);
        }

        .info-modal-body {
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .enemy-card {
            background: linear-gradient(145deg, rgba(30, 30, 35, 0.8) 0%, rgba(20, 20, 25, 0.9) 100%);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s;
        }

        .enemy-card:hover {
            border-color: rgba(255, 157, 0, 0.5);
            box-shadow: 0 0 20px rgba(255, 157, 0, 0.2);
            transform: translateY(-2px);
        }

        .enemy-card.speedy {
            border-left: 4px solid #0088ff;
        }

        .enemy-card.splitter {
            border-left: 4px solid #aa00ff;
        }

        .enemy-card.boss {
            border-left: 4px solid #ff0000;
            background: linear-gradient(145deg, rgba(40, 20, 20, 0.9) 0%, rgba(30, 15, 15, 0.95) 100%);
        }

        .enemy-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .enemy-icon {
            font-size: 32px;
        }

        .enemy-header h3 {
            margin: 0;
            color: #fff;
            font-size: 22px;
            flex: 1;
        }

        .enemy-type {
            background: rgba(255, 157, 0, 0.2);
            color: #ff9d00;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .enemy-card.speedy .enemy-type {
            background: rgba(0, 136, 255, 0.2);
            color: #0088ff;
        }

        .enemy-card.splitter .enemy-type {
            background: rgba(170, 0, 255, 0.2);
            color: #aa00ff;
        }

        .enemy-card.boss .enemy-type {
            background: rgba(255, 0, 0, 0.2);
            color: #ff4444;
        }

        .enemy-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 15px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
        }

        .stat-label {
            color: #999;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            color: #ff9d00;
            font-weight: 700;
            font-size: 13px;
        }

        .enemy-ability {
            background: rgba(0, 0, 0, 0.4);
            padding: 12px;
            border-radius: 6px;
            color: #ccc;
            font-size: 13px;
            line-height: 1.6;
        }

        .enemy-ability strong {
            color: #ff9d00;
        }

        .enemy-ability ul {
            margin: 8px 0 0 20px;
            padding: 0;
        }

        .enemy-ability li {
            margin: 6px 0;
        }


        /* Defense Mode HUD */
        #defense-hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }
        .defense-stat-row {
            display: flex;
            gap: 20px;
            margin-bottom: 5px;
        }
        .defense-badge {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #ff0000;
            color: #ff5555;
            padding: 5px 15px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 16px;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
        }
        .coin-badge {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #ffd700;
            color: #ffd700;
            padding: 5px 15px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 16px;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        #core-health-bar-wrap {
            width: 300px;
            height: 12px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #444;
            border-radius: 6px;
            overflow: hidden;
            margin-top: 5px;
            position: relative; /* Context for shield bar */
        }
        #core-health-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffaa00);
            transition: width 0.2s;
        }
        
        /* NEW: Core Shield Bar */
        #core-shield-bar-wrap {
            width: 300px;
            height: 8px; /* Thinner than health */
            background: rgba(0,0,0,0.6);
            border: 1px solid #0088ff;
            border-bottom: none; /* Connect to health bar */
            border-radius: 6px 6px 0 0;
            overflow: hidden;
            display: none; /* Hidden until unlocked */
            margin-bottom: -2px; /* Hug the health bar */
            z-index: 10;
        }
        #core-shield-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #0088ff, #00ffff);
            transition: width 0.2s;
            box-shadow: 0 0 10px #00ffff;
        }

        /* NEW: Defense Shop Styling - Redesigned as Modal */
        #defense-shop {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, rgba(10, 10, 15, 0.98) 0%, rgba(5, 5, 10, 0.98) 100%);
            padding: 0; 
            border: 2px solid rgba(255, 157, 0, 0.3);
            border-radius: 20px;
            display: none; 
            flex-direction: column;
            z-index: 150;
            width: 700px;
            min-width: 450px;
            box-shadow: 0 30px 60px -12px rgba(0, 0, 0, 0.95),
                        0 0 40px rgba(255, 157, 0, 0.1),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            pointer-events: auto;
            overflow: hidden;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        #defense-shop-header {
            background: linear-gradient(135deg, rgba(255, 157, 0, 0.25) 0%, rgba(255, 100, 0, 0.15) 100%);
            padding: 25px 30px;
            text-align: center;
            border-bottom: 2px solid rgba(255, 157, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        #defense-shop h2 {
            margin: 0;
            color: #ff9d00;
            text-transform: uppercase;
            font-size: 32px; 
            font-weight: 900;
            letter-spacing: 4px;
            text-shadow: 0 0 20px rgba(255, 157, 0, 0.6),
                         0 0 40px rgba(255, 157, 0, 0.3),
                         0 2px 4px rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        #defense-shop-content {
            padding: 25px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: 65vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 157, 0, 0.3) rgba(0, 0, 0, 0.2);
            background: linear-gradient(to bottom, 
                rgba(15, 15, 20, 0.5) 0%,
                rgba(10, 10, 15, 0.8) 100%);
        }

        /* NEW: Specific Grid Class for sub-sections */
        .shop-grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            width: 100%;
        }

        /* NEW: Group Container for complex items (Turret + Upgrades) */
        .shop-group-container {
            background: linear-gradient(145deg, rgba(20, 20, 25, 0.6) 0%, rgba(15, 15, 20, 0.8) 100%);
            border: 1px solid rgba(255, 157, 0, 0.15);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.4),
                        0 2px 4px rgba(255, 157, 0, 0.1);
        }

        /* Custom Scrollbar */
        #defense-shop-content::-webkit-scrollbar {
            width: 8px;
        }
        #defense-shop-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        #defense-shop-content::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, rgba(255, 157, 0, 0.4) 0%, rgba(255, 100, 0, 0.4) 100%);
            border-radius: 4px;
            border: 1px solid rgba(255, 157, 0, 0.2);
        }
        #defense-shop-content::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, rgba(255, 157, 0, 0.6) 0%, rgba(255, 100, 0, 0.6) 100%);
        }

        .shop-close-hint {
            text-align: center;
            color: rgba(255, 157, 0, 0.6);
            font-size: 11px;
            padding: 14px;
            background: linear-gradient(to top, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.2) 100%);
            text-transform: uppercase;
            letter-spacing: 2px;
            border-top: 1px solid rgba(255, 157, 0, 0.2);
            font-weight: 600;
            text-shadow: 0 0 8px rgba(255, 157, 0, 0.3);
        }

        /* NEW: Shop Section Headers */
        .shop-section-title {
            color: #ff9d00;
            font-size: 12px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 8px;
            margin-bottom: 8px;
            padding: 8px 12px;
            border-left: 4px solid #ff9d00;
            background: linear-gradient(90deg, rgba(255, 157, 0, 0.1) 0%, transparent 100%);
            border-radius: 4px;
            line-height: 1;
            text-shadow: 0 0 8px rgba(255, 157, 0, 0.4);
        }
        
        .shop-btn {
            background: linear-gradient(145deg, rgba(25, 25, 30, 0.8) 0%, rgba(15, 15, 20, 0.9) 100%);
            color: #666;
            border: 1.5px solid rgba(255, 255, 255, 0.08);
            padding: 14px;
            border-radius: 12px;
            cursor: not-allowed;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: space-between;
            min-height: 90px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .shop-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 157, 0, 0.1), transparent);
            transition: left 0.5s;
        }

        /* Affordable State */
        .shop-btn.affordable {
            background: linear-gradient(145deg, rgba(40, 35, 30, 0.95) 0%, rgba(30, 25, 20, 0.95) 100%);
            border-color: rgba(255, 157, 0, 0.4);
            color: #ffd700;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .shop-btn.affordable:hover {
            transform: translateY(-3px) scale(1.02);
            background: linear-gradient(145deg, rgba(50, 45, 40, 1) 0%, rgba(40, 35, 30, 1) 100%);
            border-color: #ff9d00;
            box-shadow: 0 8px 20px rgba(255, 157, 0, 0.3),
                        0 0 20px rgba(255, 157, 0, 0.2),
                        inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        
        .shop-btn.affordable:hover::before {
            left: 100%;
        }
        
        .shop-btn:active {
            transform: scale(0.97);
        }

        /* Inner Button Layout */
        .btn-label {
            display: flex;
            align-items: flex-start;
            width: 100%;
            gap: 12px;
            margin-bottom: 8px;
        }
        
        .btn-text-group {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .btn-main {
            font-weight: 800; /* UPDATED: Bolder */
            line-height: 1.2;
            color: #fff; /* UPDATED: Brighter white */
            font-size: 14px; /* UPDATED: Slightly larger */
            letter-spacing: 0.5px; /* UPDATED: Better spacing */
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        .shop-btn.affordable .btn-main {
            color: #fff;
        }
        
        .btn-sub {
            font-size: 10px; /* UPDATED: Larger */
            color: #999;
            font-weight: 600;
            text-transform: uppercase;
            margin-top: 4px; /* UPDATED: More spacing */
            letter-spacing: 0.5px;
        }
        .shop-btn.affordable .btn-sub {
            color: #ffaa00;
        }

        .btn-tiny-stats {
            font-size: 11px; /* UPDATED: Larger as requested */
            color: #00ffaa; /* UPDATED: Clean cyan color */
            margin-top: 4px;
            font-family: 'Consolas', monospace;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0, 255, 170, 0.3); /* UPDATED: Glow effect */
        }

        .shop-icon {
            font-size: 24px;
            background: linear-gradient(145deg, rgba(0,0,0,0.5) 0%, rgba(20,20,20,0.5) 100%);
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            filter: grayscale(1) brightness(0.5);
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        .shop-btn.affordable .shop-icon {
            filter: grayscale(0) brightness(1.2);
            background: linear-gradient(145deg, rgba(255, 157, 0, 0.2) 0%, rgba(255, 100, 0, 0.15) 100%);
            border-color: rgba(255, 157, 0, 0.3);
            box-shadow: 0 0 15px rgba(255, 157, 0, 0.3);
            transform: scale(1.1);
        }

        .btn-price {
            align-self: flex-end;
            color: #555;
            font-family: 'Consolas', 'Courier New', monospace;
            font-weight: 900;
            font-size: 13px;
            background: linear-gradient(145deg, rgba(0,0,0,0.6) 0%, rgba(20,20,20,0.6) 100%);
            padding: 6px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            letter-spacing: 1px;
        }
        .shop-btn.affordable .btn-price {
            color: #000;
            background: linear-gradient(145deg, #ffd700 0%, #ffaa00 100%);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5),
                        0 2px 4px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 200, 0, 0.5);
            transform: scale(1.05);
        }

        /* Sub-upgrade button (smaller, below main upgrade) */
        .shop-btn-sub {
            background: linear-gradient(145deg, rgba(20, 20, 25, 0.6) 0%, rgba(15, 15, 20, 0.8) 100%);
            color: #666;
            border: 1px solid rgba(255, 255, 255, 0.06);
            padding: 8px 12px;
            border-radius: 8px;
            cursor: not-allowed;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            min-height: 45px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            font-size: 12px;
        }

        .shop-btn-sub::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 157, 0, 0.1), transparent);
            transition: left 0.5s;
        }

        .shop-btn-sub.affordable {
            background: linear-gradient(145deg, rgba(35, 30, 25, 0.85) 0%, rgba(25, 20, 15, 0.85) 100%);
            border-color: rgba(255, 157, 0, 0.3);
            color: #ffd700;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }

        .shop-btn-sub.affordable:hover {
            transform: translateY(-2px);
            background: linear-gradient(145deg, rgba(45, 40, 35, 0.95) 0%, rgba(35, 30, 25, 0.95) 100%);
            border-color: #ff9d00;
            box-shadow: 0 4px 12px rgba(255, 157, 0, 0.2),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .shop-btn-sub.affordable:hover::before {
            left: 100%;
        }

        .shop-btn-sub:active {
            transform: translateY(0);
        }

        .shop-btn-sub .btn-label {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        .shop-btn-sub .shop-icon {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .shop-btn-sub.affordable .shop-icon {
            background: rgba(255, 157, 0, 0.2);
            border-color: rgba(255, 157, 0, 0.4);
        }

        .shop-btn-sub .btn-text-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .shop-btn-sub .btn-main {
            font-size: 11px;
            font-weight: 700;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .shop-btn-sub.affordable .btn-main {
            color: #ffd700;
        }

        .shop-btn-sub .btn-sub {
            font-size: 9px;
            color: #666;
            font-weight: 500;
        }

        .shop-btn-sub.affordable .btn-sub {
            color: #ffaa00;
        }

        .shop-btn-sub .btn-tiny-stats {
            font-size: 9px;
            color: #888;
            font-weight: 600;
        }

        .shop-btn-sub.affordable .btn-tiny-stats {
            color: #00ff88;
        }

        .shop-btn-sub .btn-price {
            color: #666;
            font-weight: 700;
            font-size: 14px;
        }

        .shop-btn-sub.affordable .btn-price {
            color: #ffd700;
            font-weight: 800;
            font-size: 16px;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
        }

        .shop-btn-sub:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Pause Menu & Game Over Screen Styles */
        .overlay-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 150;
            backdrop-filter: blur(5px);
        }
        .overlay-screen h1 {
            font-size: 60px;
            color: #fff;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff0000;
        }
        .overlay-stat {
            font-size: 24px;
            color: #ccc;
            margin-bottom: 40px;
        }
        .overlay-btn {
            padding: 15px 40px;
            font-size: 18px;
            background: transparent;
            border: 2px solid #fff;
            color: #fff;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            transition: 0.2s;
            margin: 10px;
            width: 250px;
        }
        .overlay-btn:hover {
            background: #fff;
            color: #000;
        }
        .overlay-btn.danger {
            border-color: #ff3333;
            color: #ff3333;
        }
        .overlay-btn.danger:hover {
            background: #ff3333;
            color: white;
        }

        /* NEW: Speedy Alert Styles */
        #speedy-alert {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff3300;
            font-size: 48px;
            font-weight: 900;
            text-transform: uppercase;
            text-shadow: 0 0 20px #ff0000, 0 0 10px #000;
            display: none;
            z-index: 100;
            animation: pulseAlert 0.4s infinite alternate;
            pointer-events: none;
            width: 100%;
            text-align: center;
            letter-spacing: 4px;
            background: linear-gradient(90deg, transparent, rgba(0,0,0,0.8), transparent);
            padding: 20px 0;
            border-top: 2px solid rgba(255, 50, 0, 0.5);
            border-bottom: 2px solid rgba(255, 50, 0, 0.5);
        }

        @keyframes pulseAlert {
            from { transform: translate(-50%, -50%) scale(1); opacity: 0.8; text-shadow: 0 0 10px #ff0000; }
            to { transform: translate(-50%, -50%) scale(1.1); opacity: 1; text-shadow: 0 0 30px #ff0000, 0 0 60px #ffaa00; }
        }

    </style>
    
    <!-- Suppress socket.io errors BEFORE loading the library -->
    <script>
        // Suppress WebSocket errors globally BEFORE socket.io loads
        (function() {
            const originalError = console.error;
            const originalWarn = console.warn;
            
            console.error = function(...args) {
                const errorStr = String(args[0] || '');
                const allArgs = args.map(a => String(a)).join(' ');
                // Suppress all socket.io/websocket related errors
                if (errorStr.includes('WebSocket') || errorStr.includes('socket.io') || 
                    errorStr.includes('websocket') || errorStr.includes('Connection error') ||
                    errorStr.includes('transport') || errorStr.includes('EIO') ||
                    errorStr.includes('ws://') || errorStr.includes('wss://') ||
                    allArgs.includes('websocket.js') || allArgs.includes('manager.js') ||
                    allArgs.includes('socket.io') || allArgs.includes('WebSocket connection')) {
                    return; // Suppress completely
                }
                originalError.apply(console, args);
            };
            
            console.warn = function(...args) {
                const warnStr = String(args[0] || '');
                const allArgs = args.map(a => String(a)).join(' ');
                if (warnStr.includes('WebSocket') || warnStr.includes('socket.io') || 
                    warnStr.includes('websocket') || warnStr.includes('ws://') || 
                    warnStr.includes('wss://') || allArgs.includes('socket.io')) {
                    return; // Suppress
                }
                originalWarn.apply(console, args);
            };
            
            // Store originals for restoration later
            window._originalConsoleError = originalError;
            window._originalConsoleWarn = originalWarn;
        })();
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>

</head>
<body>

    <!-- MAIN MENU -->
    <div id="main-menu">
        <div class="menu-content">
            <h1>Cube Defense</h1>
            <p>Defend the core from waves of enemies</p>
            <div class="menu-buttons">
                <button class="menu-btn primary" onclick="startDefenseMode()">
                    <span class="btn-icon">‚ñ∂</span>
                    <span class="btn-text">Start Game</span>
                </button>
                <button class="menu-btn primary" onclick="showMultiplayerLobby()">
                    <span class="btn-icon">üë•</span>
                    <span class="btn-text">Multiplayer</span>
                </button>
                <button class="menu-btn secondary" onclick="showEnemiesInfo()">
                    <span class="btn-icon">üëæ</span>
                    <span class="btn-text">Enemies</span>
                </button>
            </div>
        </div>
    </div>

    <!-- MULTIPLAYER LOBBY -->
    <div id="multiplayer-lobby" class="overlay-screen" style="display: none;">
        <div class="menu-content" style="max-width: 500px;">
            <h1 style="color: #ff9d00; margin-bottom: 30px;">Multiplayer Lobby</h1>
            
            <div id="lobby-options" style="display: flex; flex-direction: column; gap: 15px;">
                <button class="menu-btn primary" onclick="quickPlay()" style="width: 100%;">
                    <span class="btn-icon">‚ö°</span>
                    <span class="btn-text">Quick Play</span>
                </button>
                <button class="menu-btn primary" onclick="showJoinRoom()" style="width: 100%;">
                    <span class="btn-icon">üîó</span>
                    <span class="btn-text">Join Room</span>
                </button>
                <button class="menu-btn primary" onclick="createRoom()" style="width: 100%;">
                    <span class="btn-icon">‚ûï</span>
                    <span class="btn-text">Create Room</span>
                </button>
                <button class="menu-btn secondary" onclick="closeMultiplayerLobby()" style="width: 100%;">
                    <span class="btn-icon">‚Üê</span>
                    <span class="btn-text">Back</span>
                </button>
            </div>

            <div id="join-room-form" style="display: none; flex-direction: column; gap: 15px; margin-top: 20px;">
                <h3 style="color: #fff; margin: 0;">Enter Room Code</h3>
                <input type="text" id="room-code-input" placeholder="ABCD12" maxlength="6" 
                       style="padding: 15px; font-size: 24px; text-align: center; letter-spacing: 5px; 
                              text-transform: uppercase; background: rgba(0,0,0,0.5); border: 2px solid #ff9d00; 
                              color: #fff; border-radius: 8px; font-family: monospace;">
                <div style="display: flex; gap: 10px;">
                    <button class="menu-btn primary" onclick="joinRoomByCode()" style="flex: 1;">
                        <span class="btn-text">Join</span>
                    </button>
                    <button class="menu-btn secondary" onclick="returnToMainMenu()" style="flex: 1;">
                        <span class="btn-icon">‚Üê</span>
                        <span class="btn-text">Return to Menu</span>
                    </button>
                </div>
            </div>

            <div id="room-info" style="display: none; margin-top: 20px; padding: 20px; 
                                       background: rgba(0,0,0,0.5); border-radius: 8px; border: 2px solid #ff9d00;">
                <h3 style="color: #ff9d00; margin: 0 0 10px 0;">Room Code</h3>
                <div id="room-code-display" style="font-size: 32px; font-weight: bold; color: #fff; 
                                                   letter-spacing: 8px; font-family: monospace; text-align: center; 
                                                   padding: 15px; background: rgba(255,157,0,0.2); border-radius: 8px; 
                                                   margin-bottom: 15px;"></div>
                <p style="color: #aaa; margin: 0; text-align: center; font-size: 14px; margin-bottom: 15px;">
                    Share this code with friends to join your room
                </p>
                
                <div style="margin-bottom: 15px;">
                    <label style="color: #fff; font-size: 14px; display: block; margin-bottom: 8px;">Shareable Link</label>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <input type="text" id="shareable-link-input" readonly
                               style="flex: 1; padding: 10px; font-size: 12px; background: rgba(0,0,0,0.5); 
                                      border: 2px solid #ff9d00; color: #fff; border-radius: 6px; 
                                      font-family: monospace; box-sizing: border-box;">
                        <button class="menu-btn secondary" onclick="copyShareableLink()" 
                                style="padding: 10px 15px; min-width: auto;">
                            <span class="btn-text">Copy</span>
                        </button>
                    </div>
                    <p style="color: #aaa; margin: 8px 0 0 0; text-align: center; font-size: 11px;">
                        Send this link to friends - they can click it to join automatically!
                    </p>
                </div>
                
                <button class="menu-btn primary" onclick="startGameFromLobby()" style="width: 100%; margin-top: 15px;">
                    <span class="btn-text">Start Game</span>
                </button>
                <button class="menu-btn secondary" onclick="returnToMainMenu()" style="width: 100%; margin-top: 10px;">
                    <span class="btn-icon">‚Üê</span>
                    <span class="btn-text">Return to Menu</span>
                </button>
            </div>

            <div id="connection-status" style="margin-top: 20px; padding: 10px; text-align: center; 
                                               color: #ff6666; display: none;"></div>
        </div>
    </div>

    <!-- QUICK PLAY WAIT OVERLAY -->
    <div id="quickplay-wait" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                                     background: rgba(0,0,0,0.65); backdrop-filter: blur(4px); 
                                     z-index: 1500; align-items: center; justify-content: center;">
        <div style="padding: 24px 32px; background: rgba(20,20,20,0.9); border: 2px solid #ff9d00; border-radius: 12px; 
                    box-shadow: 0 10px 30px rgba(0,0,0,0.6); color: #fff; font-size: 20px; font-weight: 700; 
                    text-align: center; min-width: 340px; max-width: 420px;">
            <div id="quickplay-wait-text" style="margin-bottom: 12px;">Waiting for player...</div>
            <div style="margin-bottom: 12px; font-size: 14px; color: #ffcc80;">Stay here ‚Äî game will start automatically when another player joins.</div>
            <div id="quickplay-wait-list" style="margin-top: 8px; font-size: 14px; color: #fff; background: rgba(255,255,255,0.05); padding: 12px; border-radius: 8px; text-align: left;">
            </div>
        </div>
    </div>

    <!-- Enemies Information Modal -->
    <div id="enemies-info-modal" class="info-modal">
        <div class="info-modal-content">
            <div class="info-modal-header">
                <h2>Enemy Database</h2>
                <button class="info-close-btn" onclick="closeEnemiesInfo()">√ó</button>
            </div>
            <div class="info-modal-body">
                <!-- Standard Enemy -->
                <div class="enemy-card">
                    <div class="enemy-header">
                        <span class="enemy-icon">‚ö´</span>
                        <h3>Obsidian Breaker</h3>
                        <span class="enemy-type">Standard</span>
                    </div>
                    <div class="enemy-stats">
                        <div class="stat-item">
                            <span class="stat-label">Health:</span>
                            <span class="stat-value">64 HP</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Speed:</span>
                            <span class="stat-value">Normal</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Coins:</span>
                            <span class="stat-value">$9</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Spawn:</span>
                            <span class="stat-value">10 + (Wave-1) √ó 2-3</span>
                        </div>
                    </div>
                    <div class="enemy-ability">
                        <strong>Special Ability:</strong> None - Basic enemy unit
                    </div>
                </div>

                <!-- Speedy Enemy -->
                <div class="enemy-card speedy">
                    <div class="enemy-header">
                        <span class="enemy-icon">üí®</span>
                        <h3>Swift Striker</h3>
                        <span class="enemy-type">Fast</span>
                    </div>
                    <div class="enemy-stats">
                        <div class="stat-item">
                            <span class="stat-label">Health:</span>
                            <span class="stat-value">29 HP</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Speed:</span>
                            <span class="stat-value">Very Fast (112% faster)</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Coins:</span>
                            <span class="stat-value">$15</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Spawn:</span>
                            <span class="stat-value">2-3 per wave (after 50%)</span>
                        </div>
                    </div>
                    <div class="enemy-ability">
                        <strong>Special Ability:</strong> Feinting - Can fake attacks to confuse defenders
                    </div>
                </div>

                <!-- Splitter Enemy -->
                <div class="enemy-card splitter">
                    <div class="enemy-header">
                        <span class="enemy-icon">üí•</span>
                        <h3>Void Fragment</h3>
                        <span class="enemy-type">Elite</span>
                    </div>
                    <div class="enemy-stats">
                        <div class="stat-item">
                            <span class="stat-label">Health:</span>
                            <span class="stat-value">159 HP</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Speed:</span>
                            <span class="stat-value">Slow (70% of normal)</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Coins:</span>
                            <span class="stat-value">$20</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Spawn:</span>
                            <span class="stat-value">1 every 3 waves (Wave 3+)</span>
                        </div>
                    </div>
                    <div class="enemy-ability">
                        <strong>Special Ability:</strong> Splits into 2 smaller enemies on death
                    </div>
                </div>

                <!-- Boss Enemy -->
                <div class="enemy-card boss">
                    <div class="enemy-header">
                        <span class="enemy-icon">üëπ</span>
                        <h3>Omega Construct</h3>
                        <span class="enemy-type">Boss</span>
                    </div>
                    <div class="enemy-stats">
                        <div class="stat-item">
                            <span class="stat-label">Health:</span>
                            <span class="stat-value">539 HP</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Speed:</span>
                            <span class="stat-value">Slow (Heavy)</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Coins:</span>
                            <span class="stat-value">$360</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Spawn:</span>
                            <span class="stat-value">1 per wave (Last enemy)</span>
                        </div>
                    </div>
                    <div class="enemy-ability">
                        <strong>Special Abilities:</strong>
                        <ul>
                            <li>Jump Attack - Leaps into the air and crashes down</li>
                            <li>Shockwave Rings - Expands damaging rings outward</li>
                            <li>Healing Touch - Heals 25% HP if player doesn't jump over shockwave</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Pause Menu -->
    <div id="pause-menu" class="overlay-screen">
        <h1>PAUSED</h1>
        <button class="overlay-btn" onclick="resumeGame()">Resume</button>
        <button class="overlay-btn danger" onclick="quitToMainMenu()">Return to Menu</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="overlay-screen">
        <h1 style="color:#ff3333">GAME OVER</h1>
        <div class="overlay-stat" id="game-over-stats">Wave 1 Completed</div>
        <button class="overlay-btn" onclick="startDefenseMode()">Retry</button>
        <button class="overlay-btn danger" onclick="quitToMainMenu()">Return to Menu</button>
    </div>

    
    <div id="hud">
        <div id="crosshair"></div>

        <!-- NEW: Speedy Incoming Alert -->
        <div id="speedy-alert">SPEEDY'S INCOMING!!</div>

        <!-- Defense HUD -->
        <div id="defense-hud">
            <div class="defense-stat-row">
                <div class="defense-badge">WAVE <span id="wave-num">1</span></div>
                <div class="defense-badge">ENEMIES <span id="enemy-count">0</span></div>
                <!-- NEW: Coins Display -->
                <div class="coin-badge">$ <span id="coin-count">0</span></div>
            </div>
            
            <!-- NEW: Shield Bar (Above Health) -->
            <div id="core-shield-bar-wrap">
                <div id="core-shield-fill"></div>
            </div>

            <div id="core-health-bar-wrap">
                <div id="core-health-fill"></div>
            </div>
            
            <div style="margin-top:8px; color:#ffd700; font-weight:bold; font-size:12px; text-shadow:0 1px 2px black;">
                Press [B] for Shop
            </div>
        </div>

        <!-- RESTRUCTURED: Defense Shop Modal -->
        <div id="defense-shop">
            <div id="defense-shop-header">
                <h2><span style="font-size:18px">üõ°Ô∏è</span> ARMORY</h2>
                <div style="font-size:11px; color:#666; font-weight:bold;">UPGRADES</div>
            </div>
            <div id="defense-shop-content">
                
                <!-- Section 1: Core Support -->
                <div class="shop-section-title">Core Support</div>
                <div class="shop-grid-2">
                    <button class="shop-btn" id="btn-repair" onclick="buyRepair()">
                         <!-- Content injected by JS -->
                    </button>
                </div>
                <!-- NEW: Aurora Shield Group (Main + Upgrades) -->
                <div class="shop-group-container" style="margin-top: 8px;">
                    <!-- Main Barrier Button -->
                    <button class="shop-btn" id="btn-barrier" onclick="buyBarrier()" style="width: 100%;">
                         <!-- Content injected by JS -->
                    </button>
                    
                    <!-- Barrier Upgrades Right Underneath -->
                    <div class="shop-grid-2">
                        <button class="shop-btn" id="btn-barrier-size" onclick="buyBarrierSizeUpgrade()">
                             <!-- Content injected by JS -->
                        </button>
                        <button class="shop-btn" id="btn-barrier-wall" onclick="buyBarrierWallUpgrade()">
                             <!-- Content injected by JS -->
                        </button>
                        <button class="shop-btn" id="btn-barrier-thorns" onclick="buyBarrierThornsUpgrade()">
                        <!-- Content injected by JS -->
                    </button>
                    </div>
                </div>
                <!-- NEW: Shield Group (Main + Upgrades) -->
                <div class="shop-group-container" style="margin-top: 8px;">
                    <!-- Main Shield Button -->
                    <button class="shop-btn" id="btn-shield" onclick="buyCoreShieldUpgrade()" style="width: 100%;">
                         <!-- Content injected by JS -->
                    </button>
                    
                    <!-- Shield Upgrades Right Underneath -->
                    <div class="shop-grid-2">
                        <button class="shop-btn" id="btn-shield-regen" onclick="buyShieldRegenUpgrade()">
                             <!-- Content injected by JS -->
                        </button>
                        <button class="shop-btn" id="btn-shield-durability" onclick="buyShieldDurabilityUpgrade()">
                             <!-- Content injected by JS -->
                        </button>
                    </div>
                </div>

                <!-- Section 2: Automated Defenses (Grouped) -->
                <div class="shop-section-title">Automated Defenses</div>
                <div class="shop-group-container">
                    <!-- Main Deployable -->
                    <button class="shop-btn" id="btn-turret" onclick="buyTurret()" style="width: 100%;">
                         <!-- Content injected by JS -->
                    </button>
                    
                    <!-- Upgrades Right Underneath -->
                    <div class="shop-grid-2">
                        <button class="shop-btn" id="btn-turret-fire" onclick="buyTurretFireRate()">
                             <!-- Content injected by JS -->
                        </button>
                        <button class="shop-btn" id="btn-turret-range" onclick="buyTurretRange()">
                             <!-- Content injected by JS -->
                        </button>
                    </div>
                </div>

                <!-- Section 3: Abilities -->
                <div class="shop-section-title">Abilities & Ultimates</div>
                <div class="shop-grid-2">
                    <button class="shop-btn" id="btn-grab" onclick="buyGrabUpgrade()">
                         <!-- Content injected by JS -->
                    </button>
                    <button class="shop-btn" id="btn-nuke" onclick="buyNuke()">
                         <!-- Content injected by JS -->
                    </button>
                </div>

                <!-- Section 4: Weapons -->
                <div class="shop-section-title">Weapons & Upgrades</div>
                <div class="shop-grid-2">
                    <!-- Mass Cannon Upgrade with Max Charge sub-upgrade -->
                    <div class="shop-group-container">
                        <button class="shop-btn" id="btn-buy-heavy" onclick="buyMassCannonUpgrade()">
                             <!-- Content injected by JS -->
                        </button>
                        <button class="shop-btn-sub" id="btn-buy-maxcharge" onclick="buyMaxChargeUpgrade()">
                             <!-- Content injected by JS -->
                        </button>
                    </div>

                    <button class="shop-btn" id="btn-buy-explosive" onclick="buyWeapon('explosive')">
                         <!-- Content injected by JS -->
                    </button>
                    <button class="shop-btn" id="btn-buy-raygun" onclick="buyWeapon('raygun')">
                         <!-- Content injected by JS -->
                    </button>
                    <button class="shop-btn" id="btn-buy-shockwave" onclick="buyWeapon('shockwave')">
                         <!-- Content injected by JS -->
                    </button>
                    <button class="shop-btn" id="btn-buy-blackhole" onclick="buyWeapon('blackhole')">
                         <!-- Content injected by JS -->
                    </button>
                </div>

            </div>
            <div class="shop-close-hint">Press [B] to Close</div>
        </div>

        <div id="ui-controls">
            <h1>PHYSICS SMASH</h1>
            <div class="controls">
                <p style="margin-top:0"><b>Controls:</b></p>
                <div style="margin-bottom: 4px;">
                    <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> Move<br>
                    <span class="key">Space</span> Jump<br>
                    <span class="key">R-Click</span> Build/Throw<br>
                    <span class="key">Shift</span> Slow Mo<br>
                    <span class="key">B</span> Shop (Defense)<br>
                    <span class="key">Tab</span> Hide UI
                </div>
                <div style="margin-bottom: 4px;">
                    <span class="key">1</span>-<span class="key">9</span> Struct<br>
                    <span class="key">Q</span> Ammo<br>
                    <span class="key">E</span> Eraser Mode<br>
                    <span class="key">R</span> Clear<br>
                    <span class="key">Scroll</span> Size<br>
                    <span class="key">Y</span>/<span class="key">U</span> Reach<br>
                    <span class="key">Hold T</span> + <span class="key">Scroll</span> Form Speed
                </div>
            </div>
        </div>

        <div id="status" class="status-badge">READY</div>
        <div id="fps-tracker" style="position: absolute; top: 50px; right: 10px; padding: 5px 12px; background: rgba(0,0,0,0.5); color: rgba(255,255,255,0.7); border-radius: 15px; font-weight: bold; font-size: 11px; z-index: 10; pointer-events: none;">FPS: --</div>
        <div id="slowmo" class="slow-mo-badge">SLOW MOTION</div>
        
        <!-- Shockwave Charge Bar -->
        <div id="charge-bar-wrap" class="charge-container">
            <div class="charge-text">CHARGE</div>
            <div id="charge-bar-fill" class="charge-fill"></div>
        </div>

        <!-- 1. Ammo Buttons -->
        <div id="ammo-menu">
            <!-- UPDATED: Renamed Heavy to Mass Cannon -->
            <button class="ammo-btn selected" onclick="setAmmo('heavy')" id="btn-heavy">Mass Cannon</button>
            <button class="ammo-btn" onclick="setAmmo('explosive')" id="btn-explosive">Explosive</button>
            <button class="ammo-btn" onclick="setAmmo('blackhole')" id="btn-blackhole">Black Hole</button>
            <button class="ammo-btn" onclick="setAmmo('raygun')" id="btn-raygun">Mag-Lev</button>
            <button class="ammo-btn" onclick="setAmmo('shockwave')" id="btn-shockwave">Shockwave</button>
        </div>

        <div class="game-menus">
            
            <!-- 2. Sliders -->
            <div id="grab-slider-container" class="slider-container">
                <span id="slider-label">Grab Size:</span>
                <!-- CHANGED: step to 5 to match new upgrade increment -->
                <input type="range" id="grab-radius-slider" min="10" max="250" value="10" step="5">
                <span id="grab-radius-val">10</span>
            </div>

            <div id="form-speed-container" class="slider-container">
                <span>Form Speed:</span>
                <input type="range" id="form-speed-slider" min="0.01" max="0.4" value="0.04" step="0.01">
                <span id="form-speed-val">0.04</span>
            </div>

            <div id="eraser-dist-container" class="eraser-dist-container">
                <span>Max Reach:</span>
                <span id="eraser-dist-val">50</span>
            </div>


        </div>
    </div>

    <div id="canvas-container"></div>

    <script>

        const originalWarn = console.warn;
        const originalError = console.error;
        const filterMsg = "points into the shape";

        console.warn = function(...args) {
            if (args[0] && typeof args[0] === 'string' && args[0].includes(filterMsg)) return;
            originalWarn.apply(console, args);
        };
        console.error = function(...args) {
            if (args[0] && typeof args[0] === 'string' && args[0].includes(filterMsg)) return;
            originalError.apply(console, args);
        };

        const CONFIG = {
            ballSpeed: 90, 
            ballMass: 800, 
            ballRadius: 1.5, 
            boxMass: 30, 
            boxSize: 2, 
            moveSpeed: 33.75, 
            jumpForce: 25, // Lower jump height 
            maxBoxes: 2800, 
            grabRadius: 10, 
            defaultGrabDistance: 42.2,
            colors: [0xef476f, 0xffd166, 0x06d6a0, 0x118ab2, 0x073b4c],
            slowMoScale: 0.2
        };


        const SoundManager = {
            ctx: null,
            lastChargeTime: 0,
            heavyChargeOsc: null,
            heavyChargeGain: null,
            heavyChargeFilter: null,

            init: function() {
                if (!this.ctx) {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },
            createOscillator: function(type, freq, detune = 0) {
                if(!this.ctx) return null;
                const osc = this.ctx.createOscillator();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if(detune) osc.detune.setValueAtTime(detune, this.ctx.currentTime);
                return osc;
            },
            createHum: function(freq) {
                 if(!this.ctx) return null;
                 const osc = this.ctx.createOscillator();
                 const gain = this.ctx.createGain();
                 osc.type = 'sawtooth';
                 osc.frequency.value = freq;
                 
                 const filter = this.ctx.createBiquadFilter();
                 filter.type = 'lowpass';
                 filter.frequency.value = 120;

                 osc.connect(filter);
                 filter.connect(gain);
                 gain.connect(this.ctx.destination);
                 
                 gain.gain.value = 0; 
                 osc.start();
                 return { osc, gain };
            },
            playShoot: function(type) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);

                if (type === 'heavy') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(100, t);
                    osc.frequency.exponentialRampToValueAtTime(30, t + 0.15);
                    gain.gain.setValueAtTime(0.25, t); 
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                    osc.start(t);
                    osc.stop(t + 0.15);
                } else if (type === 'explosive') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(400, t); 
                    osc.frequency.exponentialRampToValueAtTime(50, t + 0.25);
                    gain.gain.setValueAtTime(0.2, t); 
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.25);
                    osc.start(t);
                    osc.stop(t + 0.25);
                } else if (type === 'blackhole') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(60, t); 
                    osc.frequency.linearRampToValueAtTime(20, t + 0.5);
                    gain.gain.setValueAtTime(0.4, t); 
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                    osc.start(t);
                    osc.stop(t + 0.5);
                } else if (type === 'raygun') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(600, t); 
                    osc.frequency.exponentialRampToValueAtTime(150, t + 0.2);
                    gain.gain.setValueAtTime(0.15, t); 
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                    osc.start(t);
                    osc.stop(t + 0.2);
                }
            },
            playExplosion: function() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const bufferSize = this.ctx.sampleRate * 2; 
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(500, t); 
                filter.frequency.exponentialRampToValueAtTime(50, t + 1.5);

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.8, t); 
                gain.gain.exponentialRampToValueAtTime(0.01, t + 1.5);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start(t);
            },
            playJump: function() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(100, t); 
                osc.frequency.linearRampToValueAtTime(200, t + 0.1);
                
                gain.gain.setValueAtTime(0.2, t); 
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                
                osc.start(t);
                osc.stop(t + 0.2);
            },
            playCharge: function(level) {
                if (!this.ctx) return;
                
                if (level > 0.95) return;

                const t = this.ctx.currentTime;
                const interval = 0.12 - (level * 0.08);

                if (t - this.lastChargeTime > interval) {
                    this.lastChargeTime = t;

                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.ctx.destination);

                    osc.type = 'sawtooth';
                    const baseFreq = 30 + (level * 150);
                    
                    osc.frequency.setValueAtTime(baseFreq, t);
                    osc.frequency.linearRampToValueAtTime(baseFreq + 30, t + interval/2);
                    osc.frequency.linearRampToValueAtTime(baseFreq, t + interval);

                    filter.type = 'lowpass';
                    filter.Q.value = 8; 
                    filter.frequency.setValueAtTime(100, t);
                    filter.frequency.linearRampToValueAtTime(400 + (level * 600), t + interval/2); 
                    filter.frequency.linearRampToValueAtTime(100, t + interval); 

                    gain.gain.setValueAtTime(0.15, t); 
                    gain.gain.exponentialRampToValueAtTime(0.01, t + interval);
                    
                    osc.start(t);
                    osc.stop(t + interval + 0.05);
                }
            },
            
            updateHeavyCharge: function(level) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                
                if (!this.heavyChargeOsc) {
                    this.heavyChargeOsc = this.ctx.createOscillator();
                    this.heavyChargeGain = this.ctx.createGain();
                    this.heavyChargeFilter = this.ctx.createBiquadFilter();

                    this.heavyChargeOsc.type = 'sawtooth'; 
                    this.heavyChargeFilter.type = 'lowpass';
                    this.heavyChargeFilter.Q.value = 6; 

                    this.heavyChargeOsc.connect(this.heavyChargeFilter);
                    this.heavyChargeFilter.connect(this.heavyChargeGain);
                    this.heavyChargeGain.connect(this.ctx.destination);

                    this.heavyChargeOsc.start(t);
                    
                    this.heavyChargeGain.gain.setValueAtTime(0, t);
                    this.heavyChargeGain.gain.linearRampToValueAtTime(0.1, t + 0.1);
                }

                const freq = 40 + (level * 80); 
                this.heavyChargeOsc.frequency.setTargetAtTime(freq, t, 0.1);

                const filterFreq = 100 + (level * 300);
                this.heavyChargeFilter.frequency.setTargetAtTime(filterFreq, t, 0.1);
            },

            stopHeavyCharge: function() {
                if (this.heavyChargeOsc) {
                    if(!this.ctx) return;
                    const t = this.ctx.currentTime;
                    
                    try {
                        this.heavyChargeGain.gain.cancelScheduledValues(t);
                        this.heavyChargeGain.gain.setValueAtTime(this.heavyChargeGain.gain.value, t);
                        this.heavyChargeGain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
                        
                        const osc = this.heavyChargeOsc;
                        setTimeout(() => { 
                            try { osc.stop(); } catch(e){} 
                        }, 250);
                    } catch(e) {}
                    
                    this.heavyChargeOsc = null;
                    this.heavyChargeGain = null;
                    this.heavyChargeFilter = null;
                }
            },

            playBossLanding: function() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                
                // Create a deep "boooom" sound
                const osc = this.ctx.createOscillator();
                const oscGain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                osc.connect(filter);
                filter.connect(oscGain);
                oscGain.connect(this.ctx.destination);
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(40, t); // Very low frequency for "boom"
                osc.frequency.exponentialRampToValueAtTime(30, t + 0.3);
                osc.frequency.exponentialRampToValueAtTime(20, t + 0.8);
                
                filter.type = 'lowpass';
                filter.Q.value = 5;
                filter.frequency.setValueAtTime(100, t);
                filter.frequency.exponentialRampToValueAtTime(50, t + 0.5);
                
                oscGain.gain.setValueAtTime(0.6, t);
                oscGain.gain.exponentialRampToValueAtTime(0.01, t + 1.2);
                
                osc.start(t);
                osc.stop(t + 1.2);
                
                // Add some noise for impact
                const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - (i / bufferSize), 2);
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                
                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'lowpass';
                noiseFilter.frequency.setValueAtTime(200, t);
                noiseFilter.frequency.exponentialRampToValueAtTime(50, t + 0.3);
                
                const noiseGain = this.ctx.createGain();
                noiseGain.gain.setValueAtTime(0.3, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                
                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(this.ctx.destination);
                
                noise.start(t);
                noise.stop(t + 0.5);
            },

            playShockwave: function() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;

                const osc = this.ctx.createOscillator();
                const oscGain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                osc.connect(filter);
                filter.connect(oscGain);
                oscGain.connect(this.ctx.destination);

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t); 
                osc.frequency.linearRampToValueAtTime(600, t + 0.1); 
                osc.frequency.exponentialRampToValueAtTime(100, t + 0.6); 

                filter.type = 'lowpass';
                filter.Q.value = 8; 
                filter.frequency.setValueAtTime(200, t);
                filter.frequency.linearRampToValueAtTime(2000, t + 0.15); 
                filter.frequency.exponentialRampToValueAtTime(100, t + 0.6); 

                oscGain.gain.setValueAtTime(0.25, t);
                oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.6);

                osc.start(t);
                osc.stop(t + 0.6);

                const bufferSize = this.ctx.sampleRate * 1.5; 
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'highpass'; 
                noiseFilter.frequency.setValueAtTime(500, t);
                noiseFilter.frequency.linearRampToValueAtTime(100, t + 1.0); 

                const noiseGain = this.ctx.createGain();
                noiseGain.gain.setValueAtTime(0.4, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 1.2); 

                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(this.ctx.destination);
                noise.start(t);

                const sub = this.ctx.createOscillator();
                const subGain = this.ctx.createGain();
                sub.connect(subGain);
                subGain.connect(this.ctx.destination);
                
                sub.type = 'sine';
                sub.frequency.setValueAtTime(120, t); 
                sub.frequency.exponentialRampToValueAtTime(30, t + 0.4); 
                
                subGain.gain.setValueAtTime(0.8, t);
                subGain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                
                sub.start(t);
                sub.stop(t + 0.4);
            },
            
            playCash: function() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                
                // Simple high-pitched "ding"
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, t);
                osc.frequency.exponentialRampToValueAtTime(1800, t + 0.1);
                
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                
                osc.start(t);
                osc.stop(t + 0.5);
            }
        };


        
        let scene, camera, renderer; 
        let world, timeStep = 1 / 60;
        let raycaster, centerScreen;
        
        let lastBlackHoleTime = 0;
        let lastGeneralFireTime = 0;
        let lastExplosionTime = 0;
        let lastShockwaveTime = 0;

        const _v1 = new THREE.Vector3();
        const _v2 = new THREE.Vector3();
        const _v3 = new THREE.Vector3(); 
        const _beamPos = new Float32Array(6);
        const _shockDir = new CANNON.Vec3(); 
        
        let projectiles = [];
        
        let explosions = []; 
        let activeBlackHoles = []; 
        let collidables = []; 
        
        
        let dummy = new THREE.Object3D();

        
        let jointBody; 
        let gravityConstraints = []; 
        let grabbedBodies = [];
        let beamLag = new THREE.Vector3(); 
        let grabRotation = 0; 
        
        let currentGrabDistance = CONFIG.defaultGrabDistance;
        let currentFormationSpeed = 0.04; 
        
        let isHoldingT = false;

        let sharedBoxGeometry;
        let playerBody;
        let canJump = false;
        
        
        let gameState = 'menu'; 
        let isAiming = false;
        let isLocked = false;
        let currentAmmo = 'heavy';
        let isSlowMo = false;
        let isShopOpen = false;
        const SHOP_SLOWDOWN = 0.3; // 70% slowdown = 30% speed

        let screenShake = 0;

        // Shockwave variables
        let isChargingShockwave = false;
        let shockwaveCharge = 0;
        let shockwaveChargeMesh; 
        let shockwaves = []; 

        // Gravity Gun Throw Charge Variables
        let isChargingThrow = false;
        let throwCharge = 0;

        // NEW: Heavy Ball Charge Variables
        let isChargingFire = false;
        let fireChargeStart = 0;

        // Eraser variables
        let isEraserMode = false;
        let isErasing = false;
        let eraserRadius = 10;
        let eraserMaxDistance = 50; 
        let eraserMarker;
        
        // NEW: Cube Defense Variables
        let isDefenseMode = false;
        let defenseCoreBody = null;
        let defenseCoreMesh = null;
        let defenseEnemies = []; 
        let defenseTurrets = []; 
        let defenseBarriers = []; // NEW: Track barriers
        let defenseWave = 1;
        let defenseCoreHealth = 100;
        let enemiesToSpawn = 0;
        // NEW: Track total for the wave to calculate "halfway" point
        let totalEnemiesForWave = 0; 
        let nextSpawnTime = 0;
        let waveInProgress = false;
        // MULTIPLAYER: Deterministic spawn counter for fixed positions
        let enemySpawnCounter = 0;
        
        // MULTIPLAYER: Fixed spawn positions array - same for all clients
        const FIXED_SPAWN_POSITIONS = (() => {
            const positions = [];
            const numPositions = 200; // Enough positions for many waves
            const baseDist = 255; // Standard distance
            const bossBaseDist = 420; // Boss distance
            const speedyBaseDist = 250; // Speedy distance
            const splitterBaseDist = 235; // Splitter distance
            
            // Generate evenly distributed positions around the core
            for (let i = 0; i < numPositions; i++) {
                const angle = (i * 137.508) % 360 * (Math.PI / 180); // Golden angle for even distribution
                const distVariation = (i * 7919) % 100 / 100; // Deterministic variation
                
                // Regular enemy positions
                const regularDist = baseDist + distVariation * 110;
                positions.push({
                    x: Math.cos(angle) * regularDist,
                    z: Math.sin(angle) * regularDist
                });
            }
            
            // Add boss positions (further out, every 10th slot)
            for (let i = 0; i < numPositions; i += 10) {
                const angle = (i * 137.508) % 360 * (Math.PI / 180);
                const distVariation = (i * 7919) % 100 / 100;
                const bossDist = bossBaseDist + distVariation * 40;
                positions.push({
                    x: Math.cos(angle + Math.PI / 4) * bossDist,
                    z: Math.sin(angle + Math.PI / 4) * bossDist
                });
            }
            
            // Add speedy positions (every 5th slot, offset)
            for (let i = 2; i < numPositions; i += 5) {
                const angle = (i * 137.508) % 360 * (Math.PI / 180);
                const distVariation = (i * 7919) % 100 / 100;
                const speedyDist = speedyBaseDist + distVariation * 50;
                positions.push({
                    x: Math.cos(angle + Math.PI / 6) * speedyDist,
                    z: Math.sin(angle + Math.PI / 6) * speedyDist
                });
            }
            
            // Add splitter positions (every 7th slot, offset)
            for (let i = 4; i < numPositions; i += 7) {
                const angle = (i * 137.508) % 360 * (Math.PI / 180);
                const distVariation = (i * 7919) % 100 / 100;
                const splitterDist = splitterBaseDist + distVariation * 60;
                positions.push({
                    x: Math.cos(angle - Math.PI / 8) * splitterDist,
                    z: Math.sin(angle - Math.PI / 8) * splitterDist
                });
            }
            
            return positions;
        })();

        // MULTIPLAYER Variables
        let socket = null;
        let isMultiplayerEnabled = true; // Set to false to disable multiplayer
        let currentRoomId = 'default';
        let myPlayerId = null;
        let otherPlayers = new Map(); // playerId -> {mesh, position, etc}
        let lastPositionUpdate = 0;
        const POSITION_UPDATE_INTERVAL = 500; // Update position every 500ms
        let isHost = false; // First player in room is host
        let lastGameStateSync = 0; // Last time game state was synced (host only)
        let networkEnemies = new Map(); // Track enemies by network ID
        let unlockedWeapons = ['heavy']; // Global unlocked weapons list
        let isPlayerPaused = false; // Player-specific pause (game continues)
        function clearEnemies() {
            if (defenseEnemies && defenseEnemies.length) {
                for (let i = defenseEnemies.length - 1; i >= 0; i--) {
                    const e = defenseEnemies[i];
                    if (e && e.body) {
                        try { world.removeBody(e.body); } catch (err) {}
                    }
                    if (e && e.mesh) {
                        try { scene.remove(e.mesh); } catch (err) {}
                    }
                    defenseEnemies.splice(i, 1);
                }
            }
            if (networkEnemies) networkEnemies.clear();
        }
        
        // NEW: Flag for alert
        let placementGhost = null; // NEW: Track the hologram
        let isPlacingBarrier = false; // NEW: State flag
        let placementRotationOffset = 0; // NEW: Manual rotation
        
        // NEW: Aurora Shield Upgrade Levels
        let barrierSizeLevel = 0; // 0-2 (2 purchases)
        let barrierWallCount = 0; // 0-1 (1 purchase)
        let barrierThornsLevel = 0; // 0-3 (3 purchases)

        // Economy
        let defenseCoins = 0;
        
        // NEW: Dynamic Shop Costs State
        // FIXED: All prices increased by 15%
        let shopCosts = {
            repair: Math.floor(100 * 1.15), // 115
            barrier: Math.floor(150 * 1.15), // 173
            grab: Math.floor(250 * 1.15), // 288
            turret: Math.floor(300 * 1.15), // 345
            nuke: Math.floor(500 * 1.15), // 575
            // Weapons
            explosive: Math.floor(250 * 1.15), // 288
            raygun: Math.floor(350 * 1.15), // 403
            shockwave: Math.floor(450 * 1.15), // 518
            blackhole: Math.floor(1000 * 1.15), // 1150
            // Upgrades
            upgradeHeavy: Math.floor(200 * 1.15), // 230
            upgradeMaxCharge: Math.floor(400 * 1.15), // 460
            upgradeShield: Math.floor(350 * 1.15), // 403
            upgradeShieldRegen: Math.floor(200 * 1.15), // 230
            upgradeShieldDurability: Math.floor(250 * 1.15), // 288
            upgradeBarrierSize: Math.floor(180 * 1.15), // 207
            upgradeBarrierWall: Math.floor(250 * 1.15), // 288
            upgradeBarrierThorns: Math.floor(200 * 1.15) // 230
        };
        
        // NEW: Weapon Levels
        let massCannonLevel = 1;
        let hasMaxChargeUpgrade = false;
        // NEW: Turret Upgrade Levels
        let turretFireRateLevel = 1;
        let turretRangeLevel = 1;
        // NEW: Turret Unlock State
        let isTurretUnlocked = false;

        // NEW: Core Shield Variables
        let coreShieldLevel = 0;
        let coreShieldCurrent = 0;
        let coreShieldMax = 0;
        let lastShieldHitTime = 0;
        let coreShieldRegenLevel = 0; // Quick regen upgrade level
        let coreShieldDurabilityLevel = 0; // Durability upgrade level

        // Speedy Enemy Variables
        let speedyEnemiesToSpawn = 0;
        let nextSpeedySpawnTime = 0;
        
        // Splitter Enemy Variables
        let splitterEnemiesToSpawn = 0;
        let nextSplitterSpawnTime = 0;

        // Structure Cooldown variable
        let lastDefenseBuildTime = 0;
        const DEFENSE_BUILD_COOLDOWN = 5000; 

        let lastDecayTime = Date.now();

        const moveState = { forward: false, backward: false, left: false, right: false, jump: false };
        const clock = new THREE.Clock();

        
        let aimLine, aimMarker; 
        let loadedBall; 
        let blockTexture; 
        let clouds = []; 
        let beamMeshCore; 
        let beamStrands = [];
        
        const smokeTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');

        let explosionSphereGeo;
        let explosionCoreMat, explosionWaveMat, explosionPartMat;

        const hudEl = document.getElementById('hud');
        const menuEl = document.getElementById('main-menu');
        const statusEl = document.getElementById('status');
        const fpsTrackerEl = document.getElementById('fps-tracker');
        const slowMoEl = document.getElementById('slowmo');
        const uiControlsEl = document.getElementById('ui-controls');
        const quickPlayWaitEl = document.getElementById('quickplay-wait');
        const quickPlayWaitText = document.getElementById('quickplay-wait-text');
        const quickPlayWaitList = document.getElementById('quickplay-wait-list');
        
        // FPS tracking variables
        let frameCount = 0;
        let lastFpsUpdate = Date.now();
        let currentFPS = 0;
        
        const sliderContainer = document.getElementById('grab-slider-container');
        const sliderInput = document.getElementById('grab-radius-slider');
        const sliderVal = document.getElementById('grab-radius-val');
        const sliderLabel = document.getElementById('slider-label');
        
        const formSpeedContainer = document.getElementById('form-speed-container');
        const formSpeedInput = document.getElementById('form-speed-slider');
        const formSpeedVal = document.getElementById('form-speed-val');

        const chargeBarWrap = document.getElementById('charge-bar-wrap');
        const chargeBarFill = document.getElementById('charge-bar-fill');
        const chargeBarText = document.querySelector('.charge-text');

        const eraserDistEl = document.getElementById('eraser-dist-container');
        const eraserDistVal = document.getElementById('eraser-dist-val');

        // Defense Elements
        const defenseHud = document.getElementById('defense-hud');
        const waveNumEl = document.getElementById('wave-num');
        const enemyCountEl = document.getElementById('enemy-count');
        const coreHealthFill = document.getElementById('core-health-fill');
        const coinCountEl = document.getElementById('coin-count');
        // NEW: Shield UI Refs
        const shieldBarWrap = document.getElementById('core-shield-bar-wrap');
        const shieldBarFill = document.getElementById('core-shield-fill');

        // Screen references
        const pauseMenuEl = document.getElementById('pause-menu');
        const gameOverEl = document.getElementById('game-over-screen');
        const gameOverStatsEl = document.getElementById('game-over-stats');

        // --- GEMINI API INTEGRATION ---
        

        // MULTIPLAYER Functions
        function initMultiplayer() {
            if (!isMultiplayerEnabled) return;
            
            // Connect to server - use Render URL for production
            const RENDER_SERVER_URL = 'https://defense-game.onrender.com';
            let serverUrl;
            
            // Check if we're opening from a shareable link (has room parameter)
            const urlParams = new URLSearchParams(window.location.search);
            const roomFromUrl = urlParams.get('room');
            
            if (window.location.protocol === 'file:') {
                // Opening file directly - use Render server
                serverUrl = RENDER_SERVER_URL;
            } else if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                // Local development - use Render server (or change to localhost:3000 for local testing)
                serverUrl = RENDER_SERVER_URL;
            } else {
                // Use Render server for all other cases
                serverUrl = RENDER_SERVER_URL;
            }
            
            // Suppress socket.io errors BEFORE creating connection
            // Store original console methods
            if (!window._originalConsoleError) {
                window._originalConsoleError = console.error;
                window._originalConsoleWarn = console.warn;
            }
            
            const suppressSocketErrors = () => {
                console.error = function(...args) {
                    const errorStr = String(args[0] || '');
                    // Suppress all socket.io/websocket related errors
                    if (errorStr.includes('WebSocket') || errorStr.includes('socket.io') || 
                        errorStr.includes('websocket') || errorStr.includes('Connection error') ||
                        errorStr.includes('transport') || errorStr.includes('EIO') ||
                        errorStr.includes('ws://') || errorStr.includes('wss://') ||
                        args.some(arg => String(arg).includes('websocket.js') || String(arg).includes('manager.js'))) {
                        return; // Suppress these errors completely
                    }
                    window._originalConsoleError.apply(console, args);
                };
                
                console.warn = function(...args) {
                    const warnStr = String(args[0] || '');
                    if (warnStr.includes('WebSocket') || warnStr.includes('socket.io') || 
                        warnStr.includes('websocket') || warnStr.includes('ws://') || 
                        warnStr.includes('wss://')) {
                        return; // Suppress these warnings
                    }
                    window._originalConsoleWarn.apply(console, args);
                };
            };
            
            // Suppress errors immediately
            suppressSocketErrors();
            
            socket = io(serverUrl, {
                transports: ['websocket', 'polling'],
                reconnection: false, // Disable auto-reconnect to prevent spam
                timeout: 3000,
                forceNew: false,
                autoConnect: true
            });
            
            // Also suppress errors on the socket object itself
            socket.io.on('error', () => {
                // Suppress socket.io internal errors
            });
            
            socket.on('connect', () => {
                console.log('Connected to multiplayer server');
                myPlayerId = socket.id;
                updateConnectionStatus('Connected', '#00ff00');
                // Restore console functions after successful connection
                if (window._originalConsoleError) {
                    console.error = window._originalConsoleError;
                }
                if (window._originalConsoleWarn) {
                    console.warn = window._originalConsoleWarn;
                }
            });
            
            socket.on('connect_error', (error) => {
                // Keep error suppression active
                suppressSocketErrors();
                updateConnectionStatus('Server not running. Please start the server with: npm start', '#ff6666');
            });
            
            socket.on('disconnect', (reason) => {
                if (reason === 'io server disconnect') {
                    // Server disconnected us
                    updateConnectionStatus('Disconnected from server', '#ff6666');
                } else {
                    // Client disconnected
                    updateConnectionStatus('Connection lost', '#ffaa00');
                }
            });
            
            socket.on('roomCreated', (data) => {
                currentRoomId = data.roomCode;
                isHost = data.isHost;
                clearOtherPlayers();
                showRoomInfo(data.roomCode);
                generateShareableLink(data.roomCode);
            });
            
            socket.on('roomJoined', (data) => {
                currentRoomId = data.roomCode;
                isHost = data.isHost;
                clearOtherPlayers();
                showRoomInfo(data.roomCode);
                generateShareableLink(data.roomCode);
            });
            
            socket.on('quickPlayJoined', (data) => {
                currentRoomId = data.roomCode;
                isHost = data.isHost;
                clearOtherPlayers();
                // For Quick Play, don't show room-info - just show waiting overlay
                document.getElementById('multiplayer-lobby').style.display = 'none';
                document.getElementById('room-info').style.display = 'none';
                if (quickPlayWaitEl) {
                    quickPlayWaitEl.style.display = 'flex';
                    if (quickPlayWaitText) {
                        quickPlayWaitText.innerText = 'Waiting for player...';
                    }
                }
            });
            
            socket.on('quickPlayWaiting', (data) => {
                if (quickPlayWaitEl) {
                    const playerCount = data?.playerCount || 1;
                    const players = data?.players || [];
                    
                    // Update player list
                    if (quickPlayWaitList) {
                        quickPlayWaitList.innerHTML = '';
                        players.forEach(p => {
                            const div = document.createElement('div');
                            div.style.padding = '8px 0';
                            div.style.color = '#fff';
                            div.innerText = p.name || `Player ${p.id?.slice(-4) || ''}`;
                            quickPlayWaitList.appendChild(div);
                        });
                    }
                    
                    if (playerCount >= 2) {
                        // Hide waiting overlay - game will start via quickPlayReady
                        quickPlayWaitEl.style.display = 'none';
                    } else {
                        quickPlayWaitEl.style.display = 'flex';
                        if (quickPlayWaitText) {
                            quickPlayWaitText.innerText = `Waiting for player... (${playerCount}/2)`;
                        }
                    }
                }
            });
            
            socket.on('quickPlayReady', () => {
                // Hide all lobby UI
                document.getElementById('multiplayer-lobby').style.display = 'none';
                document.getElementById('room-info').style.display = 'none';
                if (quickPlayWaitEl) quickPlayWaitEl.style.display = 'none';
                
                // Start the game for both players after reset
                if (!isDefenseMode || gameState !== 'playing') {
                    startDefenseMode();
                }
            });

            socket.on('quickPlayPlayers', (data) => {
                if (!quickPlayWaitList) return;
                quickPlayWaitList.innerHTML = '';
                const players = data?.players || [];
                players.forEach(p => {
                    const div = document.createElement('div');
                    div.style.display = 'flex';
                    div.style.justifyContent = 'space-between';
                    div.style.padding = '6px 0';
                    div.style.borderBottom = '1px solid rgba(255,255,255,0.08)';
                    const name = document.createElement('span');
                    name.innerText = (p.id === myPlayerId) ? 'You' : p.name || `Player ${p.id?.slice(-4) || ''}`;
                    name.style.color = (p.id === myPlayerId) ? '#ffcc80' : '#ffffff';
                    const tag = document.createElement('span');
                    tag.innerText = (p.id === myPlayerId) ? 'HOST' : 'READY';
                    tag.style.fontSize = '12px';
                    tag.style.color = '#ff9d00';
                    div.appendChild(name);
                    div.appendChild(tag);
                    quickPlayWaitList.appendChild(div);
                });

                if (players.length >= 2) {
                    // Hide all lobby UI
                    document.getElementById('multiplayer-lobby').style.display = 'none';
                    document.getElementById('room-info').style.display = 'none';
                    if (quickPlayWaitEl) quickPlayWaitEl.style.display = 'none';
                    if (!isDefenseMode || gameState !== 'playing') {
                        startDefenseMode();
                    }
                }
            });
            
            socket.on('joinRoomFailed', (data) => {
                if (data.reason === 'room_not_found') {
                    updateConnectionStatus('Room not found. Please check the code.', '#ff6666');
                } else if (data.reason === 'invalid_code') {
                    updateConnectionStatus('Invalid room code. Please enter a 6-character code.', '#ff6666');
                }
            });
            
            socket.on('gameState', (state) => {
                // Sync game state from server
                if (state) {
                    defenseWave = state.wave || defenseWave;
                    defenseCoreHealth = state.coreHealth || defenseCoreHealth;
                    defenseCoins = state.coins || defenseCoins;
                    enemiesToSpawn = state.enemiesToSpawn || enemiesToSpawn;
                    totalEnemiesForWave = state.totalEnemiesForWave || totalEnemiesForWave;
                    waveInProgress = state.waveInProgress || false;
                    nextSpawnTime = state.nextSpawnTime || nextSpawnTime;
                    speedyEnemiesToSpawn = state.speedyEnemiesToSpawn || 0;
                    splitterEnemiesToSpawn = state.splitterEnemiesToSpawn || 0;
                    
                    updateDefenseUI();
                }
            });
            
            socket.on('otherPlayers', (players) => {
                // Create visual indicators for other players
                console.log('Received other players list:', players);
                players.forEach(playerData => {
                    if (playerData.id !== myPlayerId) {
                        createOtherPlayer(playerData.id, playerData.position, playerData.rotation, playerData.cameraRotation);
                    }
                });
            });
            
            socket.on('playerJoined', (data) => {
                console.log('Player joined:', data.playerId);
                // Other player joined - create them if they don't exist
                if (data.playerId !== myPlayerId && !otherPlayers.has(data.playerId)) {
                    // Create player at a default position - they'll update when position is received
                    createOtherPlayer(data.playerId, { x: 0, y: 5, z: 0 }, null, null);
                }
            });
            
            socket.on('playerLeft', (data) => {
                console.log('Player left:', data.playerId);
                removeOtherPlayer(data.playerId);
            });
            
            socket.on('playerPosition', (data) => {
                updateOtherPlayer(data.playerId, data.position, data.rotation, data.cameraRotation);
            });
            
            socket.on('projectileShot', (data) => {
                // Another player shot - create visual projectile
                if (data.playerId !== myPlayerId) {
                    createNetworkProjectile(data);
                }
            });
            
            socket.on('enemyHit', (data) => {
                // Enemy was hit by another player
                const enemy = defenseEnemies[data.enemyIndex];
                if (enemy) {
                    damageEnemy(enemy, data.damage);
                }
            });
            
            socket.on('enemyKilled', (data) => {
                // Enemy was killed - sync coins and remove if still present
                const enemy = defenseEnemies[data.enemyIndex];
                if (enemy) {
                    // Remove without double coins (coins already included in payload)
                    const e = defenseEnemies[data.enemyIndex];
                    if (e && e.body) {
                        world.removeBody(e.body);
                    }
                    if (e && e.mesh) {
                        scene.remove(e.mesh);
                    }
                    defenseEnemies.splice(data.enemyIndex, 1);
                }
                defenseCoins = data.totalCoins || defenseCoins;
                updateDefenseUI();
            });
            
            socket.on('coreHit', (data) => {
                // Core was hit - sync health
                defenseCoreHealth = data.coreHealth || defenseCoreHealth;
                updateDefenseUI();
            });
            
            socket.on('waveComplete', (data) => {
                // Wave completed - sync state
                defenseWave = data.wave || defenseWave;
                defenseCoins = data.totalCoins || defenseCoins;
                enemiesToSpawn = data.enemiesToSpawn || enemiesToSpawn;
                speedyEnemiesToSpawn = data.speedyEnemiesToSpawn || 0;
                splitterEnemiesToSpawn = data.splitterEnemiesToSpawn || 0;
                updateDefenseUI();
            });
            
            socket.on('gameStateUpdate', (data) => {
                // Update local game state from server
                if (data.coins !== undefined) {
                    defenseCoins = data.coins || defenseCoins;
                }
                if (data.coreHealth !== undefined) {
                    defenseCoreHealth = data.coreHealth || defenseCoreHealth;
                }
                if (data.wave !== undefined) {
                    defenseWave = data.wave || defenseWave;
                }
                if (data.enemiesToSpawn !== undefined) {
                    enemiesToSpawn = data.enemiesToSpawn || enemiesToSpawn;
                }
                if (data.totalEnemiesForWave !== undefined) {
                    totalEnemiesForWave = data.totalEnemiesForWave || totalEnemiesForWave;
                }
                if (data.waveInProgress !== undefined) {
                    waveInProgress = data.waveInProgress;
                }
                // Handle pause state
                if (data.isPaused !== undefined && data.isPaused && gameState === 'playing') {
                    gameState = 'paused';
                    pauseMenuEl.style.display = 'flex';
                    document.exitPointerLock();
                } else if (data.isPaused !== undefined && !data.isPaused && gameState === 'paused') {
                    gameState = 'playing';
                    pauseMenuEl.style.display = 'none';
                    const promise = document.body.requestPointerLock();
                    if (promise) promise.catch(e=>{});
                }
                updateDefenseUI();
            });
            
            socket.on('gamePaused', (data) => {
                // Ignore remote pause; game keeps running
                console.log('Ignored remote gamePaused from:', data.playerId);
            });
            
            socket.on('gameResumed', (data) => {
                // Ignore remote resume
                console.log('Ignored remote gameResumed from:', data.playerId);
            });
            
            socket.on('gameOver', (data) => {
                console.log('Game over received:', data);
                endDefenseGame();
            });
            
            socket.on('enemySpawned', (data) => {
                // Host already spawned locally; others create mirrored enemy
                if (!isHost && data.id && !networkEnemies.has(data.id)) {
                    createNetworkEnemy(data);
                }
            });
            
            socket.on('shopPurchase', (data) => {
                // Shop purchase made by any player - sync for everyone
                defenseCoins = data.totalCoins || defenseCoins;
                
                // Apply the purchase effect locally
                if (data.type === 'repair') {
                    defenseCoreHealth = Math.min(100, defenseCoreHealth + 25);
                    shopCosts.repair = Math.floor(data.cost * 1.1);
                    statusEl.innerText = "CORE REPAIRED (+25%)";
                } else if (data.type === 'upgradeHeavy') {
                    massCannonLevel++;
                    shopCosts.upgradeHeavy = Math.floor(data.cost * 1.3);
                    statusEl.innerText = `MASS CANNON LVL ${massCannonLevel}`;
                } else if (data.type === 'upgradeMaxCharge') {
                    hasMaxChargeUpgrade = true;
                    statusEl.innerText = "MAX CHARGE UPGRADED (2x -> 3x DMG)";
                } else if (data.type === 'upgradeShield') {
                    coreShieldLevel++;
                    const addedCap = Math.floor(50 * Math.pow(1.5, coreShieldLevel - 1));
                    coreShieldMax += addedCap;
                    coreShieldCurrent = coreShieldMax;
                    shopCosts.upgradeShield = Math.floor(data.cost * 1.35);
                    if(coreShieldLevel === 1 && defenseCoreMesh && defenseCoreMesh.userData.shield) {
                        defenseCoreMesh.userData.shield.visible = true;
                    }
                    statusEl.innerText = `SHIELD UPGRADED (MAX ${coreShieldMax})`;
                } else if (data.type === 'upgradeShieldRegen') {
                    coreShieldRegenLevel++;
                    shopCosts.upgradeShieldRegen = Math.floor(data.cost * 1.3);
                    statusEl.innerText = `QUICK REGEN LVL ${coreShieldRegenLevel}`;
                } else if (data.type === 'upgradeShieldDurability') {
                    coreShieldDurabilityLevel++;
                    shopCosts.upgradeShieldDurability = Math.floor(data.cost * 1.3);
                    statusEl.innerText = `DURABILITY LVL ${coreShieldDurabilityLevel}`;
                }
                
                if (data.type !== 'barrier' && data.type !== 'turret') {
                    SoundManager.playCharge(0.5);
                }
                updateDefenseUI();
            });
            
            socket.on('shopPurchaseFailed', (data) => {
                // Purchase failed - show message
                statusEl.innerText = "INSUFFICIENT FUNDS";
            });
            
            socket.on('gameReset', () => {
                // Game was reset
                if (isDefenseMode) {
                    // Clear local enemies and restart defense fresh
                    clearEnemies();
                    startDefenseMode();
                }
            });
        }
        
        // Lobby Functions
        function showMultiplayerLobby() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('multiplayer-lobby').style.display = 'flex';
            showLobbyOptions();
            
            // Check if we're opening from a shareable link
            const urlParams = new URLSearchParams(window.location.search);
            const roomFromUrl = urlParams.get('room');
            
            if (roomFromUrl && roomFromUrl.length === 6) {
                // Auto-join room from shareable link
                updateConnectionStatus('Joining room from link...', '#ffaa00');
                isMultiplayerEnabled = true;
                initMultiplayer();
                
                // Wait for connection, then auto-join
                const checkAndJoin = setInterval(() => {
                    if (socket && socket.connected) {
                        clearInterval(checkAndJoin);
                        joinRoomByCodeFromLink(roomFromUrl);
                    } else if (socket && socket.disconnected) {
                        clearInterval(checkAndJoin);
                        updateConnectionStatus('Failed to connect. Please try again.', '#ff6666');
                    }
                }, 100);
                
                setTimeout(() => {
                    clearInterval(checkAndJoin);
                    if (!socket || !socket.connected) {
                        updateConnectionStatus('Connection timeout. Please try again.', '#ff6666');
                    }
                }, 5000);
            } else {
                // Normal lobby - initialize connection if not already connected
                if (!socket || !socket.connected) {
                    isMultiplayerEnabled = true;
                    updateConnectionStatus('Connecting to server...', '#ffaa00');
                    initMultiplayer();
                    
                    // Check connection after a delay
                    setTimeout(() => {
                        if (!socket || !socket.connected) {
                            updateConnectionStatus('Connecting to server...', '#ffaa00');
                        }
                    }, 2000);
                } else {
                    updateConnectionStatus('Connected', '#00ff00');
                }
            }
        }
        
        function joinRoomByCodeFromLink(roomCode) {
            if (!socket || !socket.connected) {
                updateConnectionStatus('Not connected. Please wait...', '#ffaa00');
                return;
            }
            
            updateConnectionStatus('Joining room...', '#ffaa00');
            socket.emit('joinRoomByCode', roomCode.toUpperCase(), (data) => {
                if (data && data.success) {
                    updateConnectionStatus('Joined room!', '#00ff00');
                    // Clean URL (remove room parameter)
                    const newUrl = window.location.href.split('?')[0];
                    window.history.replaceState({}, document.title, newUrl);
                } else {
                    if (data && data.reason === 'room_not_found') {
                        updateConnectionStatus('Room not found. The link may be expired.', '#ff6666');
                    } else {
                        updateConnectionStatus('Failed to join room', '#ff6666');
                    }
                }
            });
        }
        
        function closeMultiplayerLobby() {
            document.getElementById('multiplayer-lobby').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
            showLobbyOptions();
        }
        
        function returnToMainMenu() {
            // Disconnect from server if connected
            if (socket && socket.connected) {
                socket.disconnect();
                socket = null;
            }
            
            // Close lobby and return to main menu
            document.getElementById('multiplayer-lobby').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
            showLobbyOptions();
            
            // Reset multiplayer state
            isMultiplayerEnabled = false;
            currentRoomId = 'default';
            isHost = false;
        }
        
        function showLobbyOptions() {
            document.getElementById('lobby-options').style.display = 'flex';
            document.getElementById('join-room-form').style.display = 'none';
            document.getElementById('room-info').style.display = 'none';
            const codeInput = document.getElementById('room-code-input');
            if (codeInput) codeInput.value = '';
        }
        
        function showJoinRoom() {
            document.getElementById('lobby-options').style.display = 'none';
            document.getElementById('join-room-form').style.display = 'flex';
            document.getElementById('room-info').style.display = 'none';
            const codeInput = document.getElementById('room-code-input');
            if (codeInput) {
                codeInput.focus();
                codeInput.value = '';
            }
        }
        
        function showRoomInfo(roomCode) {
            document.getElementById('lobby-options').style.display = 'none';
            document.getElementById('join-room-form').style.display = 'none';
            document.getElementById('room-info').style.display = 'block';
            const codeDisplay = document.getElementById('room-code-display');
            if (codeDisplay) codeDisplay.innerText = roomCode;
        }
        
        function generateShareableLink(roomCode) {
            // Generate shareable link with room code
            const currentUrl = window.location.href.split('?')[0]; // Get URL without query params
            const shareableLink = `${currentUrl}?room=${roomCode}`;
            
            const linkInput = document.getElementById('shareable-link-input');
            if (linkInput) {
                linkInput.value = shareableLink;
            }
        }
        
        function copyShareableLink() {
            const linkInput = document.getElementById('shareable-link-input');
            if (linkInput) {
                linkInput.select();
                linkInput.setSelectionRange(0, 99999); // For mobile devices
                document.execCommand('copy');
                
                // Show feedback
                const copyBtn = event.target.closest('button');
                if (copyBtn) {
                    const originalText = copyBtn.querySelector('.btn-text').innerText;
                    copyBtn.querySelector('.btn-text').innerText = 'Copied!';
                    setTimeout(() => {
                        copyBtn.querySelector('.btn-text').innerText = originalText;
                    }, 2000);
                }
                
                updateConnectionStatus('Link copied to clipboard!', '#00ff00');
            }
        }
        
        function updateConnectionStatus(message, color) {
            const statusEl = document.getElementById('connection-status');
            if (statusEl) {
                statusEl.style.display = 'block';
                statusEl.innerText = message;
                statusEl.style.color = color;
            }
        }
        
        function quickPlay() {
            if (!socket || !socket.connected) {
                updateConnectionStatus('Not connected to server. Please wait...', '#ffaa00');
                if (!socket) {
                    isMultiplayerEnabled = true;
                    initMultiplayer();
                } else {
                    socket.connect();
                }
                setTimeout(() => {
                    if (socket && socket.connected) {
                        quickPlay();
                    } else {
                        updateConnectionStatus('Server not running. Please start the server with: npm start', '#ff6666');
                    }
                }, 2000);
                return;
            }
            
            updateConnectionStatus('Finding game...', '#ffaa00');
            // Hide lobby and show waiting overlay
            document.getElementById('multiplayer-lobby').style.display = 'none';
            document.getElementById('room-info').style.display = 'none';
            if (quickPlayWaitEl) {
                quickPlayWaitEl.style.display = 'flex';
                if (quickPlayWaitText) quickPlayWaitText.innerText = 'Waiting for player...';
            }
            socket.emit('quickPlay', (data) => {
                if (data) {
                    updateConnectionStatus('Joined game!', '#00ff00');
                } else {
                    updateConnectionStatus('Failed to join game', '#ff6666');
                    if (quickPlayWaitEl) quickPlayWaitEl.style.display = 'none';
                    // Show lobby again on error
                    document.getElementById('multiplayer-lobby').style.display = 'flex';
                }
            });
        }
        
        function createRoom() {
            if (!socket || !socket.connected) {
                updateConnectionStatus('Not connected to server. Please wait...', '#ffaa00');
                if (!socket) {
                    isMultiplayerEnabled = true;
                    initMultiplayer();
                } else {
                    socket.connect();
                }
                setTimeout(() => {
                    if (socket && socket.connected) {
                        createRoom();
                    } else {
                        updateConnectionStatus('Server not running. Please start the server with: npm start', '#ff6666');
                    }
                }, 2000);
                return;
            }
            
            updateConnectionStatus('Creating room...', '#ffaa00');
            socket.emit('createRoom', (data) => {
                if (data) {
                    updateConnectionStatus('Room created!', '#00ff00');
                } else {
                    updateConnectionStatus('Failed to create room', '#ff6666');
                }
            });
        }
        
        function joinRoomByCode() {
            const codeInput = document.getElementById('room-code-input');
            if (!codeInput) return;
            
            const roomCode = codeInput.value.toUpperCase().trim();
            
            if (roomCode.length !== 6) {
                updateConnectionStatus('Please enter a 6-character room code', '#ff6666');
                return;
            }
            
            if (!socket || !socket.connected) {
                updateConnectionStatus('Not connected to server. Please wait...', '#ffaa00');
                if (!socket) {
                    isMultiplayerEnabled = true;
                    initMultiplayer();
                } else {
                    socket.connect();
                }
                setTimeout(() => {
                    if (socket && socket.connected) {
                        joinRoomByCode();
                    } else {
                        updateConnectionStatus('Server not running. Please start the server with: npm start', '#ff6666');
                    }
                }, 2000);
                return;
            }
            
            updateConnectionStatus('Joining room...', '#ffaa00');
            socket.emit('joinRoomByCode', roomCode, (data) => {
                if (data && data.success) {
                    updateConnectionStatus('Joined room!', '#00ff00');
                } else {
                    if (data && data.reason === 'room_not_found') {
                        updateConnectionStatus('Room not found. Please check the code.', '#ff6666');
                    } else {
                        updateConnectionStatus('Failed to join room', '#ff6666');
                    }
                }
            });
        }
        
        function startGameFromLobby() {
            if (!socket || !socket.connected) {
                updateConnectionStatus('Not connected to server', '#ff6666');
                return;
            }
            
            // Close lobby and start game
            document.getElementById('multiplayer-lobby').style.display = 'none';
            startDefenseModeInternal();
        }
        
        function createOtherPlayer(playerId, position, rotation, cameraRotation) {
            if (otherPlayers.has(playerId)) return;
            
            // Create a more visible player indicator
            const group = new THREE.Group();
            
            // Main body - larger, more visible sphere (increased size)
            const bodyGeometry = new THREE.SphereGeometry(2, 16, 16);
            const bodyMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                transparent: true, 
                opacity: 0.9 
            });
            const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            group.add(bodyMesh);
            
            // Glow effect - outer ring (increased size)
            const glowGeometry = new THREE.SphereGeometry(2.5, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                transparent: true, 
                opacity: 0.3,
                side: THREE.BackSide
            });
            const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
            group.add(glowMesh);
            
            // Player indicator arrow pointing up (shows which way they're facing)
            const arrowGeometry = new THREE.ConeGeometry(0.3, 1.5, 8);
            const arrowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                transparent: true, 
                opacity: 0.8 
            });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow.position.y = 1.5;
            arrow.rotation.x = Math.PI;
            group.add(arrow);
            
            // Name label - improved visibility
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            context.fillStyle = 'rgba(0, 0, 0, 0.8)';
            context.fillRect(0, 0, 512, 128);
            context.fillStyle = '#00ff00';
            context.font = 'bold 32px Arial';
            context.textAlign = 'center';
            context.strokeStyle = '#000000';
            context.lineWidth = 4;
            context.strokeText(`Player ${playerId.slice(-4)}`, 256, 70);
            context.fillText(`Player ${playerId.slice(-4)}`, 256, 70);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(6, 1.5, 1);
            sprite.position.y = 4;
            group.add(sprite);
            
            if (position) {
                group.position.set(position.x, position.y || 5, position.z);
            } else {
                group.position.set(0, 5, 0);
            }
            
            scene.add(group);
            otherPlayers.set(playerId, {
                mesh: group,
                body: bodyMesh,
                glow: glowMesh,
                arrow: arrow,
                sprite: sprite,
                position: position || { x: 0, y: 5, z: 0 },
                rotation: rotation || { x: 0, y: 0, z: 0 },
                cameraRotation: cameraRotation || { x: 0, y: 0 }
            });
        }
        
        function updateOtherPlayer(playerId, position, rotation, cameraRotation) {
            const player = otherPlayers.get(playerId);
            if (player && player.mesh) {
                if (position) {
                    // Update position with smooth interpolation
                    const yPos = position.y !== undefined ? position.y : 5;
                    const targetPos = new THREE.Vector3(position.x, yPos, position.z);
                    player.mesh.position.lerp(targetPos, 0.3); // Smooth interpolation
                    player.position = { ...position, y: yPos };
                }
                if (rotation) {
                    // Update rotation - arrow points in the direction player is facing
                    player.mesh.rotation.y = rotation.y;
                    if (player.arrow) {
                        player.arrow.rotation.y = rotation.y;
                    }
                    player.rotation = rotation;
                }
                if (cameraRotation) {
                    player.cameraRotation = cameraRotation;
                }
                // Make sprite always face camera
                if (player.sprite && camera) {
                    player.sprite.lookAt(camera.position);
                }
                // Animate glow
                if (player.glow) {
                    const scale = 1.0 + Math.sin(Date.now() * 0.005) * 0.1;
                    player.glow.scale.setScalar(scale);
                }
            } else if (position && !otherPlayers.has(playerId)) {
                // Player doesn't exist yet - create them
                createOtherPlayer(playerId, position, rotation, cameraRotation);
            }
        }
        
        function removeOtherPlayer(playerId) {
            const player = otherPlayers.get(playerId);
            if (player && player.mesh) {
                scene.remove(player.mesh);
                // Dispose all materials and geometries
                if (player.sprite) {
                    player.sprite.material.dispose();
                    player.sprite.map.dispose();
                }
                if (player.body) {
                    player.body.geometry.dispose();
                    player.body.material.dispose();
                }
                if (player.glow) {
                    player.glow.geometry.dispose();
                    player.glow.material.dispose();
                }
                if (player.arrow) {
                    player.arrow.geometry.dispose();
                    player.arrow.material.dispose();
                }
                // Dispose any remaining children
                player.mesh.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                otherPlayers.delete(playerId);
            }
        }

        function clearOtherPlayers() {
            otherPlayers.forEach((_, id) => removeOtherPlayer(id));
            otherPlayers.clear();
        }
        
        function createNetworkProjectile(data) {
            // Create visual projectile for other players' shots
            const geometry = new THREE.SphereGeometry(data.radius || 1, 16, 16);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.6 
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(data.position.x, data.position.y, data.position.z);
            scene.add(mesh);
            
            // Animate projectile
            const velocity = new THREE.Vector3(data.velocity.x, data.velocity.y, data.velocity.z);
            const startTime = Date.now();
            const duration = 4000; // 4 seconds
            
            const animate = () => {
                const elapsed = Date.now() - startTime;
                if (elapsed < duration) {
                    const t = elapsed / 1000;
                    mesh.position.add(velocity.clone().multiplyScalar(0.016));
                    requestAnimationFrame(animate);
                } else {
                    scene.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                }
            };
            animate();
        }
        
        function createNetworkEnemy(data) {
            // Create a mirrored enemy from host data
            if (!data) return;
            networkEnemies.set(data.id, data);
            
            const radius = data.radius || 2.625;
            const mass = data.mass || 60;
            const hp = data.hp || 60;
            const coinVal = data.coinValue || 9;
            const isBoss = !!data.isBoss;
            const isSpeedy = !!data.isSpeedy;
            const isSplitter = !!data.isSplitter;
            
            // Physics body
            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({ mass });
            body.addShape(shape);
            body.position.set(data.position?.x || 0, data.position?.y || radius, data.position?.z || 0);
            body.velocity.set(data.velocity?.x || 0, data.velocity?.y || 0, data.velocity?.z || 0);
            body.linearDamping = 0.1;
            body.angularDamping = 0.1;
            
            const enemyObj = {
                id: data.id,
                body,
                hp,
                maxHp: data.maxHp || hp,
                isBoss,
                isSpeedy,
                isSplitter,
                coinValue: coinVal,
                lastHitTime: 0
            };
            
            // Simple visual (reuse existing builder)
            const color = isBoss ? 0xaa0000 : (isSpeedy ? 0x00aaff : 0xff3300);
            const geo = new THREE.SphereGeometry(radius, 16, 16);
            const mat = new THREE.MeshStandardMaterial({ color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            enemyObj.mesh = mesh;
            mesh.userData.enemyRef = enemyObj;
            scene.add(mesh);
            
            body.userData = { enemyRef: enemyObj };
            enemyObj.body = body;
            enemyObj.mesh = mesh;
            
            world.addBody(body);
            defenseEnemies.push(enemyObj);
        }
        
        function sendPositionUpdate() {
            if (!socket || !socket.connected || !isDefenseMode) return;
            
            const now = Date.now();
            if (now - lastPositionUpdate < POSITION_UPDATE_INTERVAL) return;
            lastPositionUpdate = now;
            
            if (playerBody && camera) {
                const position = {
                    x: playerBody.position.x,
                    y: playerBody.position.y,
                    z: playerBody.position.z
                };
                
                const rotation = {
                    x: playerBody.quaternion.x,
                    y: playerBody.quaternion.y,
                    z: playerBody.quaternion.z
                };
                
                const cameraRotation = {
                    x: camera.rotation.x,
                    y: camera.rotation.y
                };
                
                socket.emit('updatePosition', {
                    position: position,
                    rotation: rotation,
                    cameraRotation: cameraRotation
                });
            }
        }

        function init() {
            blockTexture = createBlockTexture();
            
            explosionSphereGeo = new THREE.SphereGeometry(1, 16, 16);
            explosionCoreMat = new THREE.MeshBasicMaterial({ color: 0xffee00, transparent: true, opacity: 0.8 });
            explosionWaveMat = new THREE.MeshBasicMaterial({ 
                color: 0xff4400, transparent: true, opacity: 0.4, side: THREE.BackSide, depthWrite: false 
            });
            explosionPartMat = new THREE.PointsMaterial({ color: 0xffaa00, size: 0.8, transparent: true, opacity: 0.8 });

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 400);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ'; 
            camera.position.set(0, 50, 60); 

            
            renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                powerPreference: "high-performance",
                stencil: false,
                depth: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.getElementById('canvas-container').appendChild(renderer.domElement);


            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
            scene.add(ambientLight);
            
            const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 0.6 );
            hemiLight.position.set( 0, 200, 0 );
            scene.add( hemiLight );

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); 
            dirLight.position.set(100, 450, 50); // Updated to match sun position
            dirLight.castShadow = true;
            // PERFORMANCE: Reduced shadow map resolution for better performance (2048 -> 1024)
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.bias = -0.0001;
            dirLight.shadow.camera.left = -150;
            dirLight.shadow.camera.right = 150;
            dirLight.shadow.camera.top = 150;
            dirLight.shadow.camera.bottom = -150;
            scene.add(dirLight);

            world = new CANNON.World();
            world.gravity.set(0, -80, 0); // Increased from -60 to -80 for much faster falling 
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.broadphase.useBoundingBoxes = true;
            // Ensure proper collision detection between all bodies
            world.broadphase.axisIndex = 0; // Use X-axis for sorting (can help with performance)
            world.solver.iterations = 25; // Increased to 25 for much better block-to-block collision resolution
            world.allowSleep = true; 
            world.quatNormalizeFast = true;
            
            world.defaultContactMaterial.contactEquationStiffness = 1e8; // Increased for better collision response
            world.defaultContactMaterial.contactEquationRelaxation = 4; // Increased for better stability

            
            const defaultMaterial = new CANNON.Material('default');
            const playerMaterial = new CANNON.Material('player');
            
            const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
                friction: 0.6, // Higher friction for better block-to-block contact and collision
                restitution: 0.1, // Low restitution to prevent bouncing but allow some response
                contactEquationStiffness: 1e10, // Very high stiffness for solid, non-penetrating collisions
                contactEquationRelaxation: 2 // Lower relaxation for better collision response
            });
            const playerContactMaterial = new CANNON.ContactMaterial(playerMaterial, defaultMaterial, {
                friction: 0.0, restitution: 0.0
            });
            
            world.addContactMaterial(defaultContactMaterial);
            world.addContactMaterial(playerContactMaterial);

            
            const jointShape = new CANNON.Sphere(0.1);
            jointBody = new CANNON.Body({ mass: 0 }); 
            jointBody.addShape(jointShape);
            jointBody.collisionFilterGroup = 0;
            jointBody.collisionFilterMask = 0;
            world.addBody(jointBody);

            createSky(); 
            createGround(defaultMaterial); 
            createPlayer(playerMaterial);
            setupAimingVisuals();
            createLoadedBall();
            createBeamVisual();
            createShockwaveChargeVisual();
            createEraserVisual();

            
            raycaster = new THREE.Raycaster();
            centerScreen = new THREE.Vector2(0, 0); 

            
            sliderInput.addEventListener('input', (e) => {
                if(isEraserMode) {
                    eraserRadius = parseFloat(e.target.value);
                    sliderVal.innerText = eraserRadius;
                } else {
                    CONFIG.grabRadius = parseFloat(e.target.value);
                    sliderVal.innerText = CONFIG.grabRadius;
                }
            });

            formSpeedInput.addEventListener('input', (e) => {
                currentFormationSpeed = parseFloat(e.target.value);
                formSpeedVal.innerText = currentFormationSpeed.toFixed(2);
            }); 

            document.addEventListener('wheel', (event) => {
                if (isHoldingT && currentAmmo === 'raygun') {
                    const delta = Math.sign(event.deltaY) * 0.01; 
                    currentFormationSpeed = Math.max(0.01, Math.min(0.4, currentFormationSpeed + delta));
                    
                    formSpeedInput.value = currentFormationSpeed;
                    formSpeedVal.innerText = currentFormationSpeed.toFixed(2);
                } 
                else if (isEraserMode) {
                    const delta = Math.sign(event.deltaY) * 5; 
                    eraserRadius = Math.max(1, Math.min(75, eraserRadius + delta));
                    sliderInput.value = eraserRadius;
                    sliderVal.innerText = eraserRadius;
                }
                else if (currentAmmo === 'raygun') {
                    // NEW: Prevent scroll wheel from cheating grab size in Defense Mode
                    if (isDefenseMode) return;

                    const delta = Math.sign(event.deltaY) * 10; 
                    CONFIG.grabRadius = Math.max(10, Math.min(250, CONFIG.grabRadius + delta));
                    sliderInput.value = CONFIG.grabRadius;
                    sliderVal.innerText = CONFIG.grabRadius;
                }
            }, { passive: true });

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('keydown', (e) => onKey(e, true));
            document.addEventListener('keyup', (e) => onKey(e, false));
            window.addEventListener('contextmenu', e => e.preventDefault());
            
            // Initialize multiplayer
            initMultiplayer();
        }

        function createShockwaveChargeVisual() {
            shockwaveChargeMesh = new THREE.Group();
            
            const coreGeo = new THREE.SphereGeometry(CONFIG.ballRadius * 0.5, 32, 32);
            const coreMat = new THREE.MeshBasicMaterial({ 
                color: 0xaa00ff, 
                transparent: true, 
                opacity: 0.8,
                blending: THREE.AdditiveBlending 
            });
            const core = new THREE.Mesh(coreGeo, coreMat);
            shockwaveChargeMesh.add(core);

            const innerCoreGeo = new THREE.SphereGeometry(CONFIG.ballRadius * 0.2, 16, 16);
            const innerCoreMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 1.0
            });
            const innerCore = new THREE.Mesh(innerCoreGeo, innerCoreMat);
            shockwaveChargeMesh.add(innerCore);

            const chargeLight = new THREE.PointLight(0xff00ff, 5, 2, 2); 
            shockwaveChargeMesh.add(chargeLight);
            
            const ringGeo = new THREE.TorusGeometry(CONFIG.ballRadius * 0.9, 0.1, 12, 50);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, blending: THREE.AdditiveBlending });
            
            const ringA = new THREE.Mesh(ringGeo, ringMat);
            const ringB = new THREE.Mesh(ringGeo, ringMat);
            ringB.rotation.x = Math.PI / 2; 

            shockwaveChargeMesh.add(ringA);
            shockwaveChargeMesh.add(ringB);
            
            const pCount = 50;
            const pGeo = new THREE.BufferGeometry();
            const pPos = new Float32Array(pCount * 3);
            for(let i=0; i<pCount; i++) {
                pPos[i*3] = (Math.random()-0.5)*10;
                pPos[i*3+1] = (Math.random()-0.5)*10;
                pPos[i*3+2] = (Math.random()-0.5)*10;
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            const pMat = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.1, transparent: true, opacity: 0.6 });
            const particles = new THREE.Points(pGeo, pMat);
            shockwaveChargeMesh.add(particles);
            
            const outerGeo = new THREE.IcosahedronGeometry(CONFIG.ballRadius * 1.2, 0);
            const outerMat = new THREE.MeshBasicMaterial({
                color: 0x0088ff,
                transparent: true,
                opacity: 0.3,
                wireframe: true
            });
            const outer = new THREE.Mesh(outerGeo, outerMat);
            shockwaveChargeMesh.add(outer);


            // UPDATED: Z Position -5.5
            shockwaveChargeMesh.position.set(2.2, -1.4, -5.5);
            shockwaveChargeMesh.visible = false;
            
            shockwaveChargeMesh.userData = { 
                core: core, 
                innerCore: innerCore, 
                chargeLight: chargeLight,
                ringA: ringA, 
                ringB: ringB, 
                outer: outer, 
                particles: particles 
            };
            
            camera.add(shockwaveChargeMesh);
        }

        function createEraserVisual() {
            const eraserGeo = new THREE.SphereGeometry(1, 32, 32); 
            const eraserMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0.3, 
                depthWrite: false
            });
            eraserMarker = new THREE.Mesh(eraserGeo, eraserMat);
            eraserMarker.visible = false;
            scene.add(eraserMarker);
        }

        function updateEraser() {
            if (isEraserMode) {
                raycaster.setFromCamera(centerScreen, camera);
                const hits = raycaster.intersectObjects(collidables);
                
                if (hits.length > 0) {
                    const hit = hits[0];
                    if (hit.distance <= eraserMaxDistance) {
                        eraserMarker.visible = true;
                        eraserMarker.position.copy(hit.point);
                        eraserMarker.scale.set(eraserRadius, eraserRadius, eraserRadius);
                        
                        if (isErasing) {
                             // Eraser functionality removed - no structures to erase
                        }
                    } else {
                        eraserMarker.visible = false;
                    }
                } else {
                    eraserMarker.visible = false;
                }
            } else {
                eraserMarker.visible = false;
            }
        }

        

        function startDefenseMode() {
            // Disable multiplayer for single player mode
            isMultiplayerEnabled = false;
            if (socket && socket.connected) {
                socket.disconnect();
                socket = null;
            }
            startDefenseModeInternal();
        }
        
        function startMultiplayerMode() {
            // Show lobby instead of starting directly
            showMultiplayerLobby();
        }
        
        function startDefenseModeInternal() {
            SoundManager.init();
            
            gameState = 'playing';
            isDefenseMode = true;
            
            lastDefenseBuildTime = 0;

            menuEl.style.display = 'none';
            pauseMenuEl.style.display = 'none';
            gameOverEl.style.display = 'none';
            
            // Ensure shop is hidden initially
            document.getElementById('defense-shop').style.display = 'none';
            isShopOpen = false; // FIXED: Reset shop state when starting defense mode
            
            hudEl.style.display = 'block';
            defenseHud.style.display = 'flex'; 

            const promise = document.body.requestPointerLock();
            if (promise) promise.catch(e => {});

            // Initialize Defense
            clearEnemies();
            clearAllStructures();
            spawnDefenseCore();
            if (quickPlayWaitEl) quickPlayWaitEl.style.display = 'none';
            
            // MULTIPLAYER: Only host initializes game state; clients wait for sync
            if (!isMultiplayerEnabled || isHost) {
                defenseWave = 1;
                defenseCoreHealth = 100;
                defenseEnemies = [];
                defenseTurrets = []; // Clear turrets
                enemiesToSpawn = 10; // FIXED: Wave 1 always starts with 10 enemies
                // NEW: Set initial total
                totalEnemiesForWave = enemiesToSpawn;
                waveInProgress = false;
                
                // MULTIPLAYER: Reset spawn counter at game start
                if (isMultiplayerEnabled && isDefenseMode) {
                    enemySpawnCounter = 0;
                }
                
                // Reset alert flag
                speedyAlertShown = false; 
                
                defenseCoins = 150; // UPDATED: STARTING COINS 150
                
                // MULTIPLAYER: Host sends initial game state immediately
                if (isMultiplayerEnabled && socket && socket.connected && isHost) {
                    setTimeout(() => {
                        socket.emit('gameStateSync', {
                            wave: defenseWave,
                            coreHealth: defenseCoreHealth,
                            coins: defenseCoins,
                            enemiesToSpawn: enemiesToSpawn,
                            totalEnemiesForWave: totalEnemiesForWave,
                            waveInProgress: waveInProgress
                        });
                    }, 100);
                }
            } else {
                // Non-host: Wait for host's game state (will be received via gameStateUpdate)
                // Don't initialize local state - wait for sync
            }
            
            // MULTIPLAYER: Request other players list when game starts
            if (isMultiplayerEnabled && socket && socket.connected && currentRoomId) {
                // Request list of other players in the room (with a small delay to ensure everything is initialized)
                setTimeout(() => {
                    if (socket && socket.connected && currentRoomId) {
                        socket.emit('requestOtherPlayers', currentRoomId);
                        console.log('Requested other players for room:', currentRoomId);
                    }
                }, 100);
                
                // Also ensure we're visible to others by sending our position once playerBody exists
                setTimeout(() => {
                    if (socket && socket.connected && playerBody) {
                        sendPositionUpdate();
                    }
                }, 1000);
            }

            // NEW: Reset Shop Costs to Base Values
            // FIXED: All prices increased by 15%
            shopCosts = {
                repair: Math.floor(100 * 1.15), // 115
                barrier: Math.floor(150 * 1.15), // 173
                grab: Math.floor(250 * 1.15), // 288
                unlockTurret: Math.floor(500 * 1.15), // 575
                turret: Math.floor(300 * 1.15), // 345
                nuke: Math.floor(500 * 1.15), // 575
                explosive: Math.floor(250 * 1.15), // 288
                raygun: Math.floor(350 * 1.15), // 403
                shockwave: Math.floor(450 * 1.15), // 518
                blackhole: Math.floor(1000 * 1.15), // 1150
                upgradeHeavy: Math.floor(200 * 1.15), // 230
                upgradeMaxCharge: Math.floor(400 * 1.15), // 460
                upgradeTurretFire: Math.floor(250 * 1.15), // 288
                upgradeTurretRange: Math.floor(250 * 1.15), // 288
                upgradeShield: Math.floor(350 * 1.15), // 403
                upgradeShieldRegen: Math.floor(200 * 1.15), // 230
                upgradeShieldDurability: Math.floor(250 * 1.15), // 288
                upgradeBarrierSize: Math.floor(180 * 1.15), // 207
                upgradeBarrierWall: Math.floor(250 * 1.15), // 288
                upgradeBarrierThorns: Math.floor(200 * 1.15) // 230
            };
            
            // NEW: Reset Level
            massCannonLevel = 1;
            hasMaxChargeUpgrade = false;
            turretFireRateLevel = 1;
            turretRangeLevel = 1;
            isTurretUnlocked = false; 
            
            // Reset cooldowns
            lastExplosionTime = 0;
            lastShockwaveTime = 0;
            
            // NEW: Reset Shield
            coreShieldLevel = 0;
            coreShieldMax = 0;
            coreShieldCurrent = 0;
            coreShieldRegenLevel = 0;
            coreShieldDurabilityLevel = 0;
            shieldBarWrap.style.display = 'none';
            
            // NEW: Reset Aurora Shield Upgrades
            barrierSizeLevel = 0;
            barrierWallCount = 0;
            barrierThornsLevel = 0;

            // NEW: Restrict Grab Size & Show Slider as Read-Only
            CONFIG.grabRadius = 10;
            const sContainer = document.getElementById('grab-slider-container');
            sContainer.style.display = 'flex'; // Make sure it's not hidden
            sliderInput.value = CONFIG.grabRadius;
            sliderVal.innerText = CONFIG.grabRadius;
            sliderInput.disabled = true; // Disable input in Defense Mode (upgrades only)
            
            // Start with only heavy weapon
            unlockedWeapons = ['heavy'];
            setAmmo('heavy');
            updateAmmoMenuVisuals();

            speedyEnemiesToSpawn = 0;
            splitterEnemiesToSpawn = 0;
            
            waveInProgress = true;
            
            nextSpawnTime = Date.now(); 
            
            updateDefenseUI();
            
            statusEl.innerText = "DEFEND THE CORE";
            setTimeout(() => statusEl.innerText = "WAVE 1 START", 2000);
            
            // Move player
            playerBody.position.set(0, 5, 30);
            playerBody.velocity.set(0,0,0);
        }
        window.startDefenseMode = startDefenseMode;
        window.startMultiplayerMode = startMultiplayerMode;

        function togglePause() {
            // Local pause: only disable player controls/UI. Game keeps running.
            if (!isPlayerPaused) {
                isPlayerPaused = true;
                pauseMenuEl.style.display = 'flex';
                document.exitPointerLock();
            } else {
                resumeGame();
            }
        }

        function resumeGame() {
            isPlayerPaused = false;
            pauseMenuEl.style.display = 'none';
            // Request pointer lock - if it fails, try again after a short delay
            const requestLock = () => {
                const promise = document.body.requestPointerLock();
                if (promise) {
                    promise.catch(err => {
                        // If it fails, try again after 100ms
                        setTimeout(() => {
                            document.body.requestPointerLock().catch(e => {});
                        }, 100);
                    });
                }
            };
            requestLock();
        }
        window.resumeGame = resumeGame;

        function quitToMainMenu() {
            gameState = 'menu';
            pauseMenuEl.style.display = 'none';
            gameOverEl.style.display = 'none';
            hudEl.style.display = 'none';
            menuEl.style.display = 'flex';
            document.getElementById('enemies-info-modal').style.display = 'none';
            document.exitPointerLock();
            isDefenseMode = false;
        }
        window.quitToMainMenu = quitToMainMenu;
        window.returnToMainMenu = returnToMainMenu;

        function showEnemiesInfo() {
            document.getElementById('enemies-info-modal').style.display = 'flex';
        }
        window.showEnemiesInfo = showEnemiesInfo;

        function closeEnemiesInfo() {
            document.getElementById('enemies-info-modal').style.display = 'none';
        }
        window.closeEnemiesInfo = closeEnemiesInfo;
        window.showMultiplayerLobby = showMultiplayerLobby;
        window.closeMultiplayerLobby = closeMultiplayerLobby;
        window.quickPlay = quickPlay;
        window.createRoom = createRoom;
        window.joinRoomByCode = joinRoomByCode;
        window.showJoinRoom = showJoinRoom;
        window.showLobbyOptions = showLobbyOptions;
        window.startGameFromLobby = startGameFromLobby;
        window.copyShareableLink = copyShareableLink;

        function updateDefenseUI() {
            waveNumEl.innerText = defenseWave;
            enemyCountEl.innerText = defenseEnemies.length + enemiesToSpawn + speedyEnemiesToSpawn + splitterEnemiesToSpawn;
            coreHealthFill.style.width = Math.max(0, defenseCoreHealth) + '%';
            
            // NEW: Update Shield UI
            if (coreShieldMax > 0) {
                shieldBarWrap.style.display = 'block';
                const shieldPct = (coreShieldCurrent / coreShieldMax) * 100;
                shieldBarFill.style.width = Math.max(0, shieldPct) + '%';
            } else {
                shieldBarWrap.style.display = 'none';
            }

            coinCountEl.innerText = defenseCoins;

            // UPDATED: Helper to render cleaner HTML with new structure
            const updateShopBtn = (id, type, label, icon, isOneTime = false) => {
                const btn = document.getElementById(id);
                if (!btn) return;
                
                // If it's a weapon and already unlocked, show "OWNED"
                if (isOneTime && unlockedWeapons.includes(type)) {
                    btn.innerHTML = `
                        <div class="btn-label">
                            <span class="shop-icon">${icon}</span> 
                            <div class="btn-text-group">
                                <div class="btn-main">${label}</div>
                                <div class="btn-sub" style="color:#4caf50">OWNED</div>
                            </div>
                        </div>
                    `;
                    btn.classList.remove('affordable');
                    btn.style.opacity = '0.5';
                    btn.disabled = true;
                    btn.style.cursor = 'default';
                    // Remove price for owned items to clean up UI
                    return;
                }

                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';

                const cost = shopCosts[type];
                
                // Reconstruct innerHTML with new CARD structure
                btn.innerHTML = `
                    <div class="btn-label">
                        <span class="shop-icon">${icon}</span> 
                        <div class="btn-text-group">
                            <div class="btn-main">${label}</div>
                        </div>
                    </div>
                    <div class="btn-price">$${cost}</div>
                `;
                
                if (defenseCoins >= cost) {
                    btn.classList.add('affordable');
                } else {
                    btn.classList.remove('affordable');
                }
            };

            updateShopBtn('btn-repair', 'repair', 'REPAIR CORE', 'üîß');
            // UPDATED: Renamed to match the Mk. IV Design
            // NEW: Aurora Shield Button
            const btnBarrier = document.getElementById('btn-barrier');
            if (btnBarrier) {
                const barrierCost = shopCosts.barrier;
                btnBarrier.innerHTML = `
                    <div class="btn-label">
                        <span class="shop-icon">üõ°Ô∏è</span> 
                        <div class="btn-text-group">
                            <div class="btn-main">AURORA SHIELD</div>
                            <div class="btn-sub">DEPLOY</div>
                        </div>
                    </div>
                    <div class="btn-price">$${barrierCost}</div>
                `;
                
                if (defenseCoins >= barrierCost) {
                    btnBarrier.classList.add('affordable');
                    btnBarrier.disabled = false;
                    btnBarrier.style.opacity = '1';
                    btnBarrier.style.cursor = 'pointer';
                } else {
                    btnBarrier.classList.remove('affordable');
                    btnBarrier.disabled = false;
                    btnBarrier.style.opacity = '0.6';
                    btnBarrier.style.cursor = 'not-allowed';
                }
            }

            // NEW: Barrier Size Upgrade Button
            const btnBarrierSize = document.getElementById('btn-barrier-size');
            if (btnBarrierSize) {
                const sizeCost = shopCosts.upgradeBarrierSize;
                // FIXED: Upgrade amounts increased by 10%
                const sizeWidthBonus = barrierSizeLevel * 12 * 1.1;
                const sizeHeightBonus = barrierSizeLevel * 10 * 1.1;
                const nextWidthBonus = (barrierSizeLevel + 1) * 12 * 1.1;
                const nextHeightBonus = (barrierSizeLevel + 1) * 10 * 1.1;
                
                btnBarrierSize.innerHTML = `
                    <div class="btn-label">
                        <span class="shop-icon">üìè</span> 
                        <div class="btn-text-group">
                            <div class="btn-main">INCREASE SIZE</div>
                            <div class="btn-sub">LVL ${barrierSizeLevel}/2</div>
                            <div class="btn-tiny-stats">+${sizeWidthBonus}%W +${sizeHeightBonus}%H ‚ûú +${nextWidthBonus}%W +${nextHeightBonus}%H</div>
                        </div>
                    </div>
                    <div class="btn-price">$${sizeCost}</div>
                `;
                
                if (defenseCoins >= sizeCost && barrierSizeLevel < 2) {
                    btnBarrierSize.classList.add('affordable');
                    btnBarrierSize.disabled = false;
                    btnBarrierSize.style.opacity = '1';
                    btnBarrierSize.style.cursor = 'pointer';
                } else {
                    btnBarrierSize.classList.remove('affordable');
                    btnBarrierSize.disabled = false;
                    btnBarrierSize.style.opacity = barrierSizeLevel >= 2 ? '0.3' : '0.6';
                    btnBarrierSize.style.cursor = 'not-allowed';
                }
            }

            // NEW: Barrier Wall Upgrade Button
            const btnBarrierWall = document.getElementById('btn-barrier-wall');
            if (btnBarrierWall) {
                const wallCost = shopCosts.upgradeBarrierWall;
                const isOwned = barrierWallCount >= 1;
                
                btnBarrierWall.innerHTML = `
                    <div class="btn-label">
                        <span class="shop-icon">üß±</span> 
                        <div class="btn-text-group">
                            <div class="btn-main">ADD WALL</div>
                            <div class="btn-sub">${isOwned ? 'OWNED' : 'UNLOCK'}</div>
                            <div class="btn-tiny-stats">${isOwned ? 'DUAL DEPLOY' : 'SPAWN 2 WALLS'}</div>
                        </div>
                    </div>
                    <div class="btn-price">${isOwned ? 'OWNED' : '$' + wallCost}</div>
                `;
                
                if (defenseCoins >= wallCost && !isOwned) {
                    btnBarrierWall.classList.add('affordable');
                    btnBarrierWall.disabled = false;
                    btnBarrierWall.style.opacity = '1';
                    btnBarrierWall.style.cursor = 'pointer';
                } else {
                    btnBarrierWall.classList.remove('affordable');
                    btnBarrierWall.disabled = false;
                    btnBarrierWall.style.opacity = isOwned ? '0.5' : '0.6';
                    btnBarrierWall.style.cursor = 'not-allowed';
                }
            }

            // NEW: Barrier Thorns Upgrade Button
            const btnBarrierThorns = document.getElementById('btn-barrier-thorns');
            if (btnBarrierThorns) {
                const thornsCost = shopCosts.upgradeBarrierThorns;
                const thornsCount = barrierThornsLevel * 8; // Base 8 thorns per level
                const nextThornsCount = (barrierThornsLevel + 1) * 8;
                const thornsDmg = 15 + (barrierThornsLevel * 10); // Base 15 + 10 per level
                const nextThornsDmg = 15 + ((barrierThornsLevel + 1) * 10);
                
                btnBarrierThorns.innerHTML = `
                    <div class="btn-label">
                        <span class="shop-icon">üåµ</span> 
                        <div class="btn-text-group">
                            <div class="btn-main">THORNS</div>
                            <div class="btn-sub">LVL ${barrierThornsLevel}/3</div>
                            <div class="btn-tiny-stats">${thornsCount} THORNS ${thornsDmg}DMG ‚ûú ${nextThornsCount} ${nextThornsDmg}DMG</div>
                        </div>
                    </div>
                    <div class="btn-price">$${thornsCost}</div>
                `;
                
                if (defenseCoins >= thornsCost && barrierThornsLevel < 3) {
                    btnBarrierThorns.classList.add('affordable');
                    btnBarrierThorns.disabled = false;
                    btnBarrierThorns.style.opacity = '1';
                    btnBarrierThorns.style.cursor = 'pointer';
                } else {
                    btnBarrierThorns.classList.remove('affordable');
                    btnBarrierThorns.disabled = false;
                    btnBarrierThorns.style.opacity = barrierThornsLevel >= 3 ? '0.3' : '0.6';
                    btnBarrierThorns.style.cursor = 'not-allowed';
                }
            }
            
            // NEW: Core Shield Button
            const btnShield = document.getElementById('btn-shield');
            if (btnShield) {
                const sCost = shopCosts.upgradeShield;
                const nextShield = coreShieldLevel === 0 ? 50 : Math.floor(50 * Math.pow(1.5, coreShieldLevel));
                
                btnShield.innerHTML = `
                    <div class="btn-label">
                        <span class="shop-icon">üõ°Ô∏è</span> 
                        <div class="btn-text-group">
                            <div class="btn-main">CORE SHIELD</div>
                            <div class="btn-sub">${coreShieldLevel === 0 ? 'UNLOCK' : 'LVL ' + coreShieldLevel}</div>
                            <div class="btn-tiny-stats">CAP: ${coreShieldMax} ‚ûú ${coreShieldMax + nextShield}</div>
                        </div>
                    </div>
                    <div class="btn-price">$${sCost}</div>
                `;
                
                if (defenseCoins >= sCost) {
                    btnShield.classList.add('affordable');
                    btnShield.disabled = false;
                    btnShield.style.opacity = '1';
                    btnShield.style.cursor = 'pointer';
                } else {
                    btnShield.classList.remove('affordable');
                    btnShield.disabled = false;
                    btnShield.style.opacity = '1';
                    btnShield.style.cursor = 'default';
                }
            }

            // NEW: Shield Quick Regen Button
            const btnShieldRegen = document.getElementById('btn-shield-regen');
            if (btnShieldRegen) {
                const regenCost = shopCosts.upgradeShieldRegen;
                // FIXED: Upgrade amounts increased by 10%
                const regenBonus = coreShieldRegenLevel * 2.5 * 1.1; // 2.75% per level
                const nextRegenBonus = (coreShieldRegenLevel + 1) * 2.5 * 1.1;
                
                btnShieldRegen.innerHTML = `
                    <div class="btn-label">
                        <span class="shop-icon">‚ö°</span> 
                        <div class="btn-text-group">
                            <div class="btn-main">QUICK REGEN</div>
                            <div class="btn-sub">LVL ${coreShieldRegenLevel}</div>
                            <div class="btn-tiny-stats">+${regenBonus.toFixed(1)}% ‚ûú +${nextRegenBonus.toFixed(1)}%/s</div>
                        </div>
                    </div>
                    <div class="btn-price">$${regenCost}</div>
                `;
                
                if (defenseCoins >= regenCost && coreShieldMax > 0) {
                    btnShieldRegen.classList.add('affordable');
                    btnShieldRegen.disabled = false;
                    btnShieldRegen.style.opacity = '1';
                    btnShieldRegen.style.cursor = 'pointer';
                } else {
                    btnShieldRegen.classList.remove('affordable');
                    btnShieldRegen.disabled = false;
                    btnShieldRegen.style.opacity = coreShieldMax > 0 ? '0.6' : '0.3';
                    btnShieldRegen.style.cursor = 'not-allowed';
                }
            }

            // NEW: Shield Durability Button
            const btnShieldDurability = document.getElementById('btn-shield-durability');
            if (btnShieldDurability) {
                const durabilityCost = shopCosts.upgradeShieldDurability;
                // FIXED: Upgrade amounts increased by 10%
                const durabilityReduction = coreShieldDurabilityLevel * 5 * 1.1; // 5.5% per level
                const nextDurabilityReduction = (coreShieldDurabilityLevel + 1) * 5 * 1.1;
                
                btnShieldDurability.innerHTML = `
                    <div class="btn-label">
                        <span class="shop-icon">üíé</span> 
                        <div class="btn-text-group">
                            <div class="btn-main">DURABILITY</div>
                            <div class="btn-sub">LVL ${coreShieldDurabilityLevel}</div>
                            <div class="btn-tiny-stats">-${durabilityReduction}% ‚ûú -${nextDurabilityReduction}% DMG</div>
                        </div>
                    </div>
                    <div class="btn-price">$${durabilityCost}</div>
                `;
                
                if (defenseCoins >= durabilityCost && coreShieldMax > 0) {
                    btnShieldDurability.classList.add('affordable');
                    btnShieldDurability.disabled = false;
                    btnShieldDurability.style.opacity = '1';
                    btnShieldDurability.style.cursor = 'pointer';
                } else {
                    btnShieldDurability.classList.remove('affordable');
                    btnShieldDurability.disabled = false;
                    btnShieldDurability.style.opacity = coreShieldMax > 0 ? '0.6' : '0.3';
                    btnShieldDurability.style.cursor = 'not-allowed';
                }
            }

            updateShopBtn('btn-grab', 'grab', 'UPGRADE GRAB', 'üß≤');
            
            // NEW: Complex Turret Button Logic (Unlock vs Deploy)
            const btnTurret = document.getElementById('btn-turret');
            if (btnTurret) {
                if (!isTurretUnlocked) {
                    // LOCKED STATE: Show Unlock Button
                    const cost = shopCosts.unlockTurret;
                    btnTurret.innerHTML = `
                        <div class="btn-label">
                            <span class="shop-icon">üîí</span> 
                            <div class="btn-text-group">
                                <div class="btn-main">UNLOCK TURRET</div>
                                <div class="btn-sub">REQUIRED TO DEPLOY</div>
                            </div>
                        </div>
                        <div class="btn-price">$${cost}</div>
                    `;
                    
                    if (defenseCoins >= cost) {
                        btnTurret.classList.add('affordable');
                        btnTurret.style.opacity = '1';
                    } else {
                        btnTurret.classList.remove('affordable');
                        btnTurret.style.opacity = '1';
                    }
                } else {
                    // UNLOCKED STATE: Show Deploy Button
                    const cost = shopCosts.turret;
                    btnTurret.innerHTML = `
                        <div class="btn-label">
                            <span class="shop-icon">ü§ñ</span> 
                            <div class="btn-text-group">
                                <div class="btn-main">SENTRY TURRET</div>
                            </div>
                        </div>
                        <div class="btn-price">$${cost}</div>
                    `;
                    
                    if (defenseCoins >= cost) {
                        btnTurret.classList.add('affordable');
                    } else {
                        btnTurret.classList.remove('affordable');
                    }
                }
                btnTurret.disabled = false;
                btnTurret.style.cursor = 'pointer';
            }
            
            // NEW: Turret Upgrade Buttons UI Logic (Handle Locking)
            const renderUpgradeBtn = (btn, id, type, title, level, current, next, unit) => {
                if (!btn) return;

                if (!isTurretUnlocked) {
                    // LOCKED STATE - UPDATED: Blurred Name
                    btn.innerHTML = `
                        <div class="btn-label" style="opacity:0.5">
                            <span class="shop-icon">üîí</span> 
                            <div class="btn-text-group">
                                <div class="btn-main" style="filter: blur(5px); user-select: none;">${title}</div>
                                <div class="btn-sub">LOCKED</div>
                            </div>
                        </div>
                    `;
                    btn.className = 'shop-btn'; // Remove affordable/etc
                    btn.style.cursor = 'not-allowed';
                    return;
                }

                // UNLOCKED STATE
                const cost = shopCosts[type];
                btn.innerHTML = `
                    <div class="btn-label">
                        <span class="shop-icon">${id === 'fire' ? '‚ö°' : 'üì°'}</span> 
                        <div class="btn-text-group">
                            <div class="btn-main">${title}</div>
                            <div class="btn-sub">LVL ${level}</div>
                            <div class="btn-tiny-stats">${unit}: ${current} ‚ûú ${next}</div>
                        </div>
                    </div>
                    <div class="btn-price">$${cost}</div>
                `;
                
                if (defenseCoins >= cost) {
                    btn.classList.add('affordable');
                    btn.style.cursor = 'pointer';
                } else {
                    btn.classList.remove('affordable');
                    btn.style.cursor = 'default';
                }
            };

            // Fire Rate Button
            const curFire = (0.47 * Math.pow(0.85, turretFireRateLevel - 1)).toFixed(2);
            const nextFire = (0.47 * Math.pow(0.85, turretFireRateLevel)).toFixed(2);
            renderUpgradeBtn(document.getElementById('btn-turret-fire'), 'fire', 'upgradeTurretFire', 'TURRET RATE', turretFireRateLevel, curFire + 's', nextFire + 's', 'DELAY');

            // Range Button
            const curRange = Math.floor(91 * (1 + (turretRangeLevel - 1) * 0.2));
            const nextRange = Math.floor(91 * (1 + turretRangeLevel * 0.2));
            renderUpgradeBtn(document.getElementById('btn-turret-range'), 'upgradeTurretRange', 'TURRET RANGE', turretRangeLevel, curRange, nextRange, 'DIST');


            // RESTORED: Nuke Button
            updateShopBtn('btn-nuke', 'nuke', 'NUKE', '‚ò¢Ô∏è');

             // Weapons
            // UPDATED: Custom Logic for Mass Cannon (Heavy) to show Upgrade text inside
            const btnHeavy = document.getElementById('btn-buy-heavy');
            if (btnHeavy) {
                const heavyCost = shopCosts.upgradeHeavy;
                
                // Calculate Power Stats
                const currentPwr = (1 + (massCannonLevel - 1) * 0.25).toFixed(2);
                const nextPwr = (1 + massCannonLevel * 0.25).toFixed(2);

                btnHeavy.innerHTML = `
                    <div class="btn-label">
                        <span class="shop-icon">üí£</span>
                        <div class="btn-text-group">
                            <div class="btn-main">MASS CANNON</div>
                            <div class="btn-sub">UPGRADE LVL ${massCannonLevel}</div>
                            <div class="btn-tiny-stats">PWR: ${currentPwr}x ‚ûú ${nextPwr}x</div>
                        </div>
                    </div>
                    <div class="btn-price">$${heavyCost}</div>
                `;
                
                if (defenseCoins >= heavyCost) {
                    btnHeavy.classList.add('affordable');
                    btnHeavy.disabled = false;
                    btnHeavy.style.opacity = '1';
                    btnHeavy.style.cursor = 'pointer';
                } else {
                    btnHeavy.classList.remove('affordable');
                    // Even if not affordable, we keep opacity mostly up so they can see the upgrade option exists
                    btnHeavy.disabled = false; 
                    btnHeavy.style.opacity = '1'; 
                    btnHeavy.style.cursor = 'default';
                }
            }

            // NEW: Max Charge Upgrade Button (Sub-upgrade)
            const btnMaxCharge = document.getElementById('btn-buy-maxcharge');
            if (btnMaxCharge) {
                const maxChargeCost = shopCosts.upgradeMaxCharge;
                
                if (hasMaxChargeUpgrade) {
                    btnMaxCharge.innerHTML = `
                        <div class="btn-label">
                            <span class="shop-icon">‚ö°</span>
                            <div class="btn-text-group">
                                <div class="btn-main">MAX CHARGE</div>
                                <div class="btn-sub">PURCHASED</div>
                                <div class="btn-tiny-stats">3x DMG</div>
                            </div>
                        </div>
                        <div class="btn-price">SOLD</div>
                    `;
                    btnMaxCharge.disabled = true;
                    btnMaxCharge.classList.remove('affordable');
                } else {
                    btnMaxCharge.innerHTML = `
                        <div class="btn-label">
                            <span class="shop-icon">‚ö°</span>
                            <div class="btn-text-group">
                                <div class="btn-main">MAX CHARGE</div>
                                <div class="btn-sub">UPGRADE</div>
                                <div class="btn-tiny-stats">2x ‚ûú 3x DMG</div>
                            </div>
                        </div>
                        <div class="btn-price">$${maxChargeCost}</div>
                    `;
                    
                    if (defenseCoins >= maxChargeCost) {
                        btnMaxCharge.classList.add('affordable');
                        btnMaxCharge.disabled = false;
                    } else {
                        btnMaxCharge.classList.remove('affordable');
                        btnMaxCharge.disabled = false;
                    }
                }
            }
            
            // REMOVED: Separate Upgrade Button Update

            updateShopBtn('btn-buy-explosive', 'explosive', 'EXPLOSIVE', 'üí•', true);
            updateShopBtn('btn-buy-raygun', 'raygun', 'MAG-LEV', 'üî´', true);
            updateShopBtn('btn-buy-shockwave', 'shockwave', 'SHOCKWAVE', 'üåä', true);
            updateShopBtn('btn-buy-blackhole', 'blackhole', 'BLACK HOLE', '‚ö´', true);
        }

        function toggleShop() {
            const shop = document.getElementById('defense-shop');
            if (shop.style.display === 'flex') {
                shop.style.display = 'none';
                isShopOpen = false; // FIXED: Set flag when closing shop
                if(gameState === 'playing') {
                    const promise = document.body.requestPointerLock();
                    if(promise) promise.catch(e => {});
                }
            } else {
                shop.style.display = 'flex';
                isShopOpen = true; // FIXED: Set flag when opening shop
                document.exitPointerLock();
                // Update UI immediately so buttons are correct
                updateDefenseUI();
            }
        }


        // --- SHOP FUNCTIONS ---
        function buyRepair() {
            const cost = shopCosts.repair;
            if (defenseCoins >= cost) {
                // MULTIPLAYER: Send purchase to server (server validates and syncs)
                if (isMultiplayerEnabled && socket && socket.connected) {
                    socket.emit('shopPurchase', {
                        type: 'repair',
                        cost: cost
                    });
                    // Wait for server confirmation before applying locally
                    return;
                }
                
                // Single player or no connection - apply immediately
                defenseCoins -= cost;
                defenseCoreHealth = Math.min(100, defenseCoreHealth + 25);
                
                // Increase Cost (10% increase)
                shopCosts.repair = Math.floor(cost * 1.1);
                
                SoundManager.playCharge(0.5); 
                statusEl.innerText = "CORE REPAIRED (+25%)";
                updateDefenseUI();
            } else {
                statusEl.innerText = "INSUFFICIENT FUNDS";
            }
        }

        // NEW: Buy Shield Upgrade
        function buyCoreShieldUpgrade() {
            const cost = shopCosts.upgradeShield;
            if (defenseCoins >= cost) {
                defenseCoins -= cost;
                
                coreShieldLevel++;
                
                // Base 50, +50% capacity per level (exponential curve for late game)
                // Level 1: 50
                // Level 2: 125 (+75)
                // Level 3: 237 (+112) ...
                const addedCap = Math.floor(50 * Math.pow(1.5, coreShieldLevel - 1));
                coreShieldMax += addedCap;
                coreShieldCurrent = coreShieldMax; // Full restore on upgrade
                
                // Increase Cost (35% increase)
                shopCosts.upgradeShield = Math.floor(cost * 1.35);
                
                // Show Visual if newly unlocked
                if(coreShieldLevel === 1 && defenseCoreMesh && defenseCoreMesh.userData.shield) {
                    defenseCoreMesh.userData.shield.visible = true;
                }

                SoundManager.playCharge(0.7);
                statusEl.innerText = `SHIELD UPGRADED (MAX ${coreShieldMax})`;
                updateDefenseUI();
            } else {
                statusEl.innerText = "INSUFFICIENT FUNDS";
            }
        }

        // NEW: Buy Shield Quick Regen Upgrade
        function buyShieldRegenUpgrade() {
            const cost = shopCosts.upgradeShieldRegen;
            if (defenseCoins >= cost) {
                defenseCoins -= cost;
                
                coreShieldRegenLevel++;
                
                // Increase Cost (30% increase)
                shopCosts.upgradeShieldRegen = Math.floor(cost * 1.3);
                
                SoundManager.playCharge(0.6);
                statusEl.innerText = `QUICK REGEN LVL ${coreShieldRegenLevel}`;
                updateDefenseUI();
            } else {
                statusEl.innerText = "INSUFFICIENT FUNDS";
            }
        }

        // NEW: Buy Shield Durability Upgrade
        function buyShieldDurabilityUpgrade() {
            const cost = shopCosts.upgradeShieldDurability;
            if (defenseCoins >= cost) {
                defenseCoins -= cost;
                
                coreShieldDurabilityLevel++;
                
                // Increase Cost (30% increase)
                shopCosts.upgradeShieldDurability = Math.floor(cost * 1.3);
                
                SoundManager.playCharge(0.6);
                statusEl.innerText = `DURABILITY LVL ${coreShieldDurabilityLevel}`;
                updateDefenseUI();
            } else {
                statusEl.innerText = "INSUFFICIENT FUNDS";
            }
        }

        function buyGrabUpgrade() {
            const cost = shopCosts.grab;
            if (defenseCoins >= cost) {
                defenseCoins -= cost;
                
                // NEW: Changed upgrade amount from 10 to 5
                CONFIG.grabRadius += 5;
                
                // Visually update the slider to match upgrade
                sliderInput.value = CONFIG.grabRadius;
                sliderVal.innerText = CONFIG.grabRadius;

                // Increase Cost (30% increase - gets expensive fast)
                shopCosts.grab = Math.floor(cost * 1.3);

                SoundManager.playCharge(0.8);
                // NEW: Updated status text
                statusEl.innerText = "GRAB RADIUS INCREASED (+5)";
                updateDefenseUI();
            } else {
                statusEl.innerText = "INSUFFICIENT FUNDS";
            }
        }

        // NEW: Max Charge Upgrade Function
        function buyMaxChargeUpgrade() {
            // FIXED: Ensure shop stays open and pointer lock doesn't activate
            if (isShopOpen) {
                document.exitPointerLock();
            }
            
            if (hasMaxChargeUpgrade) {
                statusEl.innerText = "ALREADY PURCHASED";
                return;
            }
            
            const cost = shopCosts.upgradeMaxCharge;
            if (defenseCoins >= cost) {
                // MULTIPLAYER: Send purchase to server (server validates and syncs)
                if (isMultiplayerEnabled && socket && socket.connected) {
                    socket.emit('shopPurchase', {
                        type: 'upgradeMaxCharge',
                        cost: cost
                    });
                    // Wait for server confirmation before applying locally
                    return;
                }
                
                // Single player or offline - apply immediately
                defenseCoins -= cost;
                hasMaxChargeUpgrade = true;

                SoundManager.playCharge(0.7);
                statusEl.innerText = "MAX CHARGE UPGRADED (2x -> 3x DMG)";
                updateDefenseUI();
            } else {
                statusEl.innerText = "INSUFFICIENT FUNDS";
            }
        }
        
        // NEW: Mass Cannon Upgrade Function
        function buyMassCannonUpgrade() {
            const cost = shopCosts.upgradeHeavy;
            if (defenseCoins >= cost) {
                // MULTIPLAYER: Send purchase to server (server validates and syncs)
                if (isMultiplayerEnabled && socket && socket.connected) {
                    socket.emit('shopPurchase', {
                        type: 'upgradeHeavy',
                        cost: cost
                    });
                    // Wait for server confirmation before applying locally
                    return;
                }
                
                // Single player or no connection - apply immediately
                defenseCoins -= cost;
                
                massCannonLevel++;
                
                // Increase Cost (30% increase per level)
                shopCosts.upgradeHeavy = Math.floor(cost * 1.3);

                SoundManager.playCharge(0.7);
                statusEl.innerText = "CANNON UPGRADED (LVL " + massCannonLevel + ")";
                updateDefenseUI();
            } else {
                statusEl.innerText = "INSUFFICIENT FUNDS";
            }
        }

        // NEW: Buy Weapon Function
        function buyWeapon(type) {
            if (unlockedWeapons.includes(type)) return; // Already owned

            const cost = shopCosts[type];
            if (defenseCoins >= cost) {
                defenseCoins -= cost;
                
                unlockedWeapons.push(type);
                updateAmmoMenuVisuals();
                
                SoundManager.playCharge(0.6);
                statusEl.innerText = "WEAPON UNLOCKED: " + type.toUpperCase();
                
                updateDefenseUI();
            } else {
                statusEl.innerText = "INSUFFICIENT FUNDS";
            }
        }

        function buyBarrier() {
            const cost = shopCosts.barrier;
            if (defenseCoins >= cost) {
                // NEW: Trigger Placement Mode instead of instant buy
                toggleShop(); // Close UI
                startBarrierPlacement();
            } else {
                statusEl.innerText = "INSUFFICIENT FUNDS";
            }
        }

        // NEW: Buy Barrier Size Upgrade
        function buyBarrierSizeUpgrade() {
            if (barrierSizeLevel >= 2) return; // Max level reached
            
            const cost = shopCosts.upgradeBarrierSize;
            if (defenseCoins >= cost) {
                defenseCoins -= cost;
                barrierSizeLevel++;
                
                // Increase Cost (25% increase)
                shopCosts.upgradeBarrierSize = Math.floor(cost * 1.25);
                
                SoundManager.playCharge(0.6);
                statusEl.innerText = `BARRIER SIZE LVL ${barrierSizeLevel}`;
                updateDefenseUI();
            } else {
                statusEl.innerText = "INSUFFICIENT FUNDS";
            }
        }

        // NEW: Buy Barrier Wall Upgrade
        function buyBarrierWallUpgrade() {
            if (barrierWallCount >= 1) return; // Max level reached
            
            const cost = shopCosts.upgradeBarrierWall;
            if (defenseCoins >= cost) {
                defenseCoins -= cost;
                barrierWallCount = 1;
                
                SoundManager.playCharge(0.7);
                statusEl.innerText = "DUAL WALL UNLOCKED";
                updateDefenseUI();
            } else {
                statusEl.innerText = "INSUFFICIENT FUNDS";
            }
        }

        // NEW: Buy Barrier Thorns Upgrade
        function buyBarrierThornsUpgrade() {
            if (barrierThornsLevel >= 3) return; // Max level reached
            
            const cost = shopCosts.upgradeBarrierThorns;
            if (defenseCoins >= cost) {
                defenseCoins -= cost;
                barrierThornsLevel++;
                
                // Increase Cost (30% increase)
                shopCosts.upgradeBarrierThorns = Math.floor(cost * 1.3);
                
                SoundManager.playCharge(0.6);
                statusEl.innerText = `THORNS LVL ${barrierThornsLevel}`;
                updateDefenseUI();
            } else {
                statusEl.innerText = "INSUFFICIENT FUNDS";
            }
        }

        // NEW: Placement Mode Logic
        function startBarrierPlacement() {
            isPlacingBarrier = true;
            placementRotationOffset = 0; // Reset rotation
            statusEl.innerText = "[L-CLICK] CONFIRM  |  [R-CLICK] CANCEL  |  [R] ROTATE";
            statusEl.classList.add('aiming');
            
            // Create the ghost visual (isGhost = true)
            // UPDATED: Pass null for customRotation
            placementGhost = spawnEnergyBarrier(new THREE.Vector3(0, -100, 0), null, true);
            scene.add(placementGhost);
        }

        function cancelPlacement() {
            isPlacingBarrier = false;
            placementRotationOffset = 0;
            if (placementGhost) {
                scene.remove(placementGhost);
                placementGhost = null;
            }
            statusEl.innerText = "READY";
            statusEl.classList.remove('aiming');
        }

        function confirmPlacement() {
            if (!placementGhost) return;
            
            const cost = shopCosts.barrier;
            if (defenseCoins >= cost) {
                defenseCoins -= cost;
                
                // Spawn Real Barrier at Ghost Position
                // UPDATED: Pass the ghost's rotation to the real barrier
                spawnEnergyBarrier(placementGhost.position, placementGhost.rotation.y, false, false); 
                
                // Increase Cost
                shopCosts.barrier = Math.floor(cost * 1.2);
                
                SoundManager.playShoot('heavy');
                statusEl.innerText = "BARRIER DEPLOYED";
                updateDefenseUI();
                
                // Cleanup
                cancelPlacement();
            }
        }

        // NEW: Update loop for ghost positioning
        function updatePlacement() {
            if (!isPlacingBarrier || !placementGhost) return;

            raycaster.setFromCamera(centerScreen, camera);
            const intersects = raycaster.intersectObjects(collidables);
            
            let targetPos = new THREE.Vector3();
            
            if (intersects.length > 0) {
                targetPos.copy(intersects[0].point);
            } else {
                // If aiming at sky, project forward at ground level
                const dir = new THREE.Vector3(); 
                camera.getWorldDirection(dir);
                targetPos.copy(camera.position).add(dir.multiplyScalar(40));
                targetPos.y = 0;
            }

            // Smart Placement Logic (Push away from Core)
            const distFromCenter = Math.sqrt(targetPos.x * targetPos.x + targetPos.z * targetPos.z);
            if (distFromCenter < 12) {
                const angle = Math.atan2(targetPos.z, targetPos.x);
                targetPos.x = Math.cos(angle) * 18;
                targetPos.z = Math.sin(angle) * 18;
            }
            
            // Snap to grid-ish or floor
            if (targetPos.y < 0) targetPos.y = 0;

            targetPos.y = 0; 

            placementGhost.position.copy(targetPos);
            placementGhost.position.y = 8.1 / 2; // Match the height/2 offset from spawn function

            // Rotation Logic (Snap to 90 degrees + Manual Offset)
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            const angle = Math.atan2(dir.x, dir.z);
            const snapAngle = Math.round(angle / (Math.PI/2)) * (Math.PI/2);
            
            // UPDATED: Add manual rotation offset
            placementGhost.rotation.y = snapAngle + placementRotationOffset;
        }

        // REDESIGNED: "Aurora Shield" Heavy Barrier
        // UPDATED: Added customRotation parameter and upgrade support
        function spawnEnergyBarrier(pos, customRotation = null, isGhost = false, isSecondWall = false) {
            // NEW: Apply size upgrades (12% width, 10% height per level)
            const baseWidth = 8.0;
            const baseHeight = 8.1;
            // FIXED: Upgrade amounts increased by 10%
            const width = baseWidth * Math.pow(1.12 * 1.1, barrierSizeLevel); // 12% * 1.1 = 13.2% per level
            const height = baseHeight * Math.pow(1.10 * 1.1, barrierSizeLevel); // 10% * 1.1 = 11% per level
            const depth = 2.5;

            let finalAngle;
            if (customRotation !== null) {
                finalAngle = customRotation;
            } else {
                // Snap rotation defaults if no custom rotation provided
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                const angle = Math.atan2(dir.x, dir.z);
                finalAngle = Math.round(angle / (Math.PI/2)) * (Math.PI/2);
            }

            let body = null;

            // 1. Physics Body (Static Box) - SKIP IF GHOST
            if (!isGhost) {
                body = new CANNON.Body({ mass: 0 });
                body.position.set(pos.x, height/2, pos.z);
                
                const q = new CANNON.Quaternion();
                q.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), finalAngle); // Use finalAngle
                body.quaternion.copy(q);

                const shape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
                body.addShape(shape);
                
                body.collisionFilterGroup = 1;
                body.collisionFilterMask = -1;
                world.addBody(body);
            }

            // 2. Visual Group
            const group = new THREE.Group();
            
            if (isGhost) {
                // If ghost, manually set position/rotation (since no body to copy from)
                group.position.set(pos.x, height/2, pos.z);
                group.rotation.y = finalAngle; // Use finalAngle
            } else {
                group.position.copy(body.position);
                group.quaternion.copy(body.quaternion);
            }

            // --- A. THE GENERATOR BASE (High Detail) ---
            const baseMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.85, roughness: 0.3 });
            const darkMat = new THREE.MeshStandardMaterial({ color: 0x050505, metalness: 0.5, roughness: 0.8 });
            const hazardMat = new THREE.MeshBasicMaterial({ color: 0x00ccff });
            
            // Main Chassis Block
            const chassis = new THREE.Mesh(new THREE.BoxGeometry(width - 2, 1.2, 3), baseMat);
            chassis.position.y = -height/2 + 0.6;
            group.add(chassis);

            // Top Armor Plate
            const topPlate = new THREE.Mesh(new THREE.BoxGeometry(width - 3, 0.4, 2.2), darkMat);
            topPlate.position.y = -height/2 + 1.3;
            group.add(topPlate);

            // Heavy Stabilizer Feet (Left & Right)
            const legGeo = new THREE.BoxGeometry(2.5, 1.8, 4.5);
            const legL = new THREE.Mesh(legGeo, baseMat); legL.position.set(-width/2 + 1.25, -height/2 + 0.9, 0); group.add(legL);
            const legR = new THREE.Mesh(legGeo, baseMat); legR.position.set(width/2 - 1.25, -height/2 + 0.9, 0); group.add(legR);

            // Hazard Stripes
            const stripeGeo = new THREE.BoxGeometry(2.3, 0.1, 4.0);
            const stripeL = new THREE.Mesh(stripeGeo, hazardMat); stripeL.position.set(-width/2 + 1.25, -height/2 + 1.81, 0); group.add(stripeL);
            const stripeR = new THREE.Mesh(stripeGeo, hazardMat); stripeR.position.set(width/2 - 1.25, -height/2 + 1.81, 0); group.add(stripeR);

            // Caution Bars
            const barGeo = new THREE.BoxGeometry(0.4, 0.12, 4.1);
            const barMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            for(let k=0; k<5; k++) {
                const offset = (k * 0.6) - 1.2;
                const bL = new THREE.Mesh(barGeo, barMat); bL.position.set(-width/2 + 1.25 + offset, -height/2 + 1.82, 0); bL.rotation.y = 0.3; group.add(bL);
                const bR = new THREE.Mesh(barGeo, barMat); bR.position.set(width/2 - 1.25 + offset, -height/2 + 1.82, 0); bR.rotation.y = 0.3; group.add(bR);
            }

            // REMOVED: Central Reactor Vent (The weird blue circle on the base)

            // --- B. VERTICAL PROJECTORS ---
            const pylonGeo = new THREE.BoxGeometry(1.8, height - 1, 1.8);
            const pylonL = new THREE.Mesh(pylonGeo, darkMat); pylonL.position.set(-width/2 + 1.25, 0.5, 0); group.add(pylonL);
            const pylonR = new THREE.Mesh(pylonGeo, darkMat); pylonR.position.set(width/2 - 1.25, 0.5, 0); group.add(pylonR);

            const rodGeo = new THREE.CylinderGeometry(0.3, 0.3, height - 2, 8);
            const rodMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const rodL = new THREE.Mesh(rodGeo, rodMat); rodL.position.set(-width/2 + 1.25, 0.5, 0.91); group.add(rodL);
            const rodR = new THREE.Mesh(rodGeo, rodMat); rodR.position.set(width/2 - 1.25, 0.5, 0.91); group.add(rodR);
            const rodL_Back = rodL.clone(); rodL_Back.position.z = -0.91; group.add(rodL_Back);
            const rodR_Back = rodR.clone(); rodR_Back.position.z = -0.91; group.add(rodR_Back);

            // --- C. THE FIELD ---
            const fieldW = width - 3.5; 
            const fieldH = height - 2;
            
            const glassGeo = new THREE.BoxGeometry(fieldW, fieldH, 0.15);
            const glassMat = new THREE.MeshBasicMaterial({ color: 0x0066ff, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false });
            const glass = new THREE.Mesh(glassGeo, glassMat);
            glass.position.y = 0.5;
            group.add(glass);

            const hexMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.25, blending: THREE.AdditiveBlending });
            const hexGrid = new THREE.Mesh(new THREE.PlaneGeometry(fieldW, fieldH, 24, 12), hexMat);
            hexGrid.position.set(0, 0.5, 0.08); group.add(hexGrid);
            const hexGridBack = hexGrid.clone(); hexGridBack.rotation.y = Math.PI; hexGridBack.position.z = -0.08; group.add(hexGridBack);

            const scanGeo = new THREE.BoxGeometry(fieldW, 0.2, 0.3);
            const scanMat = new THREE.MeshBasicMaterial({ color: 0x88dbff, transparent: true, opacity: 0.9 });
            const scanline = new THREE.Mesh(scanGeo, scanMat);
            scanline.position.y = -fieldH/2 + 0.5;
            group.add(scanline);

            // --- D. FLOATING TECH ---
            // REMOVED: Floating Tech Nodes and Rings (Cleaned up look)

            // NEW: Add Thorns if upgrade is purchased
            let thornsGroup = null;
            if (barrierThornsLevel > 0 && !isGhost) {
                thornsGroup = new THREE.Group();
                const thornCount = 8 * barrierThornsLevel;
                const thornGeo = new THREE.ConeGeometry(0.15, 0.8, 6);
                const thornMat = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513, // Brown
                    metalness: 0.3,
                    roughness: 0.7
                });
                
                for (let i = 0; i < thornCount; i++) {
                    const thorn = new THREE.Mesh(thornGeo, thornMat.clone());
                    const angle = (i / thornCount) * Math.PI * 2;
                    const radius = width * 0.4;
                    thorn.position.set(
                        Math.cos(angle) * radius,
                        -height/2 + 0.4,
                        Math.sin(angle) * radius
                    );
                    thorn.rotation.z = Math.random() * 0.3 - 0.15;
                    thorn.rotation.y = angle;
                    // Make thorns jagged by scaling randomly
                    thorn.scale.set(
                        0.8 + Math.random() * 0.4,
                        0.7 + Math.random() * 0.6,
                        0.8 + Math.random() * 0.4
                    );
                    thornsGroup.add(thorn);
                }
                group.add(thornsGroup);
            }

            // HANDLE GHOST VISUALS
            if (isGhost) {
                // If it's a ghost, make everything transparent and holographic
                group.traverse((child) => {
                    if (child.isMesh) {
                        // Clone material to avoid affecting the real prefab if cached (though we create new mats here)
                        const ghostMat = child.material.clone();
                        ghostMat.transparent = true;
                        ghostMat.opacity = 0.4;
                        ghostMat.depthWrite = false;
                        ghostMat.wireframe = false; // Solid ghost easier to see? Or keep wireframe if it was
                        
                        // Force a color tint
                        if (ghostMat.color) ghostMat.color.setHex(0x00ff00); // Green hologram
                        
                        child.material = ghostMat;
                    }
                });
                
                return group; // Return early, no physics/anim setup needed
            }

            // Animation Data
            group.userData = {
                isBarrier: true,
                scanline: scanline,
                scanY: 0,
                fieldH: fieldH,
                life: 17.0, // UPDATED: 17 Seconds Lifetime
                thornsLevel: barrierThornsLevel, // Store for collision
                thornsGroup: thornsGroup
            };

            scene.add(group);
            collidables.push(group);
            defenseBarriers.push({ body: body, mesh: group });
            
            // NEW: Spawn second wall if upgrade is purchased
            if (barrierWallCount >= 1 && !isGhost && !isSecondWall) {
                const offset = width * 0.6; // Offset second wall
                const perpAngle = customRotation !== null ? customRotation + Math.PI/2 : Math.atan2(camera.getWorldDirection(new THREE.Vector3()).x, camera.getWorldDirection(new THREE.Vector3()).z) + Math.PI/2;
                const secondPos = new THREE.Vector3(
                    pos.x + Math.cos(perpAngle) * offset,
                    pos.y,
                    pos.z + Math.sin(perpAngle) * offset
                );
                spawnEnergyBarrier(secondPos, customRotation, false, true);
            }

            // Deploy Animation
            group.scale.set(1, 0.01, 1);
            let s = 0.01;
            const int = setInterval(() => {
                s += 0.05;
                if(s >= 1) { s=1; clearInterval(int); }
                group.scale.set(1, s, 1);
            }, 16);
        }

        function buyTurret() {
            // NEW: Unlock Logic
            if (!isTurretUnlocked) {
                const unlockCost = shopCosts.unlockTurret;
                if (defenseCoins >= unlockCost) {
                    defenseCoins -= unlockCost;
                    isTurretUnlocked = true;
                    
                    SoundManager.playCharge(0.8); // Unlock sound
                    statusEl.innerText = "TURRET TECH UNLOCKED";
                    updateDefenseUI();
                } else {
                    statusEl.innerText = "INSUFFICIENT FUNDS";
                }
                return;
            }

            // Normal Deploy Logic
            const cost = shopCosts.turret;
            if (defenseCoins >= cost) {
                defenseCoins -= cost;
                spawnTurret();
                
                // Increase Cost (40% increase - prevents turret spam lag)
                shopCosts.turret = Math.floor(cost * 1.4);

                SoundManager.playCharge(0.6);
                statusEl.innerText = "TURRET DEPLOYED";
                updateDefenseUI();
            } else {
                statusEl.innerText = "INSUFFICIENT FUNDS";
            }
        }

        // NEW: Turret Upgrade Functions
        function buyTurretFireRate() {
            if (!isTurretUnlocked) return; // Prevent buying if locked

            const cost = shopCosts.upgradeTurretFire;
            if (defenseCoins >= cost) {
                defenseCoins -= cost;
                turretFireRateLevel++;
                
                // Increase Cost (25% increase)
                shopCosts.upgradeTurretFire = Math.floor(cost * 1.25);

                SoundManager.playCharge(0.7);
                statusEl.innerText = "TURRET RATE UPGRADED";
                updateDefenseUI();
            } else {
                statusEl.innerText = "INSUFFICIENT FUNDS";
            }
        }

        function buyTurretRange() {
            if (!isTurretUnlocked) return; // Prevent buying if locked

            const cost = shopCosts.upgradeTurretRange;
            if (defenseCoins >= cost) {
                defenseCoins -= cost;
                turretRangeLevel++;
                
                // Increase Cost (25% increase)
                shopCosts.upgradeTurretRange = Math.floor(cost * 1.25);

                SoundManager.playCharge(0.7);
                statusEl.innerText = "TURRET RANGE UPGRADED";
                updateDefenseUI();
            } else {
                statusEl.innerText = "INSUFFICIENT FUNDS";
            }
        }

        // RESTORED: Nuke Function
        function buyNuke() {
            const cost = shopCosts.nuke;
            if (defenseCoins >= cost) {
                defenseCoins -= cost;
                
                // Increase Cost (50% increase - ultimate ability)
                shopCosts.nuke = Math.floor(cost * 1.5);

                SoundManager.playExplosion();
                createRedesignedExplosion(new THREE.Vector3(0, 20, 0), 3.0);
                
                // Kill all non-bosses, damage bosses heavily
                for (let i = defenseEnemies.length - 1; i >= 0; i--) {
                    const e = defenseEnemies[i];
                    if (e.isBoss) {
                        damageEnemy(e, 2000); // Massive damage to boss
                    } else {
                        killEnemy(i, true);
                    }
                }
                statusEl.innerText = "NUKE DETONATED";
                updateDefenseUI();
            } else {
                statusEl.innerText = "INSUFFICIENT FUNDS";
            }
        }

        function spawnTurret() {
            // Find ground position near center
            const angle = Math.random() * Math.PI * 2;
            const dist = 12 + Math.random() * 6; 
            const pos = new THREE.Vector3(Math.cos(angle) * dist, 0, Math.sin(angle) * dist);
            
            // Raycast down to find ground y
            const ray = new THREE.Raycaster(new THREE.Vector3(pos.x, 100, pos.z), new THREE.Vector3(0, -1, 0));
            const hits = ray.intersectObjects(collidables);
            if (hits.length > 0) pos.y = hits[0].point.y;

            // --- REDESIGNED TURRET: MK-IV "PHANTOM STRIKER" ---
            const group = new THREE.Group();
            group.position.copy(pos);

            // 1. Hexagonal Base Platform
            const baseGroup = new THREE.Group();
            
            // Main platform (hexagonal)
            const platformGeo = new THREE.CylinderGeometry(2.5, 2.5, 0.4, 6);
            const platformMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a2e, 
                metalness: 0.8, 
                roughness: 0.2 
            });
            const platform = new THREE.Mesh(platformGeo, platformMat);
            platform.rotation.z = Math.PI / 6; // Rotate hex
            baseGroup.add(platform);
            
            // Energy core in center
            const coreGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const coreMat = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.7
            });
            const core = new THREE.Mesh(coreGeo, coreMat);
            core.position.y = 0.3;
            baseGroup.add(core);
            
            // Support pillars (6 around platform)
            const pillarGeo = new THREE.CylinderGeometry(0.15, 0.2, 3.5, 8);
            const pillarMat = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a3e, 
                metalness: 0.7, 
                roughness: 0.3 
            });
            
            for (let i = 0; i < 6; i++) {
                const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                const angle = (i / 6) * Math.PI * 2;
                pillar.position.set(
                    Math.cos(angle) * 1.8,
                    2.0,
                    Math.sin(angle) * 1.8
                );
                baseGroup.add(pillar);
            }
            
            // Central mount column
            const mountGeo = new THREE.CylinderGeometry(0.6, 0.8, 3.8, 12);
            const mount = new THREE.Mesh(mountGeo, platformMat);
            mount.position.y = 2.0;
            baseGroup.add(mount);
            
            // Energy rings around mount
            const mountRingGeo = new THREE.TorusGeometry(0.7, 0.08, 8, 24);
            const mountRingMat = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.5
            });
            for (let i = 0; i < 3; i++) {
                const ring = new THREE.Mesh(mountRingGeo, mountRingMat.clone());
                ring.position.y = 1.0 + i * 1.2;
                ring.rotation.x = Math.PI / 2;
                baseGroup.add(ring);
            }

            group.add(baseGroup);

            // 2. Rotating Head Assembly (Y-Axis Swivel)
            const headGroup = new THREE.Group();
            headGroup.position.y = 3.9; 
            group.add(headGroup);

            // Main head housing (hexagonal)
            const headGeo = new THREE.CylinderGeometry(0.9, 1.0, 1.2, 6);
            const headMat = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a4e, 
                metalness: 0.9, 
                roughness: 0.1 
            });
            const head = new THREE.Mesh(headGeo, headMat);
            head.rotation.z = Math.PI / 6;
            headGroup.add(head);
            
            // Sensor array (top)
            const sensorArrayGeo = new THREE.BoxGeometry(0.6, 0.3, 0.6);
            const sensorArrayMat = new THREE.MeshStandardMaterial({ color: 0x444466 });
            const sensorArray = new THREE.Mesh(sensorArrayGeo, sensorArrayMat);
            sensorArray.position.y = 0.75;
            headGroup.add(sensorArray);
            
            // Active sensor (glowing)
            const activeSensorGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const activeSensorMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                transparent: true,
                opacity: 0.9
            });
            const activeSensor = new THREE.Mesh(activeSensorGeo, activeSensorMat);
            activeSensor.position.set(0, 0.9, 0.5);
            headGroup.add(activeSensor);

            // 3. Advanced Gun Assembly (X-Axis Pitch)
            const gunGroup = new THREE.Group();
            gunGroup.position.y = 0;
            headGroup.add(gunGroup); 

            // Main gun body (sleek design)
            const gunBodyGeo = new THREE.CylinderGeometry(0.5, 0.6, 2.8, 8);
            const gunBodyMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a3e, 
                metalness: 0.95, 
                roughness: 0.05 
            });
            const gunBody = new THREE.Mesh(gunBodyGeo, gunBodyMat);
            gunBody.rotation.x = Math.PI / 2;
            gunBody.position.z = 1.2;
            gunGroup.add(gunBody);
            
            // Energy coils (wrapped around barrel)
            const coilGeo = new THREE.TorusGeometry(0.52, 0.06, 8, 24);
            const coilMat = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.6
            });
            for (let i = 0; i < 4; i++) {
                const coil = new THREE.Mesh(coilGeo, coilMat.clone());
                coil.rotation.x = Math.PI / 2;
                coil.position.z = 0.5 + i * 0.6;
                gunGroup.add(coil);
            }

            // Dual barrels (more refined)
            const barrelGeo = new THREE.CylinderGeometry(0.15, 0.18, 3.5, 10);
            const barrelMat = new THREE.MeshStandardMaterial({ 
                color: 0x0a0a1a, 
                metalness: 1.0, 
                roughness: 0.0 
            });
            
            const b1 = new THREE.Mesh(barrelGeo, barrelMat);
            b1.rotation.x = Math.PI / 2;
            b1.position.set(-0.25, 0, 2.6);
            gunGroup.add(b1);
            
            const b2 = new THREE.Mesh(barrelGeo, barrelMat);
            b2.rotation.x = Math.PI / 2;
            b2.position.set(0.25, 0, 2.6);
            gunGroup.add(b2);

            // Muzzle tips (glowing)
            const muzzleGeo = new THREE.CylinderGeometry(0.16, 0.16, 0.3, 10);
            const muzzleMat = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00,
                transparent: true,
                opacity: 0.8
            });
            const muzzle1 = new THREE.Mesh(muzzleGeo, muzzleMat);
            muzzle1.rotation.x = Math.PI / 2;
            muzzle1.position.set(-0.25, 0, 4.15);
            gunGroup.add(muzzle1);
            const muzzle2 = new THREE.Mesh(muzzleGeo, muzzleMat.clone());
            muzzle2.rotation.x = Math.PI / 2;
            muzzle2.position.set(0.25, 0, 4.15);
            gunGroup.add(muzzle2);

            // Side stabilizers
            const stabilizerGeo = new THREE.BoxGeometry(0.3, 0.8, 1.2);
            const stabilizerMat = new THREE.MeshStandardMaterial({ color: 0x2a2a4e });
            const stab1 = new THREE.Mesh(stabilizerGeo, stabilizerMat);
            stab1.position.set(-0.7, 0, 1.5);
            gunGroup.add(stab1);
            const stab2 = new THREE.Mesh(stabilizerGeo, stabilizerMat);
            stab2.position.set(0.7, 0, 1.5);
            gunGroup.add(stab2);
            
            // Targeting laser emitter
            const laserGeo = new THREE.BoxGeometry(0.2, 0.15, 0.4);
            const laserMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const laser = new THREE.Mesh(laserGeo, laserMat);
            laser.position.set(0, 0.5, 2.0);
            gunGroup.add(laser);

            // 4. Data for Animation
            group.userData = {
                head: headGroup,
                gun: gunGroup,
                barrels: [b1, b2],
                activeSensor: activeSensor,
                baseY: pos.y,
                mountHeight: 3.9,
                cooldown: 0,
                target: null,
                deployTime: 0
            };
            
            scene.add(group);
            defenseTurrets.push(group);
            
            // Spawn Effect
            const ringE = new THREE.Mesh(new THREE.TorusGeometry(3, 0.1, 8, 32), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent:true }));
            ringE.position.copy(pos);
            ringE.rotation.x = Math.PI/2;
            scene.add(ringE);
            let s = 0;
            const int = setInterval(() => { s+=0.05; ringE.scale.setScalar(s); ringE.material.opacity=1-s; if(s>=1){clearInterval(int);scene.remove(ringE);} }, 30);
        }

        function buyNuke() {
            const cost = shopCosts.nuke;
            if (defenseCoins >= cost) {
                defenseCoins -= cost;
                
                // Increase Cost (50% increase - ultimate ability)
                shopCosts.nuke = Math.floor(cost * 1.5);

                SoundManager.playExplosion();
                createRedesignedExplosion(new THREE.Vector3(0, 20, 0), 3.0);
                
                // Kill all non-bosses, damage bosses heavily
                for (let i = defenseEnemies.length - 1; i >= 0; i--) {
                    const e = defenseEnemies[i];
                    if (e.isBoss) {
                        damageEnemy(e, 2000); // Massive damage to boss
                    } else {
                        killEnemy(i, true);
                    }
                }
                statusEl.innerText = "NUKE DETONATED";
                updateDefenseUI();
            } else {
                statusEl.innerText = "INSUFFICIENT FUNDS";
            }
        }

        function spawnDefenseCore() {
            // Static Core Block
            const size = 8;
            // Height is now 1.5x larger (12 units high instead of 8) to cover the lifted crystal
            const shape = new CANNON.Box(new CANNON.Vec3(size/2, size * 0.75, size/2)); 
            const body = new CANNON.Body({ mass: 0 }); // Static
            body.addShape(shape);
            // REVERTED: Core position for grid floor
            body.position.set(0, size * 0.75, 0); // Core sits on grid floor at y=0 
            world.addBody(body);
            defenseCoreBody = body;

            // --- REDESIGNED VISUALS: HYPER-REACTOR MK.V (CRIMSON SPIRE) ---
            const group = new THREE.Group();
            group.position.copy(body.position);
            
            const visualOffset = -size * 0.75;
            const coreHeight = visualOffset + (size * 0.9);

            // 1. Heavy Base (Industrial Dark Metal)
            const baseMat = new THREE.MeshStandardMaterial({ 
                color: 0x0a0a0a, 
                metalness: 0.9, 
                roughness: 0.3 
            });

            const base1Geo = new THREE.BoxGeometry(size * 1.4, size * 0.2, size * 1.4);
            const base1 = new THREE.Mesh(base1Geo, baseMat);
            base1.position.y = visualOffset + (size * 0.1); 
            group.add(base1);

            const base2Geo = new THREE.CylinderGeometry(size * 0.6, size * 0.7, size * 0.3, 8);
            const base2 = new THREE.Mesh(base2Geo, baseMat);
            base2.position.y = visualOffset + (size * 0.35);
            group.add(base2);

            // 2. THE PILLARS (Restored & Heavy)
            // 4 Vertical Pylons at the corners
            const pillarGeo = new THREE.BoxGeometry(size * 0.15, size * 1.2, size * 0.15);
            const pillarMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8 });
            const capGeo = new THREE.BoxGeometry(size * 0.2, size * 0.1, size * 0.2);
            
            for(let i=0; i<4; i++) {
                const angle = (Math.PI / 4) + (i * Math.PI / 2); // Corners: 45, 135, 225, 315
                const dist = size * 0.6;
                
                const pGroup = new THREE.Group();
                pGroup.position.set(Math.cos(angle) * dist, visualOffset + (size * 0.6), Math.sin(angle) * dist);
                
                const p = new THREE.Mesh(pillarGeo, pillarMat);
                pGroup.add(p);
                
                // Add glowing emitter on pillar facing inward
                const emitGeo = new THREE.BoxGeometry(size * 0.05, size * 0.8, size * 0.05);
                const emitMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const emitter = new THREE.Mesh(emitGeo, emitMat);
                emitter.position.set(0, 0, 0);
                emitter.lookAt(new THREE.Vector3(0,0,0).sub(pGroup.position)); // Face center
                emitter.translateZ(size * 0.06); // Move slightly in
                pGroup.add(emitter);

                // Top Cap
                const cap = new THREE.Mesh(capGeo, pillarMat);
                cap.position.y = size * 0.6;
                pGroup.add(cap);

                group.add(pGroup);
            }

            // 3. REDESIGNED CRYSTAL: The Crimson Spire
            // Elongated Octahedron for a sharp, aggressive look
            const crystalGeo = new THREE.OctahedronGeometry(size * 0.35, 0);
            // Stretch vertically
            crystalGeo.scale(1, 2.5, 1); 
            
            const crystalMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0.95, 
                blending: THREE.AdditiveBlending 
            });
            const crystal = new THREE.Mesh(crystalGeo, crystalMat);
            crystal.position.y = coreHeight;
            group.add(crystal);

            // Inner Dark Core (The Singularity)
            const innerGeo = new THREE.OctahedronGeometry(size * 0.15, 0);
            innerGeo.scale(1, 2.0, 1);
            const innerMat = new THREE.MeshBasicMaterial({ color: 0x550000 });
            const innerCore = new THREE.Mesh(innerGeo, innerMat);
            innerCore.position.y = coreHeight;
            group.add(innerCore);

            // Outer Crystal Cage
            const cageGeo = new THREE.IcosahedronGeometry(size * 0.6, 1);
            const cageMat = new THREE.MeshBasicMaterial({ 
                color: 0xff3333, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.3 
            });
            const cage = new THREE.Mesh(cageGeo, cageMat);
            cage.position.y = coreHeight;
            cage.scale.set(1, 1.4, 1); // Slight vertical stretch
            group.add(cage);

            // 4. Energy Rings
            const ringGeo = new THREE.TorusGeometry(size * 0.5, size * 0.03, 6, 40);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.7 });
            
            const ring1 = new THREE.Mesh(ringGeo, ringMat);
            ring1.position.y = coreHeight;
            group.add(ring1);
            
            const ring2 = new THREE.Mesh(ringGeo, ringMat);
            ring2.position.y = coreHeight;
            ring2.rotation.x = Math.PI / 2;
            group.add(ring2);

            // 5. Intense Light
            const light = new THREE.PointLight(0xff0000, 10, 50);
            light.position.y = coreHeight;
            group.add(light);

            // NEW: Core Shield Visual (Hidden initially)
            // UPDATED: Radius increased by 30% (0.9 -> 1.17)
            const shieldGeo = new THREE.SphereGeometry(size * 1.17, 32, 32);
            const shieldMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                wireframe: false // We can add a wireframe child if we want complexity
            });
            const shieldMesh = new THREE.Mesh(shieldGeo, shieldMat);
            shieldMesh.position.y = visualOffset + (size * 0.5);
            shieldMesh.visible = false; // Hidden until bought
            group.add(shieldMesh);

            // Optional: Wireframe overlay for shield
            const shieldWire = new THREE.Mesh(shieldGeo, new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent:true, opacity:0.1 }));
            shieldMesh.add(shieldWire);

            // Animation Data
            group.userData = {
                isCore: true,
                crystal: crystal,
                innerCore: innerCore,
                cage: cage,
                ring1: ring1,
                ring2: ring2,
                light: light,
                shield: shieldMesh // NEW: Reference
            };

            scene.add(group);
            defenseCoreMesh = group; 
        }

        function spawnEnemy(isBoss = false, isSpeedy = false, isSplitter = false) {
            // Only host spawns enemies in multiplayer to keep waves in sync
            if (isMultiplayerEnabled && isDefenseMode && !isHost) return;
            
            // MULTIPLAYER: Use fixed predetermined spawn positions
            let x, z;
            if (isMultiplayerEnabled && isDefenseMode) {
                // Use fixed spawn positions array - same index = same position for all clients
                enemySpawnCounter++;
                const spawnIndex = (enemySpawnCounter - 1) % FIXED_SPAWN_POSITIONS.length;
                const spawnPos = FIXED_SPAWN_POSITIONS[spawnIndex];
                
                // Use the predetermined position
                x = spawnPos.x;
                z = spawnPos.z;
            } else {
                // Single player: use random positions
                const angle = Math.random() * Math.PI * 2;
                let dist = 200 + Math.random() * 110;
                if (isBoss) {
                    dist = 380 + Math.random() * 80;
                } else if (isSpeedy) {
                    dist += 40;
                } else if (isSplitter) {
                    dist += 25;
                }
                x = Math.cos(angle) * dist;
                z = Math.sin(angle) * dist;
            }
            
            // UPDATED: Scaling Logic
            // Standard was 2.5 -> +5% = 2.625
            let baseRadius = 2.625; 
            let mass = 60;
            let coinVal = 9; 
            
            if (isBoss) {
                // UPDATED: 20% larger than previous (7.2 -> 8.64)
                baseRadius = 8.64; 
                mass = 5760;   // 4800 * 1.2 (20% more mass for 20% larger size)
                coinVal = 360; // 600 -> 360
            } else if (isSpeedy) {
                // Speedy was 3.125 -> +10% = ~3.44
                baseRadius = 3.44; 
                mass = 50;      
                coinVal = 15; 
            } else if (isSplitter) {
                // Splitter: 45% larger than regular, plus extra 25% = 81.25% larger total, then +25% more = 126.56% larger total
                baseRadius = 2.625 * 1.8125 * 1.25; // ~5.95 (25% larger)
                mass = 450; // Triple the heaviness (was 150, now 450)
                coinVal = 20; // Slightly more valuable
            }
            
            // NEW: Apply wave scaling to size (4% per wave)
            const waveMultSize = Math.pow(1.04, defenseWave - 1);
            const radius = baseRadius * waveMultSize;
            
            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({ mass: mass }); 
            body.addShape(shape);
            
            // REVERTED: Spawn enemies on grid floor
            body.position.set(x, radius + 2, z); // Spawn on grid floor 
            
            // UPDATED: Physics tuning for Boss Acceleration/Speed balance
            // FIX: Damping must be < 1.0 or it causes NaN errors (disappearing mesh)
            if (isBoss) {
                body.linearDamping = 0.93; // Increased drag to balance massive acceleration
                body.angularDamping = 0.1;
            } else {
                body.linearDamping = isSpeedy ? 0.28 : (isSplitter ? 0.86 : 0.86); 
                body.angularDamping = 0.1;
            }
            
            // SEPARATED: Enemies use collision group 3 (different from boxes which use group 1)
            body.collisionFilterGroup = 3;
            body.collisionFilterMask = -1;

            world.addBody(body);
            
            // NEW: Reduce knockback for splitter enemies by using low restitution contact material
            if (isSplitter) {
                // Create a contact material with very low restitution (bounciness) to reduce knockback
                const splitterMaterial = new CANNON.Material('splitter');
                const defaultMaterial = new CANNON.Material('default');
                const splitterContact = new CANNON.ContactMaterial(splitterMaterial, defaultMaterial, {
                    friction: 0.4,
                    restitution: 0.1 // Very low bounce (10% of normal) = much less knockback
                });
                world.addContactMaterial(splitterContact);
                body.material = splitterMaterial;
            }

            // UPDATED: Visuals Generation
            let mesh;

            if (isBoss) {
                // --- OVERHAULED BOSS: THE OMEGA CONSTRUCT ---
                const group = new THREE.Group();

                // 1. The Event Horizon (Pitch Black Core) - UPDATED: Reduced by 15%
                // Was 1.06 -> 0.9
                const coreGeo = new THREE.SphereGeometry(radius * 0.9, 32, 32);
                const coreMat = new THREE.MeshStandardMaterial({ 
                    color: 0x000000, 
                    metalness: 1.0, 
                    roughness: 0.0,
                    emissive: 0x000000
                });
                const core = new THREE.Mesh(coreGeo, coreMat);
                group.add(core);

                // 2. The Containment Cage (Floating Spikes) - UPDATED: More Spikes
                const spikeGeo = new THREE.ConeGeometry(radius * 0.25, radius * 1.5, 4);
                const spikeMat = new THREE.MeshStandardMaterial({ 
                    color: 0x222222, 
                    metalness: 0.8, 
                    roughness: 0.4 
                });
                const tipGeo = new THREE.ConeGeometry(radius * 0.1, radius * 0.5, 4);
                const tipMat = new THREE.MeshBasicMaterial({ color: 0xff0033 }); // Red glowing tips

                const spikeGroup = new THREE.Group();
                const spikes = [];
                
                // UPDATED: Added 8 corner directions to the 6 cardinal ones
                const dirs = [
                    // Cardinal
                    new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0),
                    new THREE.Vector3(0,1,0), new THREE.Vector3(0,-1,0),
                    new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1),
                    // Corners (Diagonals)
                    new THREE.Vector3(1,1,1).normalize(), new THREE.Vector3(-1,1,1).normalize(),
                    new THREE.Vector3(1,-1,1).normalize(), new THREE.Vector3(-1,-1,1).normalize(),
                    new THREE.Vector3(1,1,-1).normalize(), new THREE.Vector3(-1,1,-1).normalize(),
                    new THREE.Vector3(1,-1,-1).normalize(), new THREE.Vector3(-1,-1,-1).normalize()
                ];

                dirs.forEach(dir => {
                    const sGroup = new THREE.Group();
                    sGroup.lookAt(dir); // Point along direction
                    sGroup.rotateX(Math.PI / 2); // Re-orient cone to point forward

                    // FIX: Clone materials to prevent shared-material flash bug (stuck white)
                    const base = new THREE.Mesh(spikeGeo, spikeMat.clone());
                    base.position.y = 0; // Center
                    sGroup.add(base);

                    const tip = new THREE.Mesh(tipGeo, tipMat.clone());
                    tip.position.y = radius * 0.5; // Offset to tip
                    sGroup.add(tip);
                    
                    // Store initial direction vector for animation
                    // Increased base distance slightly to account for larger core
                    sGroup.userData = { dir: dir, dist: radius * 1.1 }; 
                    
                    spikeGroup.add(sGroup);
                    spikes.push(sGroup);
                });
                group.add(spikeGroup);

                // 3. Jagged Energy Rings
                // Tubular segments = 3 for triangular, sharp look
                // UPDATED: Increased by 10% (Was 1.52 -> 1.67)
                const ringGeo = new THREE.TorusGeometry(radius * 1.67, radius * 0.08, 3, 50);
                const ringMat = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000, 
                    transparent: true, 
                    opacity: 0.8,
                    wireframe: false // Removed wireframe
                });

                const ring1 = new THREE.Mesh(ringGeo, ringMat);
                group.add(ring1);
                
                // FIX: Clone material for second ring
                const ring2 = new THREE.Mesh(ringGeo, ringMat.clone());
                ring2.rotation.y = Math.PI / 2;
                group.add(ring2);

                // REMOVED: Debris Field (Containment Blocks)

                // 5. Inner Glow Aura
                const auraGeo = new THREE.SphereGeometry(radius * 0.9, 16, 16); // Larger aura for larger core
                const auraMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.3, wireframe: true }); // Wireframe restored
                const aura = new THREE.Mesh(auraGeo, auraMat);
                group.add(aura);

                // Store references for animation
                group.userData = { 
                    isBoss: true, 
                    core: core,
                    spikeGroup: spikeGroup,
                    spikes: spikes,
                    ring1: ring1,
                    ring2: ring2,
                    aura: aura,
                    time: 0
                };
                
                mesh = group;

            } else {
                // --- REDESIGNED ENEMIES (ITERATION 3) ---
                
                if (isSplitter) {
                    // --- SPLITTER: COMPLETE REDESIGN - "Void Fragment" ---
                    // A dark, ominous enemy with purple energy that splits into smaller fragments
                    const group = new THREE.Group();

                    // 1. Main Body - Dark crystalline structure
                    const mainGeo = new THREE.OctahedronGeometry(radius, 2);
                    const mainMat = new THREE.MeshStandardMaterial({ 
                        color: 0x1a1a2e, // Very dark blue-black
                        metalness: 0.3, 
                        roughness: 0.7,
                        emissive: 0x4a0e4e,
                        emissiveIntensity: 0.2
                    });
                    const main = new THREE.Mesh(mainGeo, mainMat);
                    group.add(main);
                    
                    // 2. Purple energy core (pulsing)
                    const coreGeo = new THREE.SphereGeometry(radius * 0.6, 24, 24);
                    const coreMat = new THREE.MeshBasicMaterial({ 
                        color: 0x8b00ff, // Bright purple
                        transparent: true,
                        opacity: 0.7,
                        emissive: 0x8b00ff,
                        emissiveIntensity: 0.8
                    });
                    const core = new THREE.Mesh(coreGeo, coreMat);
                    group.add(core);
                    
                    // 3. Energy fragments floating around (indicating it will split)
                    const fragmentGeo = new THREE.TetrahedronGeometry(radius * 0.15, 0);
                    const fragmentMat = new THREE.MeshBasicMaterial({ 
                        color: 0xaa44ff,
                        transparent: true,
                        opacity: 0.9,
                        emissive: 0xaa44ff,
                        emissiveIntensity: 0.5
                    });
                    
                    const fragments = [];
                    for (let i = 0; i < 6; i++) {
                        const fragment = new THREE.Mesh(fragmentGeo, fragmentMat.clone());
                        const angle = (i / 6) * Math.PI * 2;
                        const height = (Math.random() - 0.5) * radius * 0.8;
                        fragment.position.set(
                            Math.cos(angle) * radius * 1.1,
                            height,
                            Math.sin(angle) * radius * 1.1
                        );
                        group.add(fragment);
                        fragments.push(fragment);
                    }
                    
                    // 4. Energy tendrils connecting fragments to core
                    const tendrilGeo = new THREE.CylinderGeometry(radius * 0.03, radius * 0.03, radius * 0.5, 8);
                    const tendrilMat = new THREE.MeshBasicMaterial({ 
                        color: 0x8b00ff,
                        transparent: true,
                        opacity: 0.5
                    });
                    
                    const tendrils = [];
                    fragments.forEach((frag, i) => {
                        const tendril = new THREE.Mesh(tendrilGeo, tendrilMat.clone());
                        const midPoint = frag.position.clone().multiplyScalar(0.5);
                        tendril.position.copy(midPoint);
                        tendril.lookAt(frag.position);
                        tendril.scale.y = frag.position.length() / (radius * 0.5);
                        group.add(tendril);
                        tendrils.push(tendril);
                    });
                    
                    // 5. Dark energy aura
                    const auraGeo = new THREE.SphereGeometry(radius * 1.15, 16, 16);
                    const auraMat = new THREE.MeshBasicMaterial({ 
                        color: 0x2a0a3a,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.BackSide
                    });
                    const aura = new THREE.Mesh(auraGeo, auraMat);
                    group.add(aura);
                    
                    // 6. Point light for purple glow
                    const pointLight = new THREE.PointLight(0x8b00ff, 1.5, radius * 4);
                    pointLight.position.set(0, 0, 0);
                    group.add(pointLight);
                    
                    // Store for animation
                    group.userData = {
                        isSplitterAnim: true,
                        core: core,
                        fragments: fragments,
                        tendrils: tendrils,
                        aura: aura,
                        pointLight: pointLight
                    };

                    mesh = group;
                } else if (isSpeedy) {
                    // --- SPEEDY: "ARC RUNNER" ---
                    // A high-velocity gyroscopic drone.
                    const group = new THREE.Group();
                    
                    // 1. The Core (Pure Energy)
                    const coreGeo = new THREE.SphereGeometry(radius * 0.6, 16, 16);
                    const coreMat = new THREE.MeshBasicMaterial({ color: 0x00ffff }); // Cyan
                    const core = new THREE.Mesh(coreGeo, coreMat);
                    group.add(core);

                    // 2. Gyro Rings (Spinning)
                    const ringGeo = new THREE.TorusGeometry(radius * 0.9, radius * 0.08, 4, 24);
                    const ringMat = new THREE.MeshBasicMaterial({ color: 0x0088ff });
                    
                    const r1 = new THREE.Mesh(ringGeo, ringMat);
                    group.add(r1);
                    
                    const r2 = new THREE.Mesh(ringGeo, ringMat);
                    r2.rotation.x = Math.PI / 2;
                    group.add(r2);
                    
                    const r3 = new THREE.Mesh(ringGeo, ringMat);
                    r3.rotation.y = Math.PI / 2;
                    group.add(r3);

                    // 3. Trailing Antennae (Visual speed indicator)
                    const spikeGeo = new THREE.ConeGeometry(radius * 0.05, radius * 2.2, 6);
                    const spikeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    
                    const s1 = new THREE.Mesh(spikeGeo, spikeMat);
                    s1.rotation.x = Math.PI / 2; // Point forward/back
                    group.add(s1);

                    // UPDATED: Wireframe Shell Smaller (Was 1.3 -> 1.1)
                    const shellGeo = new THREE.IcosahedronGeometry(radius * 1.1, 0);
                    const shellMat = new THREE.MeshBasicMaterial({ 
                        color: 0x0044aa, 
                        wireframe: true, 
                        transparent: true, 
                        opacity: 0.3 
                    });
                    const shell = new THREE.Mesh(shellGeo, shellMat);
                    group.add(shell);

                    // UPDATED: MORE DETAIL - Stabilizer Fins
                    const finGeo = new THREE.BoxGeometry(radius * 0.1, radius * 0.5, radius * 0.8);
                    const finMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                    const fin1 = new THREE.Mesh(finGeo, finMat);
                    fin1.position.y = radius * 0.8;
                    group.add(fin1);
                    const fin2 = new THREE.Mesh(finGeo, finMat);
                    fin2.position.y = -radius * 0.8;
                    group.add(fin2);

                    // Store for animation
                    group.userData = { 
                        isSpeedyAnim: true, 
                        r1: r1, 
                        r2: r2, 
                        r3: r3,
                        shell: shell // Added shell to user data
                    };
                    
                    mesh = group;

                } else {
                    // --- REGULAR: "OBSIDIAN BREAKER" ---
                    // A jagged, heavy, crystal-infused rolling boulder.
                    const group = new THREE.Group();

                    // 1. Main Body (Dark jagged rock)
                    const rockGeo = new THREE.DodecahedronGeometry(radius, 1);
                    // Perturb vertices slightly for roughness (simple scaling variation)
                    // UPDATED: Color changed to Dark Brownish-Grey (0x3a2e2e) to differ from Mass Cannon (Blue-Grey)
                    // Also reduced metalness to look more like stone
                    const rockMat = new THREE.MeshStandardMaterial({ 
                        color: 0x3a2e2e, 
                        metalness: 0.1, 
                        roughness: 0.9,
                        flatShading: true
                    });
                    const rock = new THREE.Mesh(rockGeo, rockMat);
                    group.add(rock);

                    // 2. Protruding Energy Crystals (The danger parts)
                    // UPDATED: Spikes 8% wider (0.25 -> 0.27) and 5% longer (0.8 -> 0.84)
                    const crystalGeo = new THREE.ConeGeometry(radius * 0.27, radius * 0.84, 4);
                    const crystalMat = new THREE.MeshBasicMaterial({ color: 0xff00ff }); // Magenta Glow
                    
                    // Add crystals facing outwards
                    const dirs = [
                        new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0),
                        new THREE.Vector3(0,1,0), new THREE.Vector3(0,-1,0),
                        new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)
                    ];
                    
                    dirs.forEach(dir => {
                        const c = new THREE.Mesh(crystalGeo, crystalMat);
                        c.position.copy(dir).multiplyScalar(radius * 0.8);
                        c.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
                        group.add(c);
                    });

                    // Wireframe removed

                    mesh = group;
                }
            }

            mesh.castShadow = true;
            scene.add(mesh);

            // NEW: 4% increase per wave for HP, size, and speed
            let waveMult = Math.pow(1.04, defenseWave - 1); 
            
            // FIXED: New HP values (reduced by 15% from previous values)
            // Regular: 60, Speedy: 15, Splitter: 125, Boss: 300
            let hp = isSpeedy ? 15 : (isSplitter ? 125 : 60);
            if (isBoss) hp = 300;
            
            hp *= waveMult; 

            const enemyObj = {
                body: body,
                mesh: mesh,
                hp: hp,
                maxHp: hp,
                isBoss: isBoss,
                isSpeedy: isSpeedy, 
                isSplitter: isSplitter, 
                coinValue: coinVal, // Store coin value
                lastHitTime: 0, 
                jumpCooldown: 0,
                // NEW: AI Variables
                aiOffset: Math.random() * Math.PI * 2, // For flanking
                aiRayTimer: Math.random() * 10, // Stagger raycasts
                avoidanceDir: new THREE.Vector3(),
                // NEW: Backup Logic State
                backupTimer: 0,
                backupSideDir: new THREE.Vector3(),
                // NEW: Feint Logic (Speedy only)
                feintState: 0, // 0: Approach, 1: Feinting, 2: Attacking
                feintTimer: 0,
                feintDir: new THREE.Vector3(),
                // NEW: Boss jump and shockwave variables
                bossJumpTimer: 0,
                bossIsJumping: false,
                bossJumpHeight: 0
            };
            
            enemyObj.stuckTime = 0;
            enemyObj.avoidState = 0; 
            enemyObj.avoidTimer = 0;
            enemyObj.avoidDir = new CANNON.Vec3();

            defenseEnemies.push(enemyObj);
            
            // MULTIPLAYER: Notify server of enemy spawn (only host spawns)
            if (socket && socket.connected && isHost) {
                const enemyId = `enemy-${Date.now()}-${Math.random()}`;
                enemyObj.networkId = enemyId;
                socket.emit('enemySpawned', {
                    id: enemyId,
                    position: {
                        x: body.position.x,
                        y: body.position.y,
                        z: body.position.z
                    },
                    velocity: {
                        x: body.velocity.x,
                        y: body.velocity.y,
                        z: body.velocity.z
                    },
                    isBoss: isBoss,
                    isSpeedy: isSpeedy,
                    isSplitter: isSplitter,
                    hp: hp,
                    maxHp: hp,
                    radius: radius,
                    mass: mass,
                    coinValue: coinVal,
                    spawnIndex: enemySpawnCounter // Include spawn index for deterministic positioning
                });
            }
            
            body.addEventListener('collide', (e) => {
                // FIXED: Removed physics-based velocity damage
                // Only keeping collision tracking for other purposes
                const now = Date.now();
                if (now - enemyObj.lastHitTime < 100) return;

                const otherBody = (e.contact.bi === body) ? e.contact.bj : e.contact.bi;
                
                if(otherBody.userData && otherBody.userData.isGround) return;

                // Update last hit time but don't apply damage
                     enemyObj.lastHitTime = now;
            });

            // Beacon
            const beaconGeo = new THREE.CylinderGeometry(0.5, 0.5, 200, 8); 
            let beaconColor = isBoss ? 0xffaa00 : 0xff0000;
            if (isSpeedy) beaconColor = 0x0088ff;

            const beaconMat = new THREE.MeshBasicMaterial({ 
                color: beaconColor,
                transparent: true, 
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const beacon = new THREE.Mesh(beaconGeo, beaconMat);
            beacon.position.set(x, 100, z);
            scene.add(beacon);
            
            let op = 1.0;
            const fadeInterval = setInterval(() => {
                op -= 0.05;
                if(beacon.material) beacon.material.opacity = op * 0.8;
                if(op <= 0) {
                    clearInterval(fadeInterval);
                    scene.remove(beacon);
                }
            }, 100);

            if(isBoss) {
                statusEl.innerText = "BOSS SPAWNED!";
                SoundManager.playCharge(0.8);
                setTimeout(() => { 
                    if(waveInProgress) statusEl.innerText = "WAVE " + defenseWave; 
                }, 3000);
            }

            updateDefenseUI();
        }

        // UPDATED: Fixed visual feedback and proper death handling
        function damageEnemy(enemy, amount) {
            if (!enemy) return;
            enemy.hp -= amount;
            if (enemy.hp < 0) enemy.hp = 0;
            
            // MULTIPLAYER: Notify server of enemy hit
            if (socket && socket.connected) {
                const enemyIndex = defenseEnemies.indexOf(enemy);
                if (enemyIndex >= 0) {
                socket.emit('enemyHit', {
                    enemyIndex: enemyIndex,
                    damage: amount
                });
                }
            }
            
            // Flash hit
            const flashWhite = (obj) => {
                if (obj.isMesh && obj.material) {
                    if (!obj.userData.isFlashing) {
                        obj.userData.originalHex = obj.material.color.getHex();
                        obj.userData.isFlashing = true;
                        obj.material.color.setHex(0xffffff);
                        setTimeout(() => {
                            if (obj.material && obj.userData.originalHex !== undefined) {
                                obj.material.color.setHex(obj.userData.originalHex);
                            }
                            obj.userData.isFlashing = false;
                            obj.userData.originalHex = undefined;
                        }, 100);
                    }
                }
                if (obj.children && obj.children.length > 0) {
                    obj.children.forEach(child => flashWhite(child));
                }
            };
            if (enemy.mesh) flashWhite(enemy.mesh);
            
            // Death check
            if (enemy.hp <= 0) {
                const idx = defenseEnemies.indexOf(enemy);
                if (idx > -1) {
                    killEnemy(idx);
                }
            }
            
            updateDefenseUI();
        }

        function updateDefenseGame(dt) {
            if (!defenseCoreBody) return;
            
            // Don't slow down forces - physics step already handles time scaling
            // Forces should be applied at full strength, physics step will slow them down


            // REMOVED: Gravity Dome Update Logic

            // NEW: Animate Defense Core & Shield
            if (defenseCoreMesh && defenseCoreMesh.userData.isCore) {
                const ud = defenseCoreMesh.userData;
                const now = Date.now() * 0.001;
                
                // Spin Crystal
                ud.crystal.rotation.y += dt * 0.5;
                ud.innerCore.rotation.y -= dt * 1.0;
                ud.cage.rotation.x += dt * 0.2;
                ud.cage.rotation.z += dt * 0.2;
                
                // Shield Logic
                if (coreShieldMax > 0 && ud.shield) {
                    ud.shield.visible = true; // Ensure visible if we have shield capacity
                    
                    // Regenerate if no damage for 5 seconds
                    if (Date.now() - lastShieldHitTime > 5000 && coreShieldCurrent < coreShieldMax) {
                        // FIXED: Base regen: 7.5% per second, +2.75% per regen level (increased by 10%)
                        const baseRegenRate = 0.075;
                        const regenBonus = coreShieldRegenLevel * 0.0275; // 2.5% * 1.1 = 2.75%
                        const totalRegenRate = baseRegenRate + regenBonus;
                        coreShieldCurrent += coreShieldMax * totalRegenRate * dt;
                        if (coreShieldCurrent > coreShieldMax) coreShieldCurrent = coreShieldMax;
                        // Update UI periodically during regen
                        if(Math.random() < 0.1) updateDefenseUI();
                    }

                    // Visuals: Pulse and Opacity based on health
                    const shieldPct = coreShieldCurrent / coreShieldMax;
                    
                    if (shieldPct <= 0.01) {
                        ud.shield.visible = false; // Break shield visual
                    } else {
                        ud.shield.visible = true;
                        // Opacity fades as shield gets weaker
                        const baseOp = 0.1 + (0.2 * shieldPct);
                        // Add pulse
                        const pulse = Math.sin(now * 3) * 0.05;
                        ud.shield.material.opacity = baseOp + pulse;
                        ud.shield.rotation.y += dt * 0.2;
                    }
                }
                
                // Pulse Light & Scale
                const pulse = 1 + Math.sin(now * 2) * 0.05;
                ud.crystal.scale.set(pulse, 2.5 * pulse, pulse); // Maintain aspect ratio
                ud.light.intensity = 8 + Math.sin(now * 6) * 4;
                
                // Gyro Rings
                ud.ring1.rotation.x = Math.sin(now * 0.5) * 0.5;
                ud.ring1.rotation.y += dt * 2.0;
                
                ud.ring2.rotation.y = Math.cos(now * 0.5) * 0.5;
                ud.ring2.rotation.x += dt * 2.0;
            }

            // NEW: Animate Barriers (Mk. IV Fortress Animation + Lifetime)
            const time = Date.now() * 0.001;
            
            // UPDATED: Iterate backwards to allow removal
            for (let i = defenseBarriers.length - 1; i >= 0; i--) {
                const b = defenseBarriers[i];
                const ud = b.mesh.userData;
                
                // 1. Lifetime Logic
                if (ud.life !== undefined) {
                    ud.life -= dt;
                    
                    // Fade out in last 1 second
                    if (ud.life < 1.0) {
                        const opacity = Math.max(0, ud.life);
                        b.mesh.traverse(child => {
                            if (child.isMesh && child.material) {
                                child.material.transparent = true;
                                // Simple fade hack: reduce opacity if it's currently higher
                                if (child.material.opacity > opacity) {
                                    child.material.opacity = opacity;
                                }
                            }
                        });
                    }

                    // Remove when expired
                    if (ud.life <= 0) {
                        world.removeBody(b.body);
                        scene.remove(b.mesh);
                        
                        const idx = collidables.indexOf(b.mesh);
                        if(idx > -1) collidables.splice(idx, 1);
                        
                        defenseBarriers.splice(i, 1);
                        continue; // Skip animation
                    }
                }
                
                // 2. Scanline Animation
                if (ud.scanline && ud.fieldH) {
                    ud.scanY += dt * 3.0;
                    const yOffset = Math.sin(ud.scanY) * (ud.fieldH / 2 - 0.5);
                    ud.scanline.position.y = 0.5 + yOffset; 
                }
            }

            // Update Turrets (NEW LOGIC)
            const now = Date.now();
            defenseTurrets.forEach(t => {
                const ud = t.userData;

                // Deploy Animation
                if (ud.deployTime < 1) {
                    ud.deployTime += dt * 3;
                    const ease = ud.deployTime;
                    t.position.y = ud.baseY - 4 + (ease * 4); // Adjusted for larger size
                    if (t.position.y > ud.baseY) t.position.y = ud.baseY;
                }
                
                // Animate Sensor
                if(ud.activeSensor) {
                    ud.activeSensor.rotation.y += dt * 3;
                    // Pulse sensor glow
                    const pulse = 0.8 + Math.sin(Date.now() * 0.005) * 0.2;
                    ud.activeSensor.material.opacity = pulse;
                }

                // Cooldown Tick
                if (ud.cooldown > 0) ud.cooldown -= dt;
                
                // Find Target
                let closest = null;
                // UPDATED: Dynamic Range based on Level
                // Base 91, +20% per level
                let currentRange = 91 * (1 + (turretRangeLevel - 1) * 0.2);
                let closestDist = currentRange; 
                
                if (defenseEnemies.length > 0) {
                    defenseEnemies.forEach(e => {
                        const d = t.position.distanceTo(e.mesh.position);
                        if (d < closestDist) {
                            closestDist = d;
                            closest = e;
                        }
                    });
                }
                
                if (closest) {
                    // --- AIMING LOGIC ---
                    const dx = closest.mesh.position.x - t.position.x;
                    const dz = closest.mesh.position.z - t.position.z;
                    const targetAngleY = Math.atan2(dx, dz);
                    
                    let diffY = targetAngleY - ud.head.rotation.y;
                    while (diffY > Math.PI) diffY -= Math.PI * 2;
                    while (diffY < -Math.PI) diffY += Math.PI * 2;
                    ud.head.rotation.y += diffY * dt * 8; 

                    // UPDATED: Dynamic Mounting Height (Defaults to 5.5 for new, 4.0 fallback)
                    const mountH = ud.mountHeight || 4.0;
                    const dy = closest.mesh.position.y - (t.position.y + mountH); 
                    
                    const distH = Math.sqrt(dx*dx + dz*dz);
                    const targetAngleX = Math.atan2(dy, distH);
                    const clampedX = Math.max(-0.6, Math.min(0.6, -targetAngleX));
                    ud.gun.rotation.x += (clampedX - ud.gun.rotation.x) * dt * 8;

                    // --- SHOOTING LOGIC ---
                    if (ud.cooldown <= 0) {
                        // UPDATED: Fire Rate based on Level
                        // Base 0.47, -15% delay per level (0.85 multiplier)
                        ud.cooldown = 0.47 * Math.pow(0.85, turretFireRateLevel - 1); 
                        
                        const barrelIdx = Math.floor(now / 350) % 2; 
                        const activeBarrel = ud.barrels[barrelIdx];
                        
                        // Heavier Visual Recoil
                        activeBarrel.position.z = 1.4; 
                        setTimeout(() => activeBarrel.position.z = 1.8, 150); 

                        // Calculate Muzzle Position
                        const muzzlePos = new THREE.Vector3();
                        activeBarrel.getWorldPosition(muzzlePos);
                        
                        // UPDATED: Fixed Off-Center Issue
                        // 1. Use (0,1,0) because cylinder length is along Y-axis
                        // 2. Increased scalar to 1.8 to reach the actual tip
                        const fwd = new THREE.Vector3(0,1,0).applyQuaternion(activeBarrel.getWorldQuaternion(new THREE.Quaternion()));
                        muzzlePos.add(fwd.multiplyScalar(1.8));

                        // Thicker Laser Beam
                        const points = [muzzlePos, closest.mesh.position.clone()];
                        const geo = new THREE.BufferGeometry().setFromPoints(points);
                        // Using thicker line via multiple offsets or just color intensity for now (ThreeJS Lines are thin by default)
                        const mat = new THREE.LineBasicMaterial({ color: 0xffaa00, linewidth: 2 }); 
                        const line = new THREE.Line(geo, mat);
                        scene.add(line);
                        setTimeout(() => scene.remove(line), 80); // Beam stays longer
                        
                        // Larger Muzzle Flash
                        const flashGeo = new THREE.SphereGeometry(0.5, 8, 8);
                        const flashMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                        const flash = new THREE.Mesh(flashGeo, flashMat);
                        flash.position.copy(muzzlePos);
                        scene.add(flash);
                        setTimeout(() => scene.remove(flash), 80);

                        // Damage (Heavier hit for slower speed)
                        // Old DPS: 18 dmg / 0.12s = 150 DPS
                        // New DPS target: Similar or slightly higher for upgrade feel?
                        // Let's make it hit hard: 55 dmg / 0.35s = ~157 DPS
                        damageEnemy(closest, 55); 
                        SoundManager.playShoot('heavy'); // Heavy sound suits it
                    }
                } else {
                    ud.head.rotation.y += Math.sin(now * 0.001) * dt * 0.5;
                    ud.gun.rotation.x = Math.sin(now * 0.002) * 0.2;
                }
            });

            // Apply shop slowdown to spawn intervals (intervals become longer in real time)
            const spawnIntervalMultiplier = isShopOpen ? (1.0 / SHOP_SLOWDOWN) : 1.0;
            
            if (enemiesToSpawn > 0 && now > nextSpawnTime) {
                // UPDATED: Spawn 2 enemies every 6 seconds
                for(let k=0; k<2; k++) {
                    if (enemiesToSpawn > 0) {
                        // FIXED: Boss spawns as the last regular enemy of each wave
                        const isLastEnemy = (enemiesToSpawn === 1 && speedyEnemiesToSpawn === 0 && splitterEnemiesToSpawn === 0); 
                        const isBoss = isLastEnemy; // Boss is always the last enemy
                        
                        // NEW: 8% chance for splitter on wave 2+ (but not if it's the boss)
                        let isSplitter = false;
                        if (!isBoss && defenseWave >= 2 && Math.random() < 0.08) {
                            isSplitter = true;
                        }
                        
                        spawnEnemy(isBoss, false, isSplitter);
                        enemiesToSpawn--;
                    }
                }
                
                nextSpawnTime = now + (6000 * spawnIntervalMultiplier); // 6 seconds interval (slowed when shop open)
                
                updateDefenseUI();
            }
            
            // NEW: Splitter Enemy Logic (spawn every 3 waves, starting at wave 3)
            if (waveInProgress && splitterEnemiesToSpawn > 0) {
                // Spawn when we're 60% through the wave
                if (enemiesToSpawn <= (totalEnemiesForWave * 0.4)) {
                    if (now > nextSplitterSpawnTime) {
                        spawnEnemy(false, false, true);
                        splitterEnemiesToSpawn--;
                        nextSplitterSpawnTime = now + (8000 * spawnIntervalMultiplier); // 8 seconds between splitters (slowed when shop open)
                        updateDefenseUI();
                    }
                }
            }

            // UPDATED: Speedy Enemy Logic
            // 1. Only spawn if we are halfway through the wave (enemiesToSpawn <= 50% of total)
            // 2. Interval is now 4 seconds (4000ms)
            if (waveInProgress && speedyEnemiesToSpawn > 0) {
                 // Check if we are past 75% of the wave (spawn later instead of halfway)
                 if (enemiesToSpawn <= (totalEnemiesForWave / 4)) {
                     
                     // NEW: Trigger Alert Logic
                     if (!speedyAlertShown) {
                         speedyAlertShown = true;
                         const alertEl = document.getElementById('speedy-alert');
                         alertEl.style.display = 'block';
                         // SoundManager.playCharge(0.9); // Optional: Warning sound
                         setTimeout(() => {
                             alertEl.style.display = 'none';
                         }, 1500); // UPDATED: Show for 1.5 seconds (was 2000)
                     }

                     if (now > nextSpeedySpawnTime) {
                        spawnEnemy(false, true, false); 
                        speedyEnemiesToSpawn--;
                        
                        // FIXED: Spawn interval is 4.6 seconds (slowed when shop open)
                        nextSpeedySpawnTime = now + (4600 * spawnIntervalMultiplier); 
                        
                        updateDefenseUI();
                     }
                 }
            }

            // Enemy Logic
            const corePos = defenseCoreBody.position;
            const enemyRaycaster = new THREE.Raycaster(); // NEW: Dedicated AI Raycaster
            const enemyDownRay = new THREE.Vector3(0, -1, 0);

            for (let i = defenseEnemies.length - 1; i >= 0; i--) {
                const e = defenseEnemies[i];
                
                e.mesh.position.copy(e.body.position);
                
                // REVERTED: Simple Physics Rotation for all enemies
                e.mesh.quaternion.copy(e.body.quaternion);

                // NEW: Animate Speedy Gyros
                if (e.isSpeedy && e.mesh.userData.isSpeedyAnim) {
                    const ud = e.mesh.userData;
                    ud.r1.rotation.x += dt * 5;
                    ud.r2.rotation.y += dt * 5;
                    ud.r3.rotation.z += dt * 5;
                    
                    // NEW: Animate outer shell
                    if (ud.shell) {
                        ud.shell.rotation.y -= dt * 2;
                        ud.shell.rotation.z += dt * 1;
                    }
                }

                // UPDATED: Boss Animation Logic
                if (e.isBoss && e.mesh.userData.isBoss) {
                    const ud = e.mesh.userData;
                    ud.time += dt;

                    // 1. Core Pulse
                    const pulse = 1 + Math.sin(ud.time * 2) * 0.05;
                    if(ud.core) ud.core.scale.setScalar(pulse);
                    if(ud.aura) {
                        ud.aura.rotation.y -= dt;
                        ud.aura.scale.setScalar(pulse * 1.1);
                    }

                    // 2. Animate Spikes (Breathing / Pumping)
                    if(ud.spikes) {
                        const breathe = Math.sin(ud.time * 3); // -1 to 1
                        const offset = breathe * 0.5; // distance variance
                        
                        ud.spikes.forEach(s => {
                            const d = s.userData.dist + offset;
                            const dir = s.userData.dir;
                            s.position.set(dir.x * d, dir.y * d, dir.z * d);
                        });
                        
                        // Rotate the whole spike group slowly
                        ud.spikeGroup.rotation.x += dt * 0.1;
                        ud.spikeGroup.rotation.z += dt * 0.1;
                    }

                    // 3. Spin Rings (Gyroscopic)
                    if(ud.ring1) { 
                        ud.ring1.rotation.x += dt * 1.5; 
                        ud.ring1.rotation.y += dt * 0.5; 
                    }
                    if(ud.ring2) { 
                        ud.ring2.rotation.y += dt * 1.5; 
                        ud.ring2.rotation.z += dt * 0.5; 
                    }

                    // REMOVED: Debris Animation Logic
                }

                // NEW: Splitter Animation Logic (Updated for new design)
                if (e.isSplitter && e.mesh.userData.isSplitterAnim) {
                    const ud = e.mesh.userData;
                    const time = Date.now() * 0.001;
                    const radius = e.body.shapes[0]?.boundingSphereRadius || 4.76;
                    
                    // Animate core pulse
                    if (ud.core) {
                        const pulse = 1 + Math.sin(time * 3) * 0.2;
                        ud.core.scale.setScalar(pulse);
                        ud.core.material.opacity = 0.7 + Math.sin(time * 2) * 0.2;
                    }
                    
                    // Animate fragments orbiting around
                    if (ud.fragments) {
                        ud.fragments.forEach((frag, i) => {
                            const angle = time * 1.5 + (i / ud.fragments.length) * Math.PI * 2;
                            const height = Math.sin(time * 2 + i) * radius * 0.4;
                            frag.position.set(
                                Math.cos(angle) * radius * 1.1,
                                height,
                                Math.sin(angle) * radius * 1.1
                            );
                            frag.rotation.x += dt * 2;
                            frag.rotation.y += dt * 1.5;
                        });
                    }
                    
                    // Animate tendrils to follow fragments
                    if (ud.tendrils && ud.fragments) {
                        ud.tendrils.forEach((tendril, i) => {
                            const frag = ud.fragments[i];
                            if (frag) {
                                const midPoint = frag.position.clone().multiplyScalar(0.5);
                                tendril.position.copy(midPoint);
                                tendril.lookAt(frag.position);
                                tendril.scale.y = frag.position.length() / (radius * 0.5);
                            }
                        });
                    }
                    
                    // Animate aura pulse
                    if (ud.aura) {
                        const pulse = 1 + Math.sin(time * 2) * 0.1;
                        ud.aura.scale.setScalar(pulse);
                    }
                    
                    // Animate point light
                    if (ud.pointLight) {
                        ud.pointLight.intensity = 1.5 + Math.sin(time * 3) * 0.3;
                    }
                }
                
                // OLD: Splitter Animation Logic (kept for reference, but replaced above)
                if (false && e.isSplitter && e.mesh.userData.isSplitterAnim) {
                    const ud = e.mesh.userData;
                    const time = Date.now() * 0.001;
                    
                    // Rotate energy rings (all 3 rings)
                    if (ud.ring1) {
                        ud.ring1.rotation.y += dt * 1.5;
                        ud.ring1.rotation.z += dt * 0.5;
                    }
                    if (ud.ring2) {
                        ud.ring2.rotation.x += dt * 1.5;
                        ud.ring2.rotation.y += dt * 0.5;
                    }
                    if (ud.ring3) {
                        ud.ring3.rotation.x += dt * 0.8;
                        ud.ring3.rotation.y += dt * 1.2;
                        ud.ring3.rotation.z += dt * 0.6;
                    }
                    
                    // Pulse inner glow
                    if (e.mesh.children) {
                        const glow = e.mesh.children.find(c => c.material && c.material.color && c.material.color.getHex() === 0xff88cc);
                        if (glow) {
                            const pulse = 1 + Math.sin(time * 3) * 0.1;
                            glow.scale.setScalar(pulse);
                            glow.material.opacity = 0.35 + Math.sin(time * 4) * 0.1;
                        }
                    }
                    
                    // Animate floating particles
                    e.mesh.children.forEach(child => {
                        if (child.geometry && child.geometry.type === 'SphereGeometry' && 
                            child.material && child.material.color && child.material.color.getHex() === 0xffaadd) {
                            const orbitAngle = time * 2 + child.position.x * 0.5;
                            const radius = e.body.shapes[0]?.boundingSphereRadius || 4.76;
                            child.position.x = Math.cos(orbitAngle) * radius * 1.15;
                            child.position.z = Math.sin(orbitAngle) * radius * 1.15;
                            child.position.y += Math.sin(time * 3 + child.position.x) * dt * 0.5;
                        }
                    });
                }

                // NEW: Split Enemy Animation Logic (Updated for new design)
                if (e.coinValue === 5 && e.mesh.userData.isSplitAnim) {
                    const ud = e.mesh.userData;
                    const time = Date.now() * 0.001;
                    const radius = ud.radius || 2.3;
                    
                    // Animate core pulse
                    if (ud.core) {
                        const pulse = 1 + Math.sin(time * 4) * 0.15;
                        ud.core.scale.setScalar(pulse);
                        ud.core.material.opacity = 0.8 + Math.sin(time * 3) * 0.15;
                    }
                    
                    // Animate trail fragments following behind
                    if (ud.trailFragments) {
                        ud.trailFragments.forEach((frag, i) => {
                            frag.position.set(
                                (Math.random() - 0.5) * radius * 0.8,
                                -radius * 0.6 - i * radius * 0.3 + Math.sin(time * 2 + i) * 0.2,
                                (Math.random() - 0.5) * radius * 0.8
                            );
                            frag.rotation.x += dt * 3;
                            frag.rotation.y += dt * 2;
                        });
                    }
                    
                    // Animate orbiting particles
                    if (ud.particles && ud.particles.length > 0) {
                        ud.particles.forEach((particle, i) => {
                            const angle = time * 3 + (i * Math.PI * 2 / ud.particles.length);
                            particle.position.set(
                                Math.cos(angle) * radius * 1.1,
                                (Math.random() - 0.5) * radius * 0.4 + Math.sin(time * 2 + i) * 0.2,
                                Math.sin(angle) * radius * 1.1
                            );
                            // Pulse particles
                            const pulse = 0.8 + Math.sin(time * 5 + i) * 0.2;
                            particle.scale.setScalar(pulse);
                        });
                    }
                    
                    // Pulse inner glow
                    if (e.mesh.children) {
                        const glow = e.mesh.children.find(c => c.material && c.material.color && c.material.color.getHex() === 0xffaadd);
                        if (glow) {
                            const pulse = 1 + Math.sin(time * 4) * 0.15;
                            glow.scale.setScalar(pulse);
                        }
                    }
                }

                // NEW: Intelligent Targeting
                let targetX = corePos.x;
                let targetZ = corePos.z;

                // Speedy enemies flank/orbit the core instead of rushing straight in
                if (e.isSpeedy) {
                    const distToCore = e.body.position.distanceTo(corePos);

                    if (e.feintState === 0) {
                        // State 0: Approach (Orbit Removed - Run straight at core)
                        targetX = corePos.x;
                        targetZ = corePos.z;

                        // Trigger Feint (The "Turn Away" move)
                        // FIXED: Trigger at 70 units (10 more units away) for earlier dodge
                        if (distToCore < 70 && distToCore > 20) {
                            e.feintState = 1;
                            e.feintTimer = 0.5 + Math.random() * 0.3; // 0.5s - 0.8s duration
                            
                            // NEW: Increase Linear Damping by 35% upon feint trigger
                            // Base is 0.28, so new value is ~0.378
                            e.body.linearDamping *= 1.35;

                            // Calculate direction sideways/away
                            const toCore = new THREE.Vector3(corePos.x - e.body.position.x, 0, corePos.z - e.body.position.z).normalize();
                            const side = new THREE.Vector3(-toCore.z, 0, toCore.x);
                            if (Math.random() > 0.5) side.negate(); // Random left or right
                            
                            // Combine side movement with slight backward movement
                            e.feintDir.copy(side).multiplyScalar(0.8).add(toCore.clone().negate().multiplyScalar(0.2)).normalize();
                        }
                    } 
                    else if (e.feintState === 1) {
                        // State 1: Feinting
                        e.feintTimer -= dt;
                        
                        // Target a point away from core based on feintDir
                        targetX = e.body.position.x + e.feintDir.x * 20;
                        targetZ = e.body.position.z + e.feintDir.z * 20;
                        
                        if (e.feintTimer <= 0) {
                            e.feintState = 2; // Commit to attack
                        }
                    } 
                    else {
                        // State 2: Committed Attack
                        targetX = corePos.x;
                        targetZ = corePos.z;
                        
                        // Reset to orbit if knocked way back
                        if (distToCore > 70) e.feintState = 0;
                    }
                }

                const dx = targetX - e.body.position.x;
                const dz = targetZ - e.body.position.z;
                const distToTarget = Math.sqrt(dx*dx + dz*dz);
                
                // FIXED: Accurate core hitbox check - check if enemy sphere touches core box or base
                const coreSize = 8;
                const coreHalfExtents = { x: coreSize / 2, y: coreSize * 0.75, z: coreSize / 2 };
                const coreBoxMin = {
                    x: corePos.x - coreHalfExtents.x,
                    y: corePos.y - coreHalfExtents.y,
                    z: corePos.z - coreHalfExtents.z
                };
                const coreBoxMax = {
                    x: corePos.x + coreHalfExtents.x,
                    y: corePos.y + coreHalfExtents.y,
                    z: corePos.z + coreHalfExtents.z
                };
                
                // Get enemy position and radius (accounting for wave scaling)
                const enemyPos = e.body.position;
                const waveMultSize = Math.pow(1.04, defenseWave - 1);
                let enemyRadius;
                if (e.isBoss) {
                    enemyRadius = 8.64 * waveMultSize;
                } else if (e.isSpeedy) {
                    enemyRadius = 3.44 * waveMultSize;
                } else if (e.isSplitter) {
                    enemyRadius = (2.625 * 1.8125 * 1.25) * waveMultSize;
                } else {
                    enemyRadius = 2.625 * waveMultSize;
                }
                
                // Check if enemy sphere intersects with core box
                const closestPoint = {
                    x: Math.max(coreBoxMin.x, Math.min(enemyPos.x, coreBoxMax.x)),
                    y: Math.max(coreBoxMin.y, Math.min(enemyPos.y, coreBoxMax.y)),
                    z: Math.max(coreBoxMin.z, Math.min(enemyPos.z, coreBoxMax.z))
                };
                const distToBox = Math.sqrt(
                    (enemyPos.x - closestPoint.x) ** 2 +
                    (enemyPos.y - closestPoint.y) ** 2 +
                    (enemyPos.z - closestPoint.z) ** 2
                );
                const touchesCore = distToBox <= enemyRadius;
                
                // NEW: Base speed with wave scaling (4% per wave)
                const waveMultSpeed = Math.pow(1.04, defenseWave - 1);
                let baseMoveForce = 1242 * 2.9 * 0.85 * 0.9 * waveMultSpeed; // UPDATED: Decreased by another 10% (2.9x * 0.85 * 0.9 = 2.2185x original)
                let moveForce = baseMoveForce;
                
                // UPDATED: Boss is 10% faster than previous (120750 * 1.1 = 132825)
                if (e.isBoss) moveForce = 132825; // 10% faster (120750 * 1.1) 
                
                // UPDATED: Adjusted speed force for Speedy enemies
                if (e.isSpeedy) moveForce = 1400 * waveMultSpeed;
                
                // UPDATED: Splitter has increased acceleration (not speed) - higher force multiplier to compensate for increased mass
                if (e.isSplitter) moveForce = baseMoveForce * 1.4; // Increased acceleration (was 0.7, now 1.4 - compensates for heavier mass)
                
                // UPDATED: Split enemies are 20% slower (was 10% faster, now 20% slower)
                // Check if it's a split enemy (pinkish, smaller) - we can check by coinValue or add a flag
                // For now, we'll use coinValue = 5 as identifier for split enemies
                if (e.coinValue === 5 && !e.isSpeedy && !e.isBoss && !e.isSplitter) {
                    moveForce = baseMoveForce * 0.8; // 20% slower (was 1.1, now 0.8)
                }
                
                // NEW: Check for thorns collision (bleed damage)
                if (!e.bleedTimer) e.bleedTimer = 0;
                e.bleedTimer -= dt;
                
                // Check if enemy is near a barrier with thorns
                for (let j = 0; j < defenseBarriers.length; j++) {
                    const barrier = defenseBarriers[j];
                    if (barrier.mesh.userData.thornsLevel > 0) {
                        const dist = e.body.position.distanceTo(barrier.body.position);
                        // FIXED: Upgrade amounts increased by 10%
                        const barrierWidth = 8.0 * Math.pow(1.12 * 1.1, barrierSizeLevel);
                        const barrierHeight = 8.1 * Math.pow(1.10 * 1.1, barrierSizeLevel);
                        
                        // Check if enemy is touching the barrier (within thorns range)
                        if (dist < barrierWidth * 0.6 && Math.abs(e.body.position.y - barrier.body.position.y) < barrierHeight * 0.6) {
                            if (e.bleedTimer <= 0) {
                                // Apply initial thorns damage
                                const baseDmg = 15 + (barrier.mesh.userData.thornsLevel * 10);
                                damageEnemy(e, baseDmg);
                                
                                // Apply bleed effect
                                if (!e.bleedStacks) e.bleedStacks = 0;
                                e.bleedStacks = Math.min(e.bleedStacks + 1, 5); // Max 5 stacks
                                e.bleedTimer = 1.0; // 1 second between thorns hits
                                
                                // Visual feedback
                                if (barrier.mesh.userData.thornsGroup) {
                                    barrier.mesh.userData.thornsGroup.children.forEach(thorn => {
                                        thorn.material.emissive.setHex(0xff0000);
                                        setTimeout(() => {
                                            if (thorn.material) thorn.material.emissive.setHex(0x000000);
                                        }, 200);
                                    });
                                }
                            }
                        }
                    }
                }
                
                // Apply bleed damage over time
                if (e.bleedStacks > 0) {
                    const bleedDmg = e.bleedStacks * (2 + barrierThornsLevel); // 2 base + level bonus per stack
                    e.hp -= bleedDmg * dt;
                    if (e.hp <= 0) {
                        const idx = defenseEnemies.indexOf(e);
                        if (idx > -1) killEnemy(idx);
                    }
                    // Reduce bleed stacks over time
                    e.bleedStacks = Math.max(0, e.bleedStacks - dt * 0.5); // Decay 0.5 stacks per second
                } 
                
                let dirX = dx / distToTarget;
                let dirZ = dz / distToTarget;

                // REMOVED: Gravity Dome Enemy Slow Logic

                // NEW: Backup Logic - If backing up, override movement
                if (e.backupTimer > 0) {
                    e.backupTimer -= dt;
                    
                    // Move backwards away from target
                    const backDirX = -dirX;
                    const backDirZ = -dirZ;
                    
                    // Add strong side component to navigate around (calculated when stuck)
                    const sideX = e.backupSideDir.x;
                    const sideZ = e.backupSideDir.z;

                    const finalBackX = backDirX + sideX;
                    const finalBackZ = backDirZ + sideZ;
                    
                    // Apply Force (scale by slowdown factor when shop is open)
                    e.body.applyForce(new CANNON.Vec3(finalBackX * moveForce * forceSlowdown, 0, finalBackZ * moveForce * forceSlowdown), e.body.position);
                    
                    // Skip normal obstacle avoidance and stuck check while backing up
                } else {
                    // --- NORMAL BEHAVIOR ---

                    // NEW: Obstacle Avoidance (Raycasting)
                    // Only check every few frames to save performance
                    e.aiRayTimer -= 1;
                    if (e.aiRayTimer <= 0) {
                        e.aiRayTimer = 10; // Reset timer
                        e.avoidanceDir.set(0,0,0);

                        // Cast ray forward to see if blocked
                        const start = e.mesh.position.clone();
                        start.y += 1.0; // Raise slightly
                        
                        // Direction is current velocity or towards target
                        const lookDir = new THREE.Vector3(e.body.velocity.x, 0, e.body.velocity.z).normalize();
                        if (lookDir.lengthSq() < 0.1) lookDir.set(dirX, 0, dirZ);

                        enemyRaycaster.set(start, lookDir);
                        const intersects = enemyRaycaster.intersectObjects(collidables);

                        if (intersects.length > 0 && intersects[0].distance < 15) {
                            // Obstacle detected! Steer sideways.
                            // Cross product with UP vector gives a perpendicular vector
                            const perp = new THREE.Vector3().crossVectors(lookDir, new THREE.Vector3(0,1,0));
                            
                            // Decide left or right based on relative target position
                            const toTarget = new THREE.Vector3(dirX, 0, dirZ);
                            const dot = perp.dot(toTarget);
                            
                            if (dot > 0) e.avoidanceDir.copy(perp);
                            else e.avoidanceDir.copy(perp.negate());
                            
                            // Also try to jump if it's a low wall
                            if (e.jumpCooldown <= 0 && intersects[0].distance < 8) {
                                e.body.velocity.y = 15;
                                e.jumpCooldown = 2.0;
                            }
                        }
                    }

                    // Apply Avoidance Vector
                    if (e.avoidanceDir.lengthSq() > 0) {
                        dirX = (dirX * 0.4) + (e.avoidanceDir.x * 0.9);
                        dirZ = (dirZ * 0.4) + (e.avoidanceDir.z * 0.9);
                        
                        // Normalize again
                        const len = Math.sqrt(dirX*dirX + dirZ*dirZ);
                        dirX /= len;
                        dirZ /= len;
                    }

                    // FIXED: Boss jump and shockwave logic
                    if (e.isBoss) {
                        e.bossJumpTimer += dt;
                        
                        // Every 6 seconds, boss jumps (when on ground)
                        // Check if boss is on ground (y position near spawn height + radius)
                        const groundHeight = e.body.shapes[0].boundingSphereRadius + 2; // Spawn height
                        if (e.bossJumpTimer >= 6.0 && !e.bossIsJumping && e.body.position.y < groundHeight + 2) {
                            e.bossIsJumping = true;
                            e.bossJumpTimer = 0;
                            e.bossJumpHeight = e.body.position.y;
                            
                            // Jump up shorter distance
                            const jumpHeight = 5 + Math.random(); // 5-6 units (reduced from 9-10)
                            const jumpImpulse = e.body.mass * jumpHeight * 25;
                            e.body.applyImpulse(new CANNON.Vec3(0, jumpImpulse, 0), e.body.position);
                        }
                        
                        // Check if boss is landing (was jumping and now on ground)
                        if (e.bossIsJumping && e.body.position.y < e.bossJumpHeight + 1 && e.body.velocity.y < 0) {
                            // Boss is landing - create shockwave ring
                            createBossShockwaveRing(e.body.position.x, e.body.position.z);
                            
                            // FIXED: Screen shake when boss lands
                            screenShake = 1.5; // Strong screen shake
                            
                            e.bossIsJumping = false;
                        }
                        
                        // FIXED: Make boss fall much faster by applying additional downward force
                        if (e.bossIsJumping && e.body.velocity.y < 0) {
                            // Apply very strong downward force to make boss fall much faster
                            const gravityBoost = e.body.mass * 50; // Very strong downward force
                            e.body.applyForce(new CANNON.Vec3(0, -gravityBoost, 0), e.body.position);
                        }
                    }

                    // Apply Movement Force
                    e.body.applyForce(new CANNON.Vec3(dirX * moveForce, 0, dirZ * moveForce), e.body.position);

                    // Anti-Stuck & Jump & Backup Logic
                    const hVel = Math.sqrt(e.body.velocity.x**2 + e.body.velocity.z**2);
                    
                    // Calculate distance to core for stuck detection
                    const distToCoreForStuck = e.body.position.distanceTo(corePos);
                    if (distToCoreForStuck > 15 && hVel < 1.0) {
                        e.stuckTime += dt;
                        
                        // Stage 1: Jump (0.5s stuck)
                        if (e.stuckTime > 0.5 && e.stuckTime < 1.0) { 
                            e.jumpCooldown -= dt;
                            if (e.jumpCooldown <= 0) {
                                // Jump!
                                const jumpImpulse = e.body.mass * 18; 
                                e.body.applyImpulse(new CANNON.Vec3(0, jumpImpulse, 0), e.body.position);
                                
                                // Push forward/randomly
                                const fwdImpulse = e.body.mass * 8;
                                e.body.applyImpulse(new CANNON.Vec3(dirX * fwdImpulse, 0, dirZ * fwdImpulse), e.body.position);
                                
                                e.jumpCooldown = 1.5; 
                            }
                            
                            // Wiggle
                            const sideX = -dirZ;
                            const sideZ = dirX;
                            const slideFactor = Math.sin(Date.now() * 0.01); 
                            const slideForce = moveForce * 1.0 * slideFactor;
                            e.body.applyForce(new CANNON.Vec3(sideX * slideForce * forceSlowdown, 0, sideZ * slideForce * forceSlowdown), e.body.position);
                        }
                        // Stage 2: Back Up (1.0s stuck)
                        else if (e.stuckTime >= 1.0) {
                             e.backupTimer = 0.8; // UPDATED: 0.8 seconds (was 1.0)
                             e.stuckTime = 0; // Reset
                             
                             // Calculate random perpendicular side direction to navigate around
                             // Left or Right?
                             const sideSign = Math.random() > 0.5 ? 1 : -1;
                             // Perpendicular vector (-z, x)
                             e.backupSideDir.set(-dirZ * sideSign * 1.5, 0, dirX * sideSign * 1.5);
                             
                             // Small hop to detach friction
                             e.body.applyImpulse(new CANNON.Vec3(0, e.body.mass * 5, 0), e.body.position);
                        }
                    } else {
                        e.stuckTime = Math.max(0, e.stuckTime - dt);
                        e.jumpCooldown = Math.max(0, e.jumpCooldown - dt);
                    }
                } // End of Normal Behavior Else Block
                
                if (e.body.position.y < -30) {
                    killEnemy(i, false); 
                    continue;
                }

                // UPDATED: Hitbox logic adjustment
                // Normal Enemy Collision Dist: ~6.8 (Face) to ~8.5 (Corner) -> Set to 8.5
            // FIXED: Use accurate box-sphere intersection check instead of distance
            if (touchesCore) { 
                    let dmg = 10;
                    if (e.isBoss) dmg = 50;
                    if (e.isSpeedy) dmg = 15; 

                    screenShake = 0.5;
                    SoundManager.playExplosion();

                    // NEW: Shield Absorption Logic
                    if (coreShieldCurrent > 0) {
                        lastShieldHitTime = Date.now();
                        
                        // Durability upgrade reduces damage taken: 5% reduction per level
                        // FIXED: Upgrade amounts increased by 10%
                        const durabilityReduction = 1.0 - (coreShieldDurabilityLevel * 0.055); // 5% * 1.1 = 5.5%
                        const actualDmg = Math.max(0, dmg * durabilityReduction);
                        
                        // Shield takes hit
                        if (coreShieldCurrent >= actualDmg) {
                            coreShieldCurrent -= actualDmg;
                            dmg = 0; // Completely absorbed
                            
                            // Visual: Shield Flash
                            if(defenseCoreMesh && defenseCoreMesh.userData.shield) {
                                defenseCoreMesh.userData.shield.material.opacity = 0.8;
                                defenseCoreMesh.userData.shield.material.color.setHex(0xffffff);
                                setTimeout(() => {
                                    if(defenseCoreMesh && defenseCoreMesh.userData.shield) {
                                        defenseCoreMesh.userData.shield.material.color.setHex(0x00ffff);
                                    }
                                }, 100);
                            }
                        } else {
                            // Shield breaks, remainder goes to health
                            dmg -= coreShieldCurrent;
                            coreShieldCurrent = 0;
                            statusEl.innerText = "SHIELD BROKEN!";
                        }
                    }

                    // Apply remaining damage to hull
                    if (dmg > 0) {
                        defenseCoreHealth -= dmg; 
                        
                        // MULTIPLAYER: Notify server of core hit
                        if (socket && socket.connected) {
                            socket.emit('coreHit', {
                                damage: dmg
                            });
                        }
                        
                        // Flash Core White
                        if(defenseCoreMesh && defenseCoreMesh.userData.isCore) {
                            defenseCoreMesh.userData.crystal.material.color.setHex(0xffffff);
                            defenseCoreMesh.userData.light.color.setHex(0xffffff);
                            setTimeout(() => { 
                                if(defenseCoreMesh && defenseCoreMesh.userData.isCore) {
                                    defenseCoreMesh.userData.crystal.material.color.setHex(0xff0000);
                                    defenseCoreMesh.userData.light.color.setHex(0xff0000);
                                }
                            }, 100);
                        }
                    }
                    
                    if (defenseCoreHealth > 0) {
                        createRedesignedExplosion(e.body.position);
                        // UPDATED: Pass 0.5 as coin multiplier (Half cash penalty)
                        killEnemy(i, true, 0.5); 
                    } else {
                        endDefenseGame();
                        return;
                    }
                    
                    updateDefenseUI();
                }
            }

            if (enemiesToSpawn === 0 && speedyEnemiesToSpawn === 0 && splitterEnemiesToSpawn === 0 && defenseEnemies.length === 0 && waveInProgress) {
                waveInProgress = false;
                statusEl.innerText = "WAVE COMPLETE!";
                SoundManager.playCharge(0.5); 
                
                // WAVE BONUS
                const bonus = 100 * defenseWave;
                defenseCoins += bonus;
                statusEl.innerText = `WAVE COMPLETE! +$${bonus}`;
                
                setTimeout(() => {
                    for(let ex of explosions) { if(ex.dispose) ex.dispose(); else scene.remove(ex.group); }
                    explosions = [];
                    
                    const oldWave = defenseWave;
                    defenseWave++;
                    
                    // MULTIPLAYER: Reset spawn counter for new wave (deterministic spawning)
                    if (isMultiplayerEnabled && isDefenseMode) {
                        enemySpawnCounter = 0;
                    }
                    
                    // FIXED: Wave 1 = 10 enemies, then increase by 2-3 each wave
                    // MULTIPLAYER: Use deterministic enemy count for sync
                    if (isMultiplayerEnabled && isDefenseMode) {
                        // Deterministic: use wave number to determine count
                        enemiesToSpawn = 10 + (defenseWave - 1) * 2 + (defenseWave % 2); // Alternates between +2 and +3
                    } else {
                        enemiesToSpawn = 10 + (defenseWave - 1) * (2 + Math.floor(Math.random() * 2)); // 10 + (wave-1) * (2-3)
                    }
                    // NEW: Update total for percentage calculation
                    totalEnemiesForWave = enemiesToSpawn;
                    
                    // Reset alert flag for new wave
                    speedyAlertShown = false;

                    // FIXED: Speedy enemies spawn from wave 2, count as 4, then +1 every 2 waves
                    if (defenseWave >= 2) {
                        // Wave 2 = 4, Wave 4 = 5, Wave 6 = 6, etc.
                        const waveOffset = defenseWave - 2;
                        speedyEnemiesToSpawn = 4 + Math.floor(waveOffset / 2);
                        // Reset timer so they are ready to spawn when halfway point hits
                        nextSpeedySpawnTime = 0; 
                    } else {
                        speedyEnemiesToSpawn = 0;
                    }
                    
                    // NEW: Splitter enemies spawn every 3 waves (starting at wave 3)
                    if (defenseWave >= 3 && defenseWave % 3 === 0) {
                        splitterEnemiesToSpawn = 2 + Math.floor(defenseWave / 3);
                        nextSplitterSpawnTime = 0;
                    } else {
                        splitterEnemiesToSpawn = 0;
                    }
                    
                    waveInProgress = true;
                    nextSpawnTime = Date.now();
                    
                    // MULTIPLAYER: Notify server of wave completion (only host)
                    if (socket && socket.connected && isHost) {
                        socket.emit('waveComplete', {
                            bonus: bonus,
                            enemiesToSpawn: enemiesToSpawn,
                            speedyEnemiesToSpawn: speedyEnemiesToSpawn,
                            splitterEnemiesToSpawn: splitterEnemiesToSpawn
                        });
                    }
                    
                    updateDefenseUI();
                    
                    statusEl.innerText = "WAVE " + defenseWave + " START";
                    setTimeout(() => statusEl.innerText = "DEFEND THE CORE", 2000);

                }, 4000);
            }
        }

        // UPDATED: Added coinMult parameter (default 1.0)
        function killEnemy(index, explode = true, coinMult = 1.0) {
            const e = defenseEnemies[index];
            if (!e) return;
            
            // NEW: Splitter spawns 3 smaller enemies on death with special effect
            if (e.isSplitter) {
                const spawnPos = e.body.position.clone();
                
                // Create special splitter death effect
                createSplitterDeathEffect(spawnPos, e.body.shapes[0]?.boundingSphereRadius || 4.76);
                
                // Spawn split enemies with slight delay for dramatic effect
                setTimeout(() => {
                    for (let i = 0; i < 3; i++) {
                        spawnSplitEnemy(spawnPos);
                    }
                }, 200);
            }
            
            // FIXED: Award Coins (Apply multiplier and reduce by 25%)
            const coinsEarned = Math.floor(e.coinValue * coinMult * 0.75);
            defenseCoins += coinsEarned;
            
            // MULTIPLAYER: Notify server of enemy kill
            if (socket && socket.connected) {
                socket.emit('enemyKilled', {
                    enemyIndex: index,
                    coins: coinsEarned,
                    position: {
                        x: e.body.position.x,
                        y: e.body.position.y,
                        z: e.body.position.z
                    }
                });
            }
            
            // SoundManager.playCash(); // REMOVED COIN SOUND

            if (explode) {
                // Use special boss explosion
                if (e.isBoss) {
                    createBossDeathExplosion(e.body.position, e.body.shapes[0]?.boundingSphereRadius || 8.64);
                } else if (e.isSplitter) {
                    // Already handled in createSplitterDeathEffect
                } else {
                    let scale = 0.4;
                    createRedesignedExplosion(e.body.position, scale);
                }
                
                // RESTORED EXPLOSION SOUND
                SoundManager.playExplosion();
            }

            world.removeBody(e.body);
            scene.remove(e.mesh);
            defenseEnemies.splice(index, 1);
            updateDefenseUI();
        }

        // NEW: Spawn split enemy (smaller, pinkish, faster)
        function spawnSplitEnemy(spawnPos) {
            // NEW: Apply wave scaling to size (4% per wave)
            const waveMultSize = Math.pow(1.04, defenseWave - 1);
            const baseRadius = 2.625 * 0.875; // 87.5% of regular size (70% * 1.25 = ~2.3)
            const radius = baseRadius * waveMultSize;
            const mass = 40; // Lighter
            const coinVal = 5; // Less valuable
            
            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({ mass: mass });
            body.addShape(shape);
            
            // Spawn with slight random offset from parent position
            const offsetX = (Math.random() - 0.5) * 3;
            const offsetZ = (Math.random() - 0.5) * 3;
            // REVERTED: Spawn split enemies on grid floor
            body.position.set(spawnPos.x + offsetX, radius + 2, spawnPos.z + offsetZ); // Spawn on grid floor
            
            // Give initial velocity outward
            const velX = (Math.random() - 0.5) * 8;
            const velZ = (Math.random() - 0.5) * 8;
            body.velocity.set(velX, 5, velZ);
            
            body.linearDamping = 0.86;
            body.angularDamping = 0.1;
            body.collisionFilterGroup = 1;
            body.collisionFilterMask = -1;
            
            world.addBody(body);
            
            // COMPLETE REDESIGN: Split Enemy - "Void Fragment"
            const group = new THREE.Group();
            
            // 1. Main body - Smaller dark fragment
            const mainGeo = new THREE.TetrahedronGeometry(radius, 1);
            const mainMat = new THREE.MeshStandardMaterial({ 
                color: 0x2a1a3a, // Dark purple-black
                metalness: 0.2, 
                roughness: 0.8,
                emissive: 0x6a1a8a,
                emissiveIntensity: 0.4
            });
            const main = new THREE.Mesh(mainGeo, mainMat);
            group.add(main);
            
            // 2. Purple energy core (smaller, brighter)
            const coreGeo = new THREE.SphereGeometry(radius * 0.5, 16, 16);
            const coreMat = new THREE.MeshBasicMaterial({ 
                color: 0xaa44ff, // Bright purple
                transparent: true,
                opacity: 0.8,
                emissive: 0xaa44ff,
                emissiveIntensity: 1.0
            });
            const core = new THREE.Mesh(coreGeo, coreMat);
            group.add(core);
            
            // 3. Energy trail (3 small fragments following)
            const trailGeo = new THREE.TetrahedronGeometry(radius * 0.2, 0);
            const trailMat = new THREE.MeshBasicMaterial({ 
                color: 0x8b00ff,
                transparent: true,
                opacity: 0.7,
                emissive: 0x8b00ff,
                emissiveIntensity: 0.6
            });
            
            const trailFragments = [];
            for (let i = 0; i < 3; i++) {
                const frag = new THREE.Mesh(trailGeo, trailMat.clone());
                frag.position.set(
                    (Math.random() - 0.5) * radius * 0.8,
                    -radius * 0.6 - i * radius * 0.3,
                    (Math.random() - 0.5) * radius * 0.8
                );
                group.add(frag);
                trailFragments.push(frag);
            }
            
            // 4. Energy particles orbiting
            const particleGeo = new THREE.SphereGeometry(radius * 0.08, 8, 8);
            const particleMat = new THREE.MeshBasicMaterial({ 
                color: 0xaa44ff,
                transparent: true,
                opacity: 0.9,
                emissive: 0xaa44ff,
                emissiveIntensity: 0.8
            });
            
            const particles = [];
            for (let i = 0; i < 4; i++) {
                const particle = new THREE.Mesh(particleGeo, particleMat.clone());
                const angle = (i / 4) * Math.PI * 2;
                particle.position.set(
                    Math.cos(angle) * radius * 1.1,
                    (Math.random() - 0.5) * radius * 0.4,
                    Math.sin(angle) * radius * 1.1
                );
                group.add(particle);
                particles.push(particle);
            }
            
            // Store for animation
            group.userData = {
                isSplitAnim: true,
                radius: radius,
                core: core,
                trailFragments: trailFragments,
                particles: particles
            };
            
            group.castShadow = true;
            scene.add(group);
            
            // NEW: 4% increase per wave for HP, size, and speed
            const waveMult = Math.pow(1.04, defenseWave - 1);
            // Lower health than regular (about 50% of regular), then reduced by 35%, then reduced by another 30%
            let hp = 425 * 0.65 * 0.7 * waveMult; // Reduced by 35% then another 30% (425 * 0.65 * 0.7 = 193.375)
            
            const enemyObj = {
                body: body,
                mesh: group,
                hp: hp,
                maxHp: hp,
                isBoss: false,
                isSpeedy: false,
                isSplitter: false,
                coinValue: coinVal, // FIXED: Use coinValue to match killEnemy function
                lastHitTime: 0,
                jumpCooldown: 0,
                aiOffset: Math.random() * Math.PI * 2,
                aiRayTimer: Math.random() * 10,
                avoidanceDir: new THREE.Vector3(),
                backupTimer: 0,
                backupSideDir: new THREE.Vector3(),
                feintState: 0,
                feintTimer: 0,
                feintDir: new THREE.Vector3(),
                // NEW: Boss jump and shockwave variables
                bossJumpTimer: 0,
                bossIsJumping: false,
                bossJumpHeight: 0
            };
            
            enemyObj.stuckTime = 0;
            enemyObj.avoidState = 0;
            enemyObj.avoidTimer = 0;
            enemyObj.avoidDir = new CANNON.Vec3();
            
            // FIXED: Ensure split enemies are properly added to defenseEnemies array
            // so they can be hit by projectiles
            defenseEnemies.push(enemyObj);
            
            // Collision handler
            body.addEventListener('collide', (e) => {
                const now = Date.now();
                if (now - enemyObj.lastHitTime < 100) return;
                
                const otherBody = (e.contact.bi === body) ? e.contact.bj : e.contact.bi;
                if(otherBody.userData && otherBody.userData.isGround) return;
                
                const impactVel = Math.abs(e.contact.getImpactVelocityAlongNormal());
                if (impactVel > 8) {
                    enemyObj.lastHitTime = now;
                }
            });
        }

        function endDefenseGame() {
            if (!defenseCoreBody) return; 

            statusEl.innerText = ""; 
            gameState = 'gameover'; 
            document.exitPointerLock();

            // Hide shop on game over
            document.getElementById('defense-shop').style.display = 'none';

            gameOverEl.style.display = 'flex';
            hudEl.style.display = 'none';
            gameOverStatsEl.innerText = "You survived " + (defenseWave - 1) + " Waves";

            const finalPos = defenseCoreBody.position.clone();

            clearAllStructures(); 
            
            for(let ex of explosions) {
                if(ex.dispose) ex.dispose();
                else scene.remove(ex.group);
            }
            explosions = [];

            createRedesignedExplosion(finalPos, 1.5);
            createRedesignedExplosion(finalPos.vadd(new CANNON.Vec3(0,5,0)), 1.5);
            
            defenseCoreBody = null;
            defenseCoreMesh = null;
            
            // Clear boss shockwave rings
            for (let i = 0; i < bossShockwaveRings.length; i++) {
                if (bossShockwaveRings[i].group) {
                    scene.remove(bossShockwaveRings[i].group);
                }
            }
            bossShockwaveRings = [];
        }

        function onPointerLockChange() {
            isLocked = (document.pointerLockElement === document.body);
            
            // Check if shop is open to prevent auto-pausing
            const shopOpen = document.getElementById('defense-shop').style.display === 'flex';

            if (!isLocked && gameState === 'playing' && !shopOpen && !isPlayerPaused) {
                togglePause();
            }
        }

        function showMenu() {
            gameState = 'menu';
            menuEl.style.display = 'flex';
            hudEl.style.display = 'none';
            document.getElementById('defense-shop').style.display = 'none'; // Hide shop
            document.exitPointerLock();
        }

        
        function createGround(material) {
            // REVERTED: Simple grid floor
            const groundSize = 1000;
            
            // Create flat ground plane
            const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize);
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                roughness: 0.8,
                metalness: 0.1
            });
            const groundMesh = new THREE.Mesh(groundGeo, groundMat);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.position.y = 0;
            groundMesh.receiveShadow = true;
            groundMesh.castShadow = false;
            groundMesh.userData.isGround = true;
            scene.add(groundMesh);
            
            // Add grid helper
            const gridHelper = new THREE.GridHelper(groundSize, 50, 0x888888, 0x444444);
            gridHelper.position.y = 0.01; // Slightly above ground to avoid z-fighting
            scene.add(gridHelper);
            
            // Create physics body - simple flat plane
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0, material: material });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // Rotate to lay flat
            groundBody.position.set(0, 0, 0);
            groundBody.collisionFilterGroup = 1;
            groundBody.collisionFilterMask = -1;
            groundBody.userData = { isGround: true };
            world.addBody(groundBody);
            
            collidables.push(groundMesh);
        }

        function createSky() {
            // REVERTED: Simple sky design
            scene.background = new THREE.Color(0x87CEEB);
            
            // Simple sun (kept raised position)
            const sunGeo = new THREE.SphereGeometry(20, 32, 32);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const sun = new THREE.Mesh(sunGeo, sunMat);
            sun.position.set(100, 450, 50); // Keep raised position
            scene.add(sun);

            // Simple clouds (kept raised position)
            const cloudGeo = new THREE.BoxGeometry(1, 1, 1);
            const cloudMat = new THREE.MeshStandardMaterial({ color: 0xffffff, opacity: 0.8, transparent: true });
            
            for(let i=0; i<25; i++) {
                const cloud = new THREE.Group();
                const clusters = 3 + Math.floor(Math.random() * 5);
                for(let j=0; j<clusters; j++) {
                    const puff = new THREE.Mesh(cloudGeo, cloudMat);
                    puff.position.set((Math.random()-0.5)*15, (Math.random()-0.5)*5, (Math.random()-0.5)*10);
                    puff.scale.set(8 + Math.random()*8, 4 + Math.random()*4, 6 + Math.random()*6);
                    cloud.add(puff);
                }
                cloud.position.set((Math.random()-0.5) * 800, 200 + Math.random() * 60, (Math.random()-0.5) * 800);
                cloud.userData = { speed: 2 + Math.random() * 3 };
                scene.add(cloud);
                clouds.push(cloud);
            }
        }

        
        function setAmmo(type) {
            // NEW: Locked Check
            if (isDefenseMode && !unlockedWeapons.includes(type)) {
                // Optional: Play locked sound or visual feedback
                return;
            }

            SoundManager.stopHeavyCharge();

            if (isEraserMode) {
                isEraserMode = false;
                statusEl.innerText = "READY";
                statusEl.classList.remove('erasing');
                if (eraserMarker) eraserMarker.visible = false;
                
                sliderLabel.innerText = "Grab Size:";
                sliderInput.value = CONFIG.grabRadius;
                sliderVal.innerText = CONFIG.grabRadius;
                eraserDistEl.classList.remove('visible'); 
            }

            currentAmmo = type;
            document.querySelectorAll('.ammo-btn').forEach(btn => btn.classList.remove('selected'));
            document.getElementById(`btn-${type}`).classList.add('selected');
            
            shockwaveChargeMesh.visible = false;
            isChargingShockwave = false;
            shockwaveCharge = 0;
            isChargingFire = false;
            loadedBall.scale.set(1, 1, 1);
            // UPDATED: Z Position -5.5
            loadedBall.position.set(2.2, -1.4, -5.5);
            
            // NEW: Reset Opacity for Heavy Ball
            if (loadedBall && loadedBall.userData.ammoMeshes && loadedBall.userData.ammoMeshes.heavy.userData.core) {
                loadedBall.userData.ammoMeshes.heavy.userData.core.material.opacity = 1.0;
                loadedBall.userData.ammoMeshes.heavy.userData.cage.material.opacity = 0.5;
            }
            
            chargeBarWrap.classList.remove('visible');
            chargeBarText.innerText = "CHARGE"; 
            
            if (loadedBall && loadedBall.userData && loadedBall.userData.ammoMeshes) {
                const meshes = loadedBall.userData.ammoMeshes;
                Object.values(meshes).forEach(m => m.visible = false);
                
                if (type === 'heavy') meshes.heavy.visible = true;
                else if (type === 'explosive') meshes.explosive.visible = true;
                else if (type === 'blackhole') meshes.blackhole.visible = true;
                else if (type === 'raygun') meshes.raygun.visible = true;
            }

            if (type === 'raygun') {
                sliderContainer.classList.add('visible');
                formSpeedContainer.classList.add('visible');
                loadedBall.visible = true;
            } else if (type === 'shockwave') {
                sliderContainer.classList.remove('visible');
                formSpeedContainer.classList.remove('visible');
                loadedBall.visible = false;
                chargeBarWrap.classList.add('visible');
                chargeBarText.innerText = "SHOCKWAVE CHARGE";
            } else {
                sliderContainer.classList.remove('visible');
                formSpeedContainer.classList.remove('visible');
                loadedBall.visible = true;
            }
        }
        window.setAmmo = setAmmo;

        function updateAmmoMenuVisuals() {
            const types = ['heavy', 'explosive', 'blackhole', 'raygun', 'shockwave'];
            types.forEach(t => {
                const btn = document.getElementById(`btn-${t}`);
                if (isDefenseMode && !unlockedWeapons.includes(t)) {
                    btn.classList.add('locked');
                } else {
                    btn.classList.remove('locked');
                }
            });
        }

        function cycleAmmo() {
            const types = ['heavy', 'explosive', 'blackhole', 'raygun', 'shockwave'];
            
            // NEW: Only cycle through unlocked weapons in Defense Mode
            let available = types;
            if (isDefenseMode) {
                available = types.filter(t => unlockedWeapons.includes(t));
            }

            let idx = available.indexOf(currentAmmo);
            // If current ammo isn't in unlocked list (shouldn't happen but safety check), default to 0
            if (idx === -1) idx = 0;
            
            setAmmo(available[(idx + 1) % available.length]);
        }

        
        function createBlockTexture() {
            const canvas = document.createElement('canvas');
            const size = 95;
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            const scale = size / 64;
            ctx.scale(scale, scale);
            
            ctx.fillStyle = '#444444'; 
            ctx.fillRect(0, 0, 64, 64);
            
            const bevelSize = 3;
            
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.beginPath();
            ctx.moveTo(0,0); ctx.lineTo(64,0); ctx.lineTo(64-bevelSize, bevelSize); ctx.lineTo(bevelSize, bevelSize);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(0,0); ctx.lineTo(bevelSize, bevelSize); ctx.lineTo(bevelSize, 64-bevelSize); ctx.lineTo(0, 64);
            ctx.fill();

            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.moveTo(0,64); ctx.lineTo(bevelSize, 64-bevelSize); ctx.lineTo(64-bevelSize, 64-bevelSize); ctx.lineTo(64, 64);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(64,64); ctx.lineTo(64-bevelSize, 64-bevelSize); ctx.lineTo(64-bevelSize, bevelSize); ctx.lineTo(64, 0);
            ctx.fill();
            
            ctx.fillStyle = '#777777';
            ctx.fillRect(bevelSize, bevelSize, 64-(bevelSize*2), 64-(bevelSize*2)); 
            
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const inner = bevelSize;
            const outer = 64 - bevelSize;
            ctx.moveTo(outer-2, inner); ctx.lineTo(inner, inner); ctx.lineTo(inner, outer-2);
            ctx.stroke();
            
            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.moveTo(outer-2, inner); ctx.lineTo(outer-2, outer-2); ctx.lineTo(inner, outer-2);
            ctx.stroke();

            ctx.fillStyle = '#666666'; 
            ctx.beginPath();
            ctx.arc(32, 32, 10, 0, Math.PI*2);
            ctx.fill();

            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(32, 32, 10, -Math.PI/4, Math.PI*0.75);
            ctx.stroke();

            const tex = new THREE.CanvasTexture(canvas);
            tex.anisotropy = 4;
            return tex;
        }


        
        function onMouseDown(event) {
            // FIXED: Prevent pointer lock when clicking shop or menu elements
            if (event.target.closest('.menu-container') || 
                event.target.closest('.shop-btn') || 
                event.target.closest('.shop-btn-sub') ||
                event.target.closest('#defense-shop')) {
                return;
            }
            
            // FIXED: Don't lock pointer if shop is open
            if (isShopOpen) {
                return;
            }
            
            // NEW: Placement Interaction
            if (isPlacingBarrier) {
                if (event.button === 0) { // Left Click
                    confirmPlacement();
                } else if (event.button === 2) { // Right Click
                    cancelPlacement();
                }
                return;
            }

            if (!isLocked || isPlayerPaused) {
                if(gameState === 'playing') {
                    const promise = document.body.requestPointerLock();
                    if (promise) promise.catch(err => console.log("Pointer lock failed:", err));
                    SoundManager.init(); 
                }
                return;
            }

            if (event.button === 2) {
                if (currentAmmo === 'raygun' && grabbedBodies.length > 0) {
                    isChargingThrow = true;
                    throwCharge = 0;
                    chargeBarWrap.classList.add('visible');
                    chargeBarText.innerText = "THROW POWER";
                    return; 
                }
            }
            else if (event.button === 0) {
                // Prevent aiming when shop is open
                if (isShopOpen) return;
                
                if (!isAiming && currentAmmo !== 'shockwave' && currentAmmo !== 'raygun' && !isEraserMode) { 
                    isAiming = true; 
                    statusEl.innerText = "AIMING..."; 
                    statusEl.classList.add('aiming'); 
                } 
                else {
                    if (isEraserMode) {
                        isErasing = true;
                    } else if (currentAmmo === 'raygun') {
                        tryGrab();
                    } else if (currentAmmo === 'shockwave') {
                        isChargingShockwave = true;
                        shockwaveCharge = 0;
                        shockwaveChargeMesh.visible = true;
                    } else if (currentAmmo === 'heavy') {
                        // NEW: 0.3s Cooldown Check
                        if (Date.now() - lastGeneralFireTime < 300) return;

                        isChargingFire = true;
                        fireChargeStart = Date.now();
                    } else {
                        const now = Date.now();
                        
                        if (currentAmmo === 'blackhole') {
                            if (now - lastBlackHoleTime < 10000) {
                                const remaining = Math.ceil((10000 - (now - lastBlackHoleTime)) / 1000);
                                statusEl.innerText = `COOLDOWN (${remaining}s)`;
                                statusEl.classList.add('erasing'); 
                                setTimeout(() => {
                                    statusEl.innerText = "READY";
                                    statusEl.classList.remove('erasing');
                                }, 1000);
                                return;
                            }
                            lastBlackHoleTime = now;
                        } else {
                            if (now - lastGeneralFireTime < 500) {
                                return;
                            }
                            lastGeneralFireTime = now;
                        }
                        
                        shoot();
                    }
                }
            }
        }

        function releaseChargedThrow() {
            if (grabbedBodies.length > 0) {
                SoundManager.playShoot('raygun'); 
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                
                const targetSpeed = 34 + (throwCharge * 221); 

                grabbedBodies.forEach(b => {
                    b.wakeUp();
                    
                    let impulseMag = b.mass * targetSpeed;

                    if (b.userData && b.userData.isHeavyBall) {
                        impulseMag *= 0.525; 
                    }
                    
                    const impulse = new CANNON.Vec3(dir.x * impulseMag, dir.y * impulseMag, dir.z * impulseMag);

                    b.applyImpulse(impulse, b.position);
                    b.angularVelocity.set(
                        (Math.random()-0.5)*20, 
                        (Math.random()-0.5)*20, 
                        (Math.random()-0.5)*20
                    );
                });
                
                tryThrow();
                
                statusEl.innerText = "LAUNCHED!";
                setTimeout(() => { if(!isAiming) statusEl.innerText = "READY"; }, 500);
            }
        }

        function onMouseUp(event) {
            if (event.button === 2) {
                if (isChargingThrow) {
                    releaseChargedThrow();
                    isChargingThrow = false;
                    chargeBarWrap.classList.remove('visible');
                    chargeBarText.innerText = "SHOCKWAVE CHARGE"; 
                    return;
                }
            }
            if (event.button === 0) {
                if (isEraserMode) {
                    isErasing = false;
                } else if(currentAmmo === 'raygun') {
                    if (grabbedBodies.length > 0) {
                        tryThrow();
                    }
                } else if (currentAmmo === 'shockwave') {
                    if(isChargingShockwave) {
                        fireShockwave();
                        isChargingShockwave = false;
                        shockwaveChargeMesh.visible = false;
                        chargeBarFill.style.width = '0%';
                    }
                } else if (currentAmmo === 'heavy' && isChargingFire) {
                    shoot();
                    // NEW: Reset cooldown timer on fire
                    lastGeneralFireTime = Date.now();
                    isChargingFire = false;
                }
            }
        }

        function fireShockwave() {
            // FIXED: 10 second cooldown for shockwave
            const now = Date.now();
            if (now - lastShockwaveTime < 10000) return; // 10 second cooldown
            if (shockwaveCharge < 0.1) return;
            
            lastShockwaveTime = now;

            SoundManager.playShockwave();

            const startPos = new THREE.Vector3();
            shockwaveChargeMesh.getWorldPosition(startPos);
            
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);

            const chargeLevel = shockwaveCharge; 
            const size = 0.8 + (chargeLevel * 7.0); 

            const shockGroup = new THREE.Group();
            shockGroup.position.copy(startPos);
            shockGroup.lookAt(startPos.clone().add(dir));
            scene.add(shockGroup);

            const coreGeo = new THREE.SphereGeometry(1, 32, 32);
            const coreMat = new THREE.MeshBasicMaterial({ color: 0x110033, transparent:true, opacity:0.9 });
            const coreMesh = new THREE.Mesh(coreGeo, coreMat);
            coreMesh.scale.set(size, size, size);
            shockGroup.add(coreMesh);

            const ringGeo = new THREE.TorusGeometry(1, 0.05, 16, 100);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0x3300aa, transparent:true, opacity:0.8 });
            
            const rings = [];
            for(let i=0; i<3; i++) {
                const r = new THREE.Mesh(ringGeo, ringMat);
                r.scale.set(size*(1.2 + i*0.2), size*(1.2 + i*0.2), size*(1.2 + i*0.2));
                r.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                shockGroup.add(r);
                rings.push(r);
            }

            const pCount = 120;
            const pGeo = new THREE.BufferGeometry();
            const pPos = new Float32Array(pCount * 3);
            for(let i=0; i<pCount; i++) {
                pPos[i*3] = (Math.random()-0.5)*size*3.0;
                pPos[i*3+1] = (Math.random()-0.5)*size*3.0;
                pPos[i*3+2] = (Math.random()-0.5)*size*3.0;
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            const pMat = new THREE.PointsMaterial({ color: 0x2200cc, size: 0.8, transparent: true, opacity: 0.6 });
            const particles = new THREE.Points(pGeo, pMat);
            shockGroup.add(particles);

            const cageGeo = new THREE.IcosahedronGeometry(1, 1);
            const cageMat = new THREE.MeshBasicMaterial({ color: 0x8800ff, wireframe: true, transparent: true, opacity: 0.5 });
            const cage = new THREE.Mesh(cageGeo, cageMat);
            cage.scale.set(size * 1.5, size * 1.5, size * 1.5);
            shockGroup.add(cage);

            const windCount = 75; 
            const windGeo = new THREE.BufferGeometry();
            
            const windPos = new Float32Array(windCount * 2 * 3);
            const windData = []; 
            
            for(let i=0; i<windCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                
                const rStart = size * (0.4 + Math.random() * 0.3); 
                const rMid = size * (0.95 + Math.random() * 0.1);    
                const rEnd = size * (0.2 + Math.random() * 0.3); 

                const x = Math.cos(angle);
                const y = Math.sin(angle);
                
                const vStart = new THREE.Vector3(x * rStart, y * rStart, size * 0.8); 
                const vMid = new THREE.Vector3(x * rMid, y * rMid, -size * 0.2); 
                const vEnd = new THREE.Vector3(x * rEnd, y * rEnd, -size * 1.5); 

                const curve = new THREE.QuadraticBezierCurve3(vStart, vMid, vEnd);
                
                windData.push({
                    curve: curve,
                    speed: (0.5 + Math.random() * 1.0) * 1.1, 
                    t: Math.random(), 
                    length: 0.1 + Math.random() * 0.1 
                });
            }
            windGeo.setAttribute('position', new THREE.BufferAttribute(windPos, 3));
            
            const windMat = new THREE.LineBasicMaterial({ 
                color: 0xccffff, 
                transparent: true, 
                opacity: 0.4,
                blending: THREE.AdditiveBlending 
            });
            const windLines = new THREE.LineSegments(windGeo, windMat);
            shockGroup.add(windLines);

            shockwaves.push({
                group: shockGroup,
                core: coreMesh,
                rings: rings,
                particles: particles,
                cage: cage, 
                windLines: windLines,
                windData: windData,
                pos: startPos.clone(),
                dir: dir.clone(),
                speed: 41 + (chargeLevel * 27), 
                radius: size * 3.0, 
                force: 316 + (chargeLevel * 3795), 
                life: 5.0,
                maxLife: 5.0,
                baseRadius: size * 2.0,
                health: 1.0, 
                hitBodies: new Set() 
            });
        }

        function updateShockwaves(dt) {
            for(let i = shockwaves.length - 1; i >= 0; i--) {
                const s = shockwaves[i];
                s.life -= dt;
                
                if(s.health <= 0.1) s.life = 0;

                const currentScale = s.health * (s.baseRadius / 2.0); 
                s.core.scale.set(currentScale, currentScale, currentScale);
                s.rings.forEach((r, idx) => {
                    const rs = currentScale * (1.2 + idx*0.2);
                    r.scale.set(rs, rs, rs);
                    r.rotation.x += (2 + idx) * dt;
                    r.rotation.y += (2 - idx) * dt;
                });
                
                if (s.cage) {
                    s.cage.rotation.y -= 2.0 * dt;
                    s.cage.rotation.z += 1.0 * dt;
                    s.cage.scale.set(currentScale * 1.5, currentScale * 1.5, currentScale * 1.5);
                }
                
                if (s.windLines && s.windData) {
                    const posAttr = s.windLines.geometry.attributes.position;
                    const arr = posAttr.array;
                    
                    for(let k=0; k<s.windData.length; k++) {
                        const d = s.windData[k];
                        d.t += dt * d.speed; 
                        
                        if (d.t > 1.0 + d.length) {
                            d.t = 0; 
                        }

                        const tHead = Math.max(0, Math.min(1, d.t));
                        const tTail = Math.max(0, Math.min(1, d.t - d.length));
                        
                        const pHead = d.curve.getPoint(tHead);
                        const pTail = d.curve.getPoint(tTail);
                        
                        const idx = k * 6; 
                        
                        arr[idx]   = pHead.x * currentScale * 0.5;
                        arr[idx+1] = pHead.y * currentScale * 0.5;
                        arr[idx+2] = pHead.z * currentScale * 0.8;
                        
                        arr[idx+3] = pTail.x * currentScale * 0.5;
                        arr[idx+4] = pTail.y * currentScale * 0.5;
                        arr[idx+5] = pTail.z * currentScale * 0.8;

                        if (d.t < 0 || (tHead === tTail && (tHead === 0 || tHead === 1))) {
                             arr[idx] = arr[idx+1] = arr[idx+2] = 0;
                             arr[idx+3] = arr[idx+4] = arr[idx+5] = 0;
                        }
                    }
                    posAttr.needsUpdate = true;
                    
                    const fade = Math.min(1, s.life) * s.health;
                    s.windLines.material.opacity = 0.4 * fade;
                }
                
                if(s.health > 0.6) s.core.material.color.setHex(0x110033);
                else if (s.health > 0.3) s.core.material.color.setHex(0x330011);
                else s.core.material.color.setHex(0x110000);

                const moveStep = s.dir.clone().multiplyScalar(s.speed * dt);
                s.pos.add(moveStep);
                s.group.position.copy(s.pos);

                const positions = s.particles.geometry.attributes.position.array;
                for(let j=0; j<positions.length; j+=3) {
                     positions[j] -= s.dir.x * 10 * dt + (Math.random()-0.5);
                     positions[j+1] -= s.dir.y * 10 * dt + (Math.random()-0.5);
                     positions[j+2] -= s.dir.z * 10 * dt + (Math.random()-0.5);
                     const dist = Math.sqrt(positions[j]**2 + positions[j+1]**2 + positions[j+2]**2);
                     if(dist > s.radius * 3) {
                         positions[j] = (Math.random()-0.5)*s.radius;
                         positions[j+1] = (Math.random()-0.5)*s.radius;
                         positions[j+2] = (Math.random()-0.5)*s.radius;
                     }
                }
                s.particles.geometry.attributes.position.needsUpdate = true;

                const opacity = Math.max(0, s.life / s.maxLife);
                s.core.material.opacity = opacity * 0.9 * s.health;
                s.rings.forEach(r => r.material.opacity = opacity * 0.8 * s.health);

                if(s.life <= 0) {
                    scene.remove(s.group);
                    shockwaves.splice(i, 1);
                    continue;
                }

                const rSq = (s.radius * s.health) ** 2; 
                const effectiveForce = s.force * s.health;
                
                // Box physics removed - no structures

                for(let j = 0; j < defenseEnemies.length; j++) {
                    const e = defenseEnemies[j];
                    if (e.hp <= 0) continue;
                    
                    const body = e.body;
                    const dx = body.position.x - s.pos.x;
                    const dy = body.position.y - s.pos.y;
                    const dz = body.position.z - s.pos.z;
                    const distSq = dx*dx + dy*dy + dz*dz;

                    if(distSq < rSq) {
                        body.wakeUp();

                        _shockDir.set(dx, dy, dz);
                        if (distSq > 0.0001) _shockDir.normalize();
                        else _shockDir.set(0, 1, 0);
                        
                        const forwardDir = new CANNON.Vec3(s.dir.x, s.dir.y, s.dir.z);
                        const forceDir = forwardDir.scale(0.4).vadd(_shockDir.scale(0.6));
                        forceDir.normalize();
                        
                        // FIXED: Increased knockback for shockwave
                        const enemyForceMult = 3.0; // Increased from 1.2 to 3.0 for lots of knockback
                        const forceMag = effectiveForce * dt * 4 * enemyForceMult; 
                        
                        body.applyImpulse(forceDir.scale(forceMag), body.position);

                        if (!s.hitBodies.has(body.id)) {
                            s.hitBodies.add(body.id);
                            damageEnemy(e, 215); // Fixed damage: 215 
                        }
                    }
                }

            }
        }

        // NEW: Boss shockwave ring on ground
        let bossShockwaveRings = [];
        
        function createBossShockwaveRing(x, z) {
            const ringGroup = new THREE.Group();
            ringGroup.position.set(x, 0.1, z); // Slightly above ground
            
            // Start small and expand to 3x larger size
            const startInnerRadius = 5.0; // Start small
            const startOuterRadius = 8.0; // Start small
            const maxInnerRadius = 90.0; // Max size (3x larger)
            const maxOuterRadius = 150.0; // Max size (3x larger)
            const thickness = 60.0; // Thickness when fully expanded
            
            // Main ring with detailed design - multiple segments for pattern
            const ringGeo = new THREE.RingGeometry(startInnerRadius, startOuterRadius, 128); // High detail
            const ringMat = new THREE.MeshStandardMaterial({ 
                color: 0xff0000, // Bright red
                emissive: 0xff4400, // Orange-red glow
                emissiveIntensity: 1.8,
                transparent: true, 
                opacity: 0.95,
                side: THREE.DoubleSide,
                metalness: 0.5,
                roughness: 0.1
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI / 2; // Lay flat on ground
            ringGroup.add(ring);
            
            // Inner edge detail ring (brighter, more intense)
            const innerEdgeGeo = new THREE.RingGeometry(startInnerRadius - 1.0, startInnerRadius, 128);
            const innerEdgeMat = new THREE.MeshStandardMaterial({ 
                color: 0xffff00, // Bright yellow
                emissive: 0xffff44, // Yellow glow
                emissiveIntensity: 2.0,
                transparent: true, 
                opacity: 0.9,
                side: THREE.DoubleSide,
                metalness: 0.7,
                roughness: 0.05
            });
            const innerEdge = new THREE.Mesh(innerEdgeGeo, innerEdgeMat);
            innerEdge.rotation.x = -Math.PI / 2;
            ringGroup.add(innerEdge);
            
            // Outer edge detail ring (darker, more defined)
            const outerEdgeGeo = new THREE.RingGeometry(startOuterRadius, startOuterRadius + 2.0, 128);
            const outerEdgeMat = new THREE.MeshStandardMaterial({ 
                color: 0xcc0000, // Darker red
                emissive: 0xff2200, // Deep red glow
                emissiveIntensity: 1.5,
                transparent: true, 
                opacity: 0.85,
                side: THREE.DoubleSide,
                metalness: 0.4,
                roughness: 0.15
            });
            const outerEdge = new THREE.Mesh(outerEdgeGeo, outerEdgeMat);
            outerEdge.rotation.x = -Math.PI / 2;
            ringGroup.add(outerEdge);
            
            // Subtle outer glow (simplified)
            const glowGeo = new THREE.RingGeometry(startOuterRadius + 2.0, startOuterRadius + 8.0, 64);
            const glowMat = new THREE.MeshBasicMaterial({ 
                color: 0xff6600, // Orange glow
                transparent: true, 
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const glowRing = new THREE.Mesh(glowGeo, glowMat);
            glowRing.rotation.x = -Math.PI / 2;
            ringGroup.add(glowRing);
            
            scene.add(ringGroup);
            
            bossShockwaveRings.push({
                group: ringGroup,
                ring: ring,
                innerEdge: innerEdge,
                outerEdge: outerEdge,
                glowRing: glowRing,
                x: x,
                z: z,
                startInnerRadius: startInnerRadius,
                startOuterRadius: startOuterRadius,
                maxInnerRadius: maxInnerRadius,
                maxOuterRadius: maxOuterRadius,
                maxRadius: 250, // Max outer radius to expand to (250 units)
                life: 2.5, // Expansion lifespan (2.5 seconds)
                maxLife: 2.5,
                hasHitPlayer: false,
                pulseTime: 0 // For pulsing animation
            });
            
            // FIXED: Play "boooom" sound effect
            SoundManager.playBossLanding();
        }
        
        function updateBossShockwaveRings(dt) {
            for (let i = bossShockwaveRings.length - 1; i >= 0; i--) {
                const ring = bossShockwaveRings[i];
                ring.life -= dt;
                ring.pulseTime += dt * 4.0; // Pulse speed
                
                if (ring.life <= 0) {
                    scene.remove(ring.group);
                    bossShockwaveRings.splice(i, 1);
                    continue;
                }
                
                // Expand from small start to large max size
                const t = 1.0 - (ring.life / ring.maxLife);
                const thickness = 60.0; // Thickness when fully expanded
                
                // Calculate current radii (expand from start to max)
                const currentOuterRadius = ring.startOuterRadius + (t * (ring.maxRadius - ring.startOuterRadius));
                const currentInnerRadius = ring.startInnerRadius + (t * ((ring.maxRadius - thickness) - ring.startInnerRadius));
                
                // Pulsing effect
                const pulse = 0.5 + 0.5 * Math.sin(ring.pulseTime);
                const pulse2 = 0.5 + 0.5 * Math.sin(ring.pulseTime * 1.3); // Different frequency for variety
                
                // Update main ring geometry
                if (ring.ring && ring.ring.geometry) {
                    ring.ring.geometry.dispose();
                    ring.ring.geometry = new THREE.RingGeometry(currentInnerRadius, currentOuterRadius, 128);
                }
                ring.ring.material.opacity = (0.95 + 0.05 * pulse) * (1.0 - t * 0.15);
                ring.ring.material.emissiveIntensity = 1.8 + 0.4 * pulse;
                
                // Update inner edge detail
                if (ring.innerEdge && ring.innerEdge.geometry) {
                    ring.innerEdge.geometry.dispose();
                    ring.innerEdge.geometry = new THREE.RingGeometry(currentInnerRadius - 2.0, currentInnerRadius, 128);
                }
                ring.innerEdge.material.opacity = (0.9 + 0.1 * pulse2) * (1.0 - t * 0.1);
                ring.innerEdge.material.emissiveIntensity = 2.0 + 0.5 * pulse2;
                
                // Update outer edge detail
                if (ring.outerEdge && ring.outerEdge.geometry) {
                    ring.outerEdge.geometry.dispose();
                    ring.outerEdge.geometry = new THREE.RingGeometry(currentOuterRadius, currentOuterRadius + 3.0, 128);
                }
                ring.outerEdge.material.opacity = (0.85 + 0.1 * pulse) * (1.0 - t * 0.2);
                ring.outerEdge.material.emissiveIntensity = 1.5 + 0.3 * pulse;
                
                // Update glow ring
                if (ring.glowRing && ring.glowRing.geometry) {
                    ring.glowRing.geometry.dispose();
                    ring.glowRing.geometry = new THREE.RingGeometry(currentOuterRadius + 3.0, currentOuterRadius + 12.0, 64);
                }
                ring.glowRing.material.opacity = (0.3 + 0.1 * pulse) * (1.0 - t * 0.4);
                
                // Store current radii for collision detection
                ring.currentOuterRadius = currentOuterRadius;
                ring.currentInnerRadius = currentInnerRadius;
                
                // Check if player is touching the RED ring (any part of it) - ONLY when on the floor
                if (!ring.hasHitPlayer && playerBody) {
                    const dx = playerBody.position.x - ring.x;
                    const dz = playerBody.position.z - ring.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    
                    // Only affect player when they're on the floor (not jumping/airborne)
                    // canJump is true when player is touching the ground
                    const isOnFloor = canJump && playerBody.position.y <= 3.5; // On ground and not too high
                    
                    // Check if player is accurately touching the red ring (between inner and outer radius) AND on the floor
                    // Player is hit if they're within the expanding ring area (outer radius) but outside the safe inner area
                    if (dist >= ring.currentInnerRadius && dist <= ring.currentOuterRadius && isOnFloor) {
                        // Player didn't jump over - push back and heal boss
                        if (!ring.hasHitPlayer) {
                            ring.hasHitPlayer = true;
                            
                            // Find boss and heal it
                            for (let j = 0; j < defenseEnemies.length; j++) {
                                const enemy = defenseEnemies[j];
                                if (enemy && enemy.isBoss && enemy.hp > 0) {
                                    const healAmount = enemy.maxHp * 0.25; // Heal 25%
                                    enemy.hp = Math.min(enemy.maxHp, enemy.hp + healAmount);
                                    if (typeof updateDefenseUI === 'function') {
                                        updateDefenseUI();
                                    }
                                    break;
                                }
                            }
                            
                            // UPDATED: Push player back 50-60 units away and 35-60 units high using impulses
                            if (dist > 0.1) {
                                const pushDir = new CANNON.Vec3(dx / dist, 0, dz / dist);
                                // Random distance: 70-85 units away (increased from 50-60)
                                const pushDistance = 70 + Math.random() * 15; // 70-85 units
                                // Random height: 50-75 units high (increased from 35-60)
                                const pushHeight = 50 + Math.random() * 25; // 50-75 units
                                
                                const playerMass = playerBody.mass || 1;
                                
                                // FIXED: Much stronger horizontal push - use higher multiplier
                                // Increase horizontal velocity significantly to ensure strong backward push
                                const horizontalVelocity = pushDistance * 3.5; // Much stronger (was 1.5)
                                const horizontalImpulse = pushDir.clone().scale(horizontalVelocity * playerMass);
                                
                                // Calculate impulse for vertical push (35-60 units high)
                                // v = sqrt(2gh) where g = 80, h = pushHeight
                                const verticalVelocity = Math.sqrt(2 * 80 * pushHeight);
                                const verticalImpulse = new CANNON.Vec3(0, verticalVelocity * playerMass, 0);
                                
                                // Apply both impulses - horizontal first, then vertical
                                playerBody.applyImpulse(horizontalImpulse, playerBody.position);
                                playerBody.applyImpulse(verticalImpulse, playerBody.position);
                                
                                // Also set velocity directly to ensure strong backward movement
                                playerBody.velocity.x += pushDir.x * horizontalVelocity * 0.5;
                                playerBody.velocity.z += pushDir.z * horizontalVelocity * 0.5;
                            } else {
                                // If player is exactly at center, push in random direction
                                const randomAngle = Math.random() * Math.PI * 2;
                                const pushDir = new CANNON.Vec3(
                                    Math.cos(randomAngle),
                                    0,
                                    Math.sin(randomAngle)
                                );
                                
                                // Random distance: 50-60 units away
                                const pushDistance = 50 + Math.random() * 10;
                                // Random height: 35-60 units high
                                const pushHeight = 35 + Math.random() * 25;
                                
                                const playerMass = playerBody.mass || 1;
                                // FIXED: Much stronger horizontal push
                                const horizontalVelocity = pushDistance * 3.5; // Much stronger (was 1.5)
                                const horizontalImpulse = pushDir.clone().scale(horizontalVelocity * playerMass);
                                const verticalVelocity = Math.sqrt(2 * 80 * pushHeight);
                                const verticalImpulse = new CANNON.Vec3(0, verticalVelocity * playerMass, 0);
                                
                                playerBody.applyImpulse(horizontalImpulse, playerBody.position);
                                playerBody.applyImpulse(verticalImpulse, playerBody.position);
                                
                                // Also set velocity directly to ensure strong backward movement
                                playerBody.velocity.x += pushDir.x * horizontalVelocity * 0.5;
                                playerBody.velocity.z += pushDir.z * horizontalVelocity * 0.5;
                            }
                        }
                    }
                }
            }
        }

        function createBlackHole(position, normal) {
            const bh = new THREE.Group();
            bh.position.copy(position);
            scene.add(bh);

            const coreGeo = new THREE.SphereGeometry(1, 32, 32);
            const coreMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const core = new THREE.Mesh(coreGeo, coreMat);
            bh.add(core);

            const horizonGeo = new THREE.SphereGeometry(1.2, 32, 32);
            const horizonMat = new THREE.MeshBasicMaterial({ 
                color: 0x220066, 
                transparent: true, 
                opacity: 0.8, 
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending
            });
            const horizon = new THREE.Mesh(horizonGeo, horizonMat);
            bh.add(horizon);

            const diskGeo = new THREE.TorusGeometry(3, 0.2, 16, 60);
            const diskMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
            const disk = new THREE.Mesh(diskGeo, diskMat);
            disk.rotation.x = Math.PI / 2;
            bh.add(disk);

            const disk2Geo = new THREE.TorusGeometry(1.8, 0.15, 16, 40);
            const disk2Mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending });
            const disk2 = new THREE.Mesh(disk2Geo, disk2Mat);
            disk2.rotation.x = Math.PI / 2.2; 
            bh.add(disk2);

            const pCount = 300;
            const pGeo = new THREE.BufferGeometry();
            const pPos = new Float32Array(pCount * 3);
            for(let i=0; i<pCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = 2 + Math.random() * 5;
                pPos[i*3] = Math.cos(angle) * r;
                pPos[i*3+1] = (Math.random() - 0.5) * 0.5; 
                pPos[i*3+2] = Math.sin(angle) * r;
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            const pMat = new THREE.PointsMaterial({ color: 0xaa00ff, size: 0.5, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
            const particles = new THREE.Points(pGeo, pMat);
            bh.add(particles);

            const jetGeo = new THREE.ConeGeometry(0.5, 8, 16, 1, true);
            const jetMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2, side: THREE.DoubleSide, blending: THREE.AdditiveBlending });
            
            const jet1 = new THREE.Mesh(jetGeo, jetMat);
            jet1.position.y = 4;
            bh.add(jet1);
            
            const jet2 = new THREE.Mesh(jetGeo, jetMat);
            jet2.position.y = -4;
            jet2.rotation.z = Math.PI;
            bh.add(jet2);

            const hum = SoundManager.createHum(40);
            if(hum) {
                hum.gain.gain.setTargetAtTime(0.15, SoundManager.ctx.currentTime, 0.5);
            }

            activeBlackHoles.push({
                group: bh,
                core: core,
                horizon: horizon,
                disk: disk,
                disk2: disk2, 
                particles: particles,
                jet1: jet1,
                jet2: jet2,
                hum: hum, 
                position: position,
                initialY: position.y, 
                age: 0, 
                maxLife: 60.0, 
                baseRadius: 0.5, 
                currentRadius: 0.5
            });
        }

        function updateBlackHoles(dt) {
            for (let i = activeBlackHoles.length - 1; i >= 0; i--) {
                const bh = activeBlackHoles[i];
                
                bh.age += dt;
                
                if (bh.age > bh.maxLife) {
                    scene.remove(bh.group);
                    if(bh.hum) {
                        bh.hum.gain.gain.setTargetAtTime(0, SoundManager.ctx.currentTime, 0.1);
                        const osc = bh.hum.osc;
                        setTimeout(() => osc.stop(), 200);
                    }
                    activeBlackHoles.splice(i, 1);
                    continue;
                }

                const t = bh.age / bh.maxLife;
                
                bh.currentRadius = bh.baseRadius + (t * t * 21.8); 

                const riseAmount = t * 30.0;
                bh.position.y = bh.initialY + riseAmount;
                bh.group.position.y = bh.position.y;

                const scale = bh.currentRadius;
                bh.core.scale.set(scale, scale, scale);
                bh.horizon.scale.set(scale*1.1, scale*1.1, scale*1.1);
                
                const diskScale = scale * 1.5;
                bh.disk.scale.set(diskScale, diskScale, 1);
                bh.disk.rotation.z += 5 * dt;

                const disk2Scale = scale * 1.0; 
                bh.disk2.scale.set(disk2Scale, disk2Scale, 1);
                bh.disk2.rotation.z -= 8 * dt; 
                bh.disk2.rotation.x = (Math.PI / 2.2) + Math.sin(bh.age * 2.0) * 0.2; 

                bh.particles.rotation.y += (1 + t*5) * dt;
                bh.particles.scale.set(scale, scale, scale);

                bh.jet1.scale.set(scale, scale, scale);
                bh.jet1.position.y = scale * 4;
                bh.jet2.scale.set(scale, scale, scale);
                bh.jet2.position.y = -scale * 4;

                const strengthRamp = Math.max(0, (t - 0.1) / 0.9); 
                const pullStrength = strengthRamp * strengthRamp; 

                const influenceDist = (bh.currentRadius * 3.6) + 8.0;
                const rangeSq = influenceDist * influenceDist;
                
                const forceBase = 30000 * pullStrength * bh.currentRadius; 
                
                // Box physics removed - no structures 
                
                // FIXED: Black hole deals 35 damage per second to enemies
                if (!bh.lastDamageTime) bh.lastDamageTime = 0;
                if (bh.age - bh.lastDamageTime >= 1.0) { // Every 1 second
                    bh.lastDamageTime = bh.age;
                    
                    for(let j = 0; j < defenseEnemies.length; j++) {
                        const e = defenseEnemies[j];
                        if (e.hp <= 0) continue;
                        
                        const dx = bh.position.x - e.body.position.x;
                        const dy = bh.position.y - e.body.position.y;
                        const dz = bh.position.z - e.body.position.z;
                        const distSq = dx*dx + dy*dy + dz*dz;
                        const influenceDist = (bh.currentRadius * 3.6) + 8.0;
                        const rangeSq = influenceDist * influenceDist;
                        
                        if (distSq < rangeSq) {
                            damageEnemy(e, 35); // 35 damage per second
                        }
                    }
                }
            }
        }


        function onKey(event, isDown) {
            
            if (event.code === 'KeyT') {
                isHoldingT = isDown;
            }

            if (isDown) {
                switch(event.code) { 
                    case 'KeyR': 
                        if (isPlacingBarrier) {
                            // Rotate 15 degrees (in radians)
                            placementRotationOffset += (15 * Math.PI / 180);
                        }
                        break;
                    case 'KeyQ': cycleAmmo(); break;
                    
                    // NEW: Toggle Shop
                    case 'KeyB': 
                        if (isDefenseMode) {
                            // NEW: Cancel placement if shop is toggled or B is pressed
                            if (isPlacingBarrier) cancelPlacement();
                            toggleShop();
                        }
                        break;

                    case 'KeyE': 
                        isEraserMode = !isEraserMode;
                        if(isEraserMode) {
                            statusEl.innerText = "ERASER MODE";
                            statusEl.classList.add('erasing');
                            sliderLabel.innerText = "Eraser Size:";
                            sliderInput.max = 75;
                            if(eraserRadius > 75) eraserRadius = 75;
                            sliderInput.value = eraserRadius;
                            sliderVal.innerText = eraserRadius;
                            sliderContainer.classList.add('visible');
                            eraserDistEl.classList.add('visible');
                            formSpeedContainer.classList.remove('visible');
                        } else {
                            statusEl.innerText = "READY";
                            statusEl.classList.remove('erasing');
                            sliderLabel.innerText = "Grab Size:";
                            sliderInput.max = 250;
                            sliderInput.value = CONFIG.grabRadius;
                            sliderVal.innerText = CONFIG.grabRadius;
                            if(currentAmmo !== 'raygun') sliderContainer.classList.remove('visible');
                            if(currentAmmo === 'raygun') formSpeedContainer.classList.add('visible');
                            else formSpeedContainer.classList.remove('visible');
                            eraserDistEl.classList.remove('visible');
                        }
                        break;
                    case 'KeyY': 
                        if(isEraserMode) {
                            eraserMaxDistance = Math.min(250, eraserMaxDistance + 5);
                            eraserDistVal.innerText = eraserMaxDistance;
                        }
                        break;
                    case 'KeyU': 
                        if(isEraserMode) {
                            eraserMaxDistance = Math.max(5, eraserMaxDistance - 5);
                            eraserDistVal.innerText = eraserMaxDistance;
                        }
                        break;
                    case 'Space': 
                        if(canJump) { 
                            // Apply faster, snappier jump with impulse for instant feel
                            const jumpImpulse = playerBody.mass * CONFIG.jumpForce * 2.5; // Much faster jump feel
                            playerBody.applyImpulse(new CANNON.Vec3(0, jumpImpulse, 0), playerBody.position);
                            canJump = false; 
                            SoundManager.playJump();
                        } 
                        break;
                    case 'Escape': 
                        if (isPlacingBarrier) {
                            cancelPlacement();
                        } else {
                            togglePause(); 
                        }
                        break;
                    case 'Tab': 
                        event.preventDefault();
                        uiControlsEl.style.opacity = (uiControlsEl.style.opacity === '0' ? '1' : '0'); 
                        break;
                }
            }
            if (event.code === 'ShiftLeft') {
                isSlowMo = isDown;
                slowMoEl.style.opacity = isDown ? 1 : 0;
            }
            switch(event.code) {
                case 'KeyW': moveState.forward = isDown; break;
                case 'KeyS': moveState.backward = isDown; break;
                case 'KeyA': moveState.left = isDown; break;
                case 'KeyD': moveState.right = isDown; break;
            }
        }

        function updatePlayerMovement(delta) {
            if (!isLocked || !playerBody || isPlayerPaused) return;

            const speedMultiplier = 1.0;

            const inputVector = new THREE.Vector3();
            if (moveState.forward) inputVector.z -= 1;
            if (moveState.backward) inputVector.z += 1;
            if (moveState.left) inputVector.x -= 1;
            if (moveState.right) inputVector.x += 1;
            
            const currentSpeed = CONFIG.moveSpeed * speedMultiplier;

            if (inputVector.lengthSq() > 0) {
                inputVector.normalize();
                const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); camDir.y = 0; camDir.normalize();
                const camRight = new THREE.Vector3(); camRight.crossVectors(camDir, camera.up).normalize();
                const moveDir = new THREE.Vector3(); moveDir.add(camDir.multiplyScalar(-inputVector.z)); moveDir.add(camRight.multiplyScalar(inputVector.x));
                playerBody.velocity.x = moveDir.x * currentSpeed; playerBody.velocity.z = moveDir.z * currentSpeed;
            } else {
                playerBody.velocity.x *= 0.8; playerBody.velocity.z *= 0.8;
            }
        }

        
        function createBeamVisual() {
            const count = 50;
            
            for(let i=0; i<4; i++) {
                const geo = new THREE.BufferGeometry().setFromPoints(Array(count).fill(new THREE.Vector3()));
                const mat = new THREE.LineBasicMaterial({ color: i%2===0 ? 0x00ffff : 0x0088ff, linewidth: 2, transparent: true, opacity: 0.6 });
                const line = new THREE.Line(geo, mat);
                line.frustumCulled = false; 
                line.visible = false;
                scene.add(line);
                beamStrands.push(line);
            }

            const geoC = new THREE.BufferGeometry().setFromPoints(Array(count).fill(new THREE.Vector3()));
            const matC = new THREE.PointsMaterial({ color: 0xffffff, size: 0.4, transparent: true, opacity: 0.8 });
            beamMeshCore = new THREE.Points(geoC, matC);
            beamMeshCore.frustumCulled = false; 
            beamMeshCore.visible = false;
            scene.add(beamMeshCore);
        }

        function updateBeam() {
            if(gravityConstraints.length > 0 && beamMeshCore.visible) {
                loadedBall.getWorldPosition(_v1); 
                _v1.y -= 0.5;
                
                _v2.copy(jointBody.position); 
                
                beamLag.lerp(_v2, 0.2); 
                
                const start = _v1.clone();
                const end = beamLag.clone();
                const diff = end.clone().sub(start);
                
                const dir = diff.clone().normalize();
                const up = new THREE.Vector3(0, 1, 0);
                const right = new THREE.Vector3().crossVectors(dir, up).normalize();
                if(right.lengthSq() === 0) right.set(1,0,0);
                const finalUp = new THREE.Vector3().crossVectors(right, dir).normalize();

                const segments = 50;
                const pointsCore = [];
                const strandsPoints = [[], [], [], []];
                const time = Date.now() * 0.02;

                for(let i=0; i<=segments; i++) {
                    const t = i / segments;
                    const pos = start.clone().add(diff.clone().multiplyScalar(t));
                    
                    pointsCore.push(pos.clone().add(new THREE.Vector3((Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2)));

                    const spiralRadius = 0.6 * Math.sin(t * Math.PI); 
                    
                    for(let s=0; s<4; s++) {
                        const phase = (s * Math.PI / 2) + time + (t * 20);
                        const off1 = right.clone().multiplyScalar(Math.cos(phase) * spiralRadius);
                        const off2 = finalUp.clone().multiplyScalar(Math.sin(phase) * spiralRadius);
                        strandsPoints[s].push(pos.clone().add(off1).add(off2));
                    }
                }
                
                beamMeshCore.geometry.setFromPoints(pointsCore);
                beamMeshCore.geometry.attributes.position.needsUpdate = true;

                for(let s=0; s<4; s++) {
                    beamStrands[s].geometry.setFromPoints(strandsPoints[s]);
                    beamStrands[s].geometry.attributes.position.needsUpdate = true;
                }
            }
        }

        function tryGrab() {
            raycaster.setFromCamera(centerScreen, camera);
            
            const intersects = raycaster.intersectObjects(collidables, true);
            
            if (intersects.length > 0) {
                const hit = intersects[0];
                if (hit.distance < 100) {
                    const hitPoint = new CANNON.Vec3(hit.point.x, hit.point.y, hit.point.z);
                    
                    let directHitBody = null;
                    let curr = hit.object;
                    while(curr) {
                        if (curr.userData && curr.userData.physicsBody) {
                            directHitBody = curr.userData.physicsBody;
                            break;
                        }
                        curr = curr.parent;
                    }

                    currentGrabDistance = hit.distance;
                    beamLag.copy(hit.point);
                    jointBody.position.copy(hitPoint);
                    jointBody.velocity.set(0,0,0);
                    grabRotation = 0;
                    jointBody.quaternion.set(0,0,0,1);
                    
                    const bodiesToGrab = [];
                    
                    if (directHitBody && directHitBody.userData && directHitBody.userData.isHeavyBall) {
                        bodiesToGrab.push(directHitBody);
                        const proj = projectiles.find(p => p.body === directHitBody);
                        if(proj && proj.timerId) clearTimeout(proj.timerId);
                    }
                    // Box grabbing removed - no structures

                    const count = bodiesToGrab.length;
                    if (count === 0) return; 

                    bodiesToGrab.sort((a, b) => {
                        const dA = a.position.distanceSquared(hitPoint);
                        const dB = b.position.distanceSquared(hitPoint);
                        return dA - dB;
                    });

                    const phi = Math.PI * (3 - Math.sqrt(5)); 
                    
                    const sphereRadius = Math.max(0, Math.sqrt(count) * CONFIG.boxSize * 0.37);

                    for(let i=0; i<count; i++) {
                        const body = bodiesToGrab[i];
                        body.wakeUp();
                        grabbedBodies.push(body);
                        
                        if (!body.userData) body.userData = {};
                        if (body.userData.originalGroup === undefined) {
                            body.userData.originalGroup = body.collisionFilterGroup;
                            body.userData.originalMask = body.collisionFilterMask;
                        }
                        
                        body.collisionFilterGroup = 2;
                        body.collisionFilterMask = 1;

                        const y = 1 - (i / (count - 1 + 0.0001)) * 2; 
                        const radiusAtY = Math.sqrt(1 - y * y); 
                        const theta = phi * i; 

                        const x = Math.cos(theta) * radiusAtY;
                        const z = Math.sin(theta) * radiusAtY;

                        const targetPivot = new CANNON.Vec3(
                            x * sphereRadius, 
                            y * sphereRadius, 
                            z * sphereRadius
                        );
                        
                        const initialPivot = new CANNON.Vec3();
                        jointBody.pointToLocalFrame(body.position, initialPivot);

                        const pivotB = new CANNON.Vec3(0, 0, 0);

                        const constraint = new CANNON.PointToPointConstraint(
                            jointBody, initialPivot, body, pivotB
                        );
                        
                        constraint.targetPivot = targetPivot;
                        
                        constraint.formationDelay = i * 1.1; 
                        
                        if (body.userData && body.userData.isHeavyBall) {
                            body.collisionFilterGroup = 2; 
                            body.collisionFilterMask = -1; 
                        }

                        world.addConstraint(constraint);
                        gravityConstraints.push(constraint);
                        
                        body.angularDamping = 0.9;
                        body.linearDamping = 0.5; 
                    }
                    
                    if (grabbedBodies.length > 0) {
                        beamStrands.forEach(b => b.visible = true);
                        beamMeshCore.visible = true;
                        loadedBall.visible = false;
                        SoundManager.playShoot('raygun'); 
                    }
                }
            }
        }

        function tryThrow() {
            if (gravityConstraints.length > 0) {
                grabbedBodies.forEach(b => {
                    b.angularDamping = 0.01; 
                    b.linearDamping = 0.01;
                    
                    b.collisionFilterGroup = 1;
                    b.collisionFilterMask = -1; 
                });

                gravityConstraints.forEach(c => world.removeConstraint(c));
                gravityConstraints = [];
                beamStrands.forEach(b => b.visible = false);
                beamMeshCore.visible = false;
                loadedBall.visible = true;
                grabbedBodies = [];
                
                currentGrabDistance = CONFIG.defaultGrabDistance;
            }
        }
        
        function updateGravityGun() {
            if (gravityConstraints.length > 0) {
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                
                const targetDist = CONFIG.defaultGrabDistance;
                
                let burden = 0;
                
                burden += grabbedBodies.length;

                grabbedBodies.forEach(b => {
                    if (b.userData && b.userData.isHeavyBall) {
                        burden += 50; 
                    }
                });

                let heaviness = 1.0;
                if (burden > 0) {
                    heaviness = 1.0 + (burden / 62.0);
                }
                
                const lerpFactor = 0.03 / heaviness;

                currentGrabDistance += (targetDist - currentGrabDistance) * lerpFactor;

                const targetPos = camera.position.clone().add(dir.multiplyScalar(currentGrabDistance)); 
                
                const currentPos = new THREE.Vector3().copy(jointBody.position);
                currentPos.lerp(targetPos, lerpFactor * 2); 

                jointBody.position.set(currentPos.x, currentPos.y, currentPos.z);
                
                grabRotation += 0.005; 
                
                const q = new CANNON.Quaternion();
                q.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), grabRotation);
                jointBody.quaternion.copy(q);

                jointBody.velocity.set(0,0,0);
                jointBody.angularVelocity.set(0,0,0);
                
                const formationSpeed = currentFormationSpeed; 
                
                gravityConstraints.forEach(c => {
                    if (c.formationDelay > 0) {
                        c.formationDelay -= 1; 
                    } else if (c.targetPivot) {
                        c.pivotA.lerp(c.targetPivot, formationSpeed, c.pivotA);
                    }
                });

                grabbedBodies.forEach(b => b.wakeUp());
                updateBeam();
            }
        }

        function createPlayer(material) {
            const radius = 1.5;
            const shape = new CANNON.Sphere(radius);
            playerBody = new CANNON.Body({ mass: 1, material: material, fixedRotation: true, allowSleep: false });
            playerBody.addShape(shape);
            playerBody.position.set(0, 5, 60);
            playerBody.linearDamping = 0.9;
            
            // FIXED: Set collision filters to ensure player collides with ground and boxes
            playerBody.collisionFilterGroup = 4; // Player group
            playerBody.collisionFilterMask = -1; // Collide with everything (ground, boxes, etc.) 
            
            playerBody.preStep = () => {
                if (!canJump) {
                    // Apply upward force when not on ground (for floating)
                    playerBody.applyForce(new CANNON.Vec3(0, 8, 0), playerBody.position);
                    
                    // Apply additional downward force when falling to make fall faster
                    if (playerBody.velocity.y < 0) {
                        const fallBoost = playerBody.mass * 80; // Increased to 80 for even faster falling
                        playerBody.applyForce(new CANNON.Vec3(0, -fallBoost, 0), playerBody.position);
                    }
                }
            };

            world.addBody(playerBody);
            playerBody.addEventListener('collide', (e) => {
                if(e.contact.bi.id === playerBody.id) e.contact.ni.negate(new CANNON.Vec3()).y > 0.5 ? canJump = true : null;
                else e.contact.ni.y > 0.5 ? canJump = true : null;
            });
        }

        function createLoadedBall() {
            loadedBall = new THREE.Group();
            
            const rayGroup = new THREE.Group();
            
            const rayCoreGeo = new THREE.IcosahedronGeometry(CONFIG.ballRadius * 0.7, 2);
            const rayCoreMat = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                blending: THREE.AdditiveBlending, 
                transparent: true, 
                opacity: 0.8 
            });
            const rayCore = new THREE.Mesh(rayCoreGeo, rayCoreMat);
            rayGroup.add(rayCore);
            
            const rayShellGeo = new THREE.IcosahedronGeometry(CONFIG.ballRadius * 0.85, 1);
            const rayShellMat = new THREE.MeshBasicMaterial({ 
                color: 0x00aaff, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            const rayShell = new THREE.Mesh(rayShellGeo, rayShellMat);
            rayGroup.add(rayShell);
            
            const coilGeo = new THREE.TorusGeometry(CONFIG.ballRadius * 0.4, 0.05, 8, 32);
            const coilMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, blending: THREE.AdditiveBlending });
            const rayCoil = new THREE.Mesh(coilGeo, coilMat);
            rayCoil.rotation.x = Math.PI / 2; 
            rayGroup.add(rayCoil);

            rayGroup.userData = { 
                core: rayCore, 
                shell: rayShell, 
                coil: rayCoil
            };
            
            rayGroup.visible = false;
            loadedBall.add(rayGroup);

            const heavyGroup = new THREE.Group();
            
            const heavyGeo = new THREE.IcosahedronGeometry(CONFIG.ballRadius, 1);
            const heavyMat = new THREE.MeshStandardMaterial({ 
                color: 0x4a5a6a, 
                metalness: 0.9, 
                roughness: 0.2,
                flatShading: true,
                // UPDATED: Enable transparency for fading effect
                transparent: true,
                opacity: 1.0
            });
            const heavyCore = new THREE.Mesh(heavyGeo, heavyMat);
            heavyGroup.add(heavyCore);

            const heavyCageGeo = new THREE.IcosahedronGeometry(CONFIG.ballRadius * 1.02, 1);
            const heavyCageMat = new THREE.MeshBasicMaterial({ 
                color: 0x000000, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.5 
            });
            const heavyCage = new THREE.Mesh(heavyCageGeo, heavyCageMat);
            heavyGroup.add(heavyCage);
            
            // NEW: Store references for animation
            heavyGroup.userData = { core: heavyCore, cage: heavyCage };

            heavyGroup.visible = true; 
            loadedBall.add(heavyGroup);

            const expGroup = new THREE.Group();

            const expCoreGeo = new THREE.IcosahedronGeometry(CONFIG.ballRadius * 0.8, 2);
            const expCoreMat = new THREE.MeshBasicMaterial({ 
                color: 0xff5500, 
                blending: THREE.AdditiveBlending 
            });
            const expCore = new THREE.Mesh(expCoreGeo, expCoreMat);
            expGroup.add(expCore);

            const expLight = new THREE.PointLight(0xffaa00, 2, 5);
            expGroup.add(expLight);

            const expShellGeo = new THREE.IcosahedronGeometry(CONFIG.ballRadius * 1.1, 0); 
            const expShellMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.6
            });
            const expShell = new THREE.Mesh(expShellGeo, expShellMat);
            expGroup.add(expShell);

            const expRingGeo = new THREE.TorusGeometry(CONFIG.ballRadius * 1.3, 0.05, 8, 24);
            const expRingMat = new THREE.MeshBasicMaterial({ color: 0xff8800 });
            
            const ring1 = new THREE.Mesh(expRingGeo, expRingMat);
            const ring2 = new THREE.Mesh(expRingGeo, expRingMat);
            ring2.rotation.y = Math.PI / 2;
            
            expGroup.add(ring1);
            expGroup.add(ring2);

            const fpCount = 50;
            const fpGeo = new THREE.BufferGeometry();
            const fpPos = new Float32Array(fpCount * 3);
            const fpSpeeds = [];
            for(let i=0; i<fpCount; i++) {
                fpPos[i*3] = (Math.random()-0.5)*0.5;
                fpPos[i*3+1] = (Math.random()-0.5)*0.5;
                fpPos[i*3+2] = (Math.random()-0.5)*0.5;
                fpSpeeds.push({
                    y: 0.5 + Math.random(),
                    angle: Math.random() * Math.PI * 2,
                    radius: 0.2 + Math.random() * 0.3
                });
            }
            fpGeo.setAttribute('position', new THREE.BufferAttribute(fpPos, 3));
            const fpMat = new THREE.PointsMaterial({ color: 0xff5500, size: 0.1, transparent: true, opacity: 0.8 });
            const fireParticles = new THREE.Points(fpGeo, fpMat);
            expGroup.add(fireParticles);
            
            expGroup.userData = { 
                light: expLight, 
                shell: expShell, 
                ring1: ring1, 
                ring2: ring2,
                fireParticles: fireParticles,
                fireSpeeds: fpSpeeds,
                time: 0
            };

            expGroup.visible = false;
            loadedBall.add(expGroup);

            const bhGroup = new THREE.Group(); 

            const bhGeo = new THREE.SphereGeometry(CONFIG.ballRadius, 32, 32);
            const bhMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.0, metalness: 1.0 });
            const bhMesh = new THREE.Mesh(bhGeo, bhMat);
            bhGroup.add(bhMesh);

            const glowGeo = new THREE.SphereGeometry(CONFIG.ballRadius * 1.1, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0x5500aa, wireframe: true, transparent: true, opacity: 0.4 });
            const glowMesh = new THREE.Mesh(glowGeo, glowMat);
            bhGroup.add(glowMesh);

            const bhRingGeo = new THREE.TorusGeometry(CONFIG.ballRadius * 1.3, 0.1, 8, 32);
            const bhRingMat = new THREE.MeshBasicMaterial({ color: 0xaa00ff, transparent: true, opacity: 0.8 });
            const orbitRing = new THREE.Mesh(bhRingGeo, bhRingMat);
            orbitRing.rotation.x = Math.PI / 2; 
            bhGroup.add(orbitRing);

            const ring2Geo = new THREE.TorusGeometry(CONFIG.ballRadius * 1.1, 0.08, 8, 32);
            const ring2Mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
            const orbitRing2 = new THREE.Mesh(ring2Geo, ring2Mat);
            orbitRing2.rotation.x = Math.PI / 2.2; 
            bhGroup.add(orbitRing2);

            const wpCount = 40;
            const wpGeo = new THREE.BufferGeometry();
            const wpPos = new Float32Array(wpCount * 3);
            for(let i=0; i<wpCount; i++) {
                const r = 2 + Math.random() * 2;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI * 2;
                wpPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                wpPos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                wpPos[i*3+2] = r * Math.cos(phi);
            }
            wpGeo.setAttribute('position', new THREE.BufferAttribute(wpPos, 3));
            const wpMat = new THREE.PointsMaterial({ color: 0xaa00ff, size: 0.08, transparent: true, opacity: 0.6 });
            const weaponParticles = new THREE.Points(wpGeo, wpMat);
            bhGroup.add(weaponParticles);
            
            bhGroup.userData = { orbitRing: orbitRing, orbitRing2: orbitRing2, weaponParticles: weaponParticles }; 

            bhGroup.visible = false;
            loadedBall.add(bhGroup);

            loadedBall.userData = {
                ammoMeshes: {
                    heavy: heavyGroup, 
                    explosive: expGroup, 
                    blackhole: bhGroup,
                    raygun: rayGroup
                }
            };

            // UPDATED: Z Position -5.5
            loadedBall.position.set(2.2, -1.4, -5.5); 
            camera.add(loadedBall);
            scene.add(camera); 
        }

        function clearAllStructures() {
            projectiles.forEach(p => {
                world.removeBody(p.body);
                scene.remove(p.mesh);
            });
            projectiles = [];
            
            if (defenseCoreBody) {
                world.removeBody(defenseCoreBody);
                if (defenseCoreMesh) {
                    scene.remove(defenseCoreMesh);
                    if(defenseCoreMesh.userData && defenseCoreMesh.userData.light) {
                        scene.remove(defenseCoreMesh.userData.light);
                    }
                }
                defenseCoreBody = null;
                defenseCoreMesh = null;
            }
            defenseEnemies.forEach(e => {
                world.removeBody(e.body);
                scene.remove(e.mesh);
            });
            defenseEnemies = [];
            
            // Clear turrets
            defenseTurrets.forEach(t => scene.remove(t));
            defenseTurrets = [];

            // NEW: Clear Barriers
            defenseBarriers.forEach(b => {
                world.removeBody(b.body);
                scene.remove(b.mesh);
                // Remove from collidables if present
                const idx = collidables.indexOf(b.mesh);
                if(idx > -1) collidables.splice(idx, 1);
            });
            defenseBarriers = [];

            explosions.forEach(ex => {
                if (ex.dispose) ex.dispose(); 
                else if (ex.group) scene.remove(ex.group);
            });
            explosions = [];
            
            activeBlackHoles.forEach(bh => {
                scene.remove(bh.group);
                if(bh.hum) {
                    bh.hum.gain.gain.value = 0;
                    bh.hum.osc.stop();
                }
            });
            activeBlackHoles = [];
            
            loadedBall.visible = true;
            if(gravityConstraints.length > 0) {
                gravityConstraints.forEach(c => world.removeConstraint(c));
                gravityConstraints = [];
                grabbedBodies = [];
                beamStrands.forEach(b => b.visible = false);
                beamMeshCore.visible = false;
            }
        }

        
        function setupAimingVisuals() {
            // OPTIMIZED: Reduced points from 150 to 40 for better performance
            const maxPoints = 40;
            const positions = new Float32Array(maxPoints * 3);
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            // SIMPLIFIED: Simple line material without transparency for better performance
            const material = new THREE.LineBasicMaterial({ 
                color: 0x00ff00, 
                linewidth: 2 
            });
            aimLine = new THREE.Line(geometry, material); 
            aimLine.frustumCulled = true; // Enable frustum culling for performance
            aimLine.renderOrder = 999; 
            aimLine.visible = false; 
            aimLine.userData.maxPoints = maxPoints; 
            scene.add(aimLine);

            const sphereGeo = new THREE.SphereGeometry(0.8, 16, 12); 
            const sphereMat = new THREE.PointsMaterial({ 
                color: 0x00ff00, 
                size: 0.15, 
                transparent: true,
                opacity: 0.8
            });
            aimMarker = new THREE.Points(sphereGeo, sphereMat); 
            aimMarker.visible = false; 
            scene.add(aimMarker);
        }

        function onMouseMove(event) {
            if (!isLocked || isPlayerPaused) return;
            const sensitivity = 0.002;
            camera.rotation.y -= event.movementX * sensitivity;
            camera.rotation.x -= event.movementY * sensitivity;
            const maxPolarAngle = Math.PI / 2 - 0.05;
            camera.rotation.x = Math.max(-maxPolarAngle, Math.min(maxPolarAngle, camera.rotation.x));
        }

        function updateAiming() {
            camera.updateMatrixWorld();
            const startPos = new THREE.Vector3(); loadedBall.getWorldPosition(startPos);
            raycaster.setFromCamera(centerScreen, camera);
            let targetDir = new THREE.Vector3();
            
            const hits = raycaster.intersectObjects(collidables);
            if(hits.length > 0) targetDir.subVectors(hits[0].point, startPos).normalize();
            else camera.getWorldDirection(targetDir);

            const simPos = _v1.copy(startPos);
            
            let speed = CONFIG.ballSpeed;
            if (currentAmmo === 'blackhole') speed *= 0.5;

            const simVel = _v2.copy(targetDir).multiplyScalar(speed);
            const gravity = new THREE.Vector3(0, world.gravity.y, 0); 
            
            // OPTIMIZED: Larger dt and fewer steps for better performance
            const dt = 0.05; // Increased from 0.02 to reduce calculations
            const maxSteps = aimLine.userData.maxPoints || 40;
            
            let hitFound = false; let hitPoint = new THREE.Vector3(); let hitNormal = new THREE.Vector3();
            
            const positions = aimLine.geometry.attributes.position.array;
            let pIndex = 0;
            
            positions[pIndex++] = simPos.x; positions[pIndex++] = simPos.y; positions[pIndex++] = simPos.z;

            let pointsCount = 1;
            let lastRaycastStep = -1; // Only raycast every few steps for performance

            for(let i=0; i<maxSteps; i++) {
                const prevPos = simPos.clone();
                
                simVel.add(gravity.clone().multiplyScalar(dt));
                simPos.add(simVel.clone().multiplyScalar(dt));
                
                positions[pIndex++] = simPos.x; positions[pIndex++] = simPos.y; positions[pIndex++] = simPos.z;
                pointsCount++;

                // OPTIMIZED: Only check collision every 3 steps to reduce raycasting
                if (i - lastRaycastStep >= 3 || i === maxSteps - 1) {
                    lastRaycastStep = i;

                const segmentDir = simPos.clone().sub(prevPos);
                const segmentLen = segmentDir.length(); 
                segmentDir.normalize();
                
                raycaster.set(prevPos, segmentDir);
               
                const segHits = raycaster.intersectObjects(collidables);
                let validHit = null;
                for(let hit of segHits) {
                        if(hit.distance <= segmentLen * 3) { // Account for larger steps
                        validHit = hit;
                        break;
                    }
                }

                if(validHit) {
                    hitFound = true; 
                    hitPoint.copy(validHit.point); 
                    hitNormal.copy(validHit.face.normal);
                    
                    positions[pIndex-3] = hitPoint.x; 
                    positions[pIndex-2] = hitPoint.y; 
                    positions[pIndex-1] = hitPoint.z;
                    break;
                    }
                }
                
                if (simPos.y < -100) break;
            }

            aimLine.geometry.setDrawRange(0, pointsCount);
            aimLine.geometry.attributes.position.needsUpdate = true;
            aimLine.visible = true;

            if(hitFound) {
                aimMarker.position.copy(hitPoint).add(hitNormal.clone().multiplyScalar(0.05));
                
                aimMarker.rotation.y += 0.02;
                aimMarker.rotation.z += 0.01;
                
                aimMarker.visible = true;
            } else {
                aimMarker.visible = false;
            }
        }

        function shoot() {
            SoundManager.stopHeavyCharge();

            let sizeMult = 1;
            let massMult = 1;
            let isMaxCharge = false; 
            
            // Calculate charge level for damage scaling - scales from 0 to 1.0 continuously
            // Damage scales from 20 (base) to 40 (2x) or 60 (3x) based on upgrade
            // Starts scaling immediately from first millisecond of charging
            let chargeLevel = 0;
            if (currentAmmo === 'heavy' && isChargingFire) {
                const duration = (Date.now() - fireChargeStart); // Duration in milliseconds
                // Scale from 0 to 1.0 over 2.5 seconds (2500ms)
                chargeLevel = Math.min(duration / 2500, 1.0);
                
                // Calculate size/mass multipliers (for visual/physics scaling)
                // Size/mass scaling still uses the old timing (starts after 0.3s)
                const durationSeconds = duration / 1000;
                if (durationSeconds > 0.3) {
                    const t = Math.min((durationSeconds - 0.3) / 2.2, 1.0);
                    sizeMult = 1 + (t * 2); 
                    massMult = 1 + (t * 2); 
                    if (t > 0.95) isMaxCharge = true;
                }
            }
            
            // Reset charging state after calculating everything
            isChargingFire = false;
            
            // NEW: Apply Level Multiplier for Heavy Ammo
            // +25% Mass per level
            if (currentAmmo === 'heavy') {
                const levelMult = 1 + ((massCannonLevel - 1) * 0.25);
                massMult *= levelMult;
                
                // Slight visual size increase for high levels (capped)
                if (massCannonLevel > 1) {
                    sizeMult *= Math.min(1.5, 1 + ((massCannonLevel - 1) * 0.05));
                }
            }

            const startPos = new THREE.Vector3(); 
            loadedBall.getWorldPosition(startPos);

            isAiming = false; aimLine.visible = false; aimMarker.visible = false;
            statusEl.innerText = "FIRED"; statusEl.classList.remove('aiming');
            loadedBall.visible = false;
            
            // NEW: Reset Opacity immediately after firing
            if (loadedBall.userData.ammoMeshes && loadedBall.userData.ammoMeshes.heavy.userData.core) {
                loadedBall.userData.ammoMeshes.heavy.userData.core.material.opacity = 1.0;
                loadedBall.userData.ammoMeshes.heavy.userData.cage.material.opacity = 0.5;
            }
            
            loadedBall.scale.set(1, 1, 1);
            // UPDATED: Z Position -5.5
            loadedBall.position.set(2.2, -1.4, -5.5);

            SoundManager.playShoot(currentAmmo);

            screenShake = 0.3 * sizeMult; 

            raycaster.setFromCamera(centerScreen, camera);
            let shootDir = new THREE.Vector3();
            
            const hits = raycaster.intersectObjects(collidables);
            if(hits.length > 0) shootDir.subVectors(hits[0].point, startPos).normalize();
            else camera.getWorldDirection(shootDir);

            if (currentAmmo === 'explosive') {
                const velocity = new CANNON.Vec3(shootDir.x, shootDir.y, shootDir.z).scale(CONFIG.ballSpeed);
                spawnPhysicsBall(startPos, velocity, CONFIG.ballRadius, CONFIG.ballMass, 'explosive');
                // MULTIPLAYER: Send projectile to network
                if (socket && socket.connected) {
                    socket.emit('shoot', {
                        position: { x: startPos.x, y: startPos.y, z: startPos.z },
                        velocity: { x: velocity.x, y: velocity.y, z: velocity.z },
                        radius: CONFIG.ballRadius,
                        mass: CONFIG.ballMass,
                        ammoType: 'explosive',
                        chargeLevel: 0
                    });
                }
            } else if (currentAmmo === 'blackhole') {
                const velocity = new CANNON.Vec3(shootDir.x, shootDir.y, shootDir.z).scale(CONFIG.ballSpeed * 0.5); 
                spawnPhysicsBall(startPos, velocity, CONFIG.ballRadius, CONFIG.ballMass, 'blackhole');
                // MULTIPLAYER: Send projectile to network
                if (socket && socket.connected) {
                    socket.emit('shoot', {
                        position: { x: startPos.x, y: startPos.y, z: startPos.z },
                        velocity: { x: velocity.x, y: velocity.y, z: velocity.z },
                        radius: CONFIG.ballRadius,
                        mass: CONFIG.ballMass,
                        ammoType: 'blackhole',
                        chargeLevel: 0
                    });
                }
            } else {
                // Use chargeLevel calculated at the start of shoot() function
                // chargeLevel is already calculated and isChargingFire is already reset
                // If not charging, chargeLevel is 0, which gives base damage (20)
                const velocity = new CANNON.Vec3(shootDir.x, shootDir.y, shootDir.z).scale(CONFIG.ballSpeed);
                spawnPhysicsBall(startPos, velocity, CONFIG.ballRadius * sizeMult, CONFIG.ballMass * massMult, 'heavy', isMaxCharge, chargeLevel);
                // MULTIPLAYER: Send projectile to network
                if (socket && socket.connected) {
                    socket.emit('shoot', {
                        position: { x: startPos.x, y: startPos.y, z: startPos.z },
                        velocity: { x: velocity.x, y: velocity.y, z: velocity.z },
                        radius: CONFIG.ballRadius * sizeMult,
                        mass: CONFIG.ballMass * massMult,
                        ammoType: 'heavy',
                        chargeLevel: chargeLevel
                    });
                }
            }
            
            setTimeout(() => { if(isLocked && currentAmmo !== 'shockwave') { statusEl.innerText = "READY"; loadedBall.visible = true; } }, 500);
        }

        function spawnPhysicsBall(pos, velocity, radius, mass, ammoType, isMaxCharge = false, chargeLevel = 0) {
            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({ mass: mass });
            body.addShape(shape);
            body.position.set(pos.x, pos.y, pos.z);
            body.velocity.copy(velocity);
            
            // FIXED: Add damping to prevent glitching when bouncing off structures
            body.linearDamping = 0.2; // Increased damping to prevent excessive bouncing and glitching
            body.angularDamping = 0.3; // Increased angular damping for smoother rotation
            
            // Projectiles collide with boxes, enemies, and ground, but NOT player
            // Group 1 = boxes, Group 2 = projectiles, Group 3 = enemies, Group 4 = player
            body.collisionFilterGroup = 2; // Projectiles group
            body.collisionFilterMask = -1 & ~4; // Collide with everything except player (group 4)
            
            let mesh;

            if (ammoType === 'heavy' && isMaxCharge) {
                body.userData = { 
                    canGrab: true,
                    isHeavyBall: true 
                };
            }

            if(ammoType === 'explosive') {
                let hasExploded = false;
                body.addEventListener('collide', (e) => {
                    if(!hasExploded && e.contact.getImpactVelocityAlongNormal() > 10) {
                        hasExploded = true;
                        explode(body.position);
                        
                        setTimeout(() => {
                            world.removeBody(body);
                            if(mesh) {
                                if(mesh.userData.cleanup) mesh.userData.cleanup(); 
                                scene.remove(mesh);
                            }
                            const idx = projectiles.findIndex(p => p.body === body);
                            if (idx > -1) projectiles.splice(idx, 1);
                        }, 0);
                    }
                });
                body.userData = { explosive: true };
            } else if (ammoType === 'blackhole') {
                 let triggered = false;
                 body.addEventListener('collide', (e) => {
                     if (!triggered) {
                         triggered = true;
                         SoundManager.playExplosion(); 
                         
                         const idx = projectiles.findIndex(p => p.body === body);
                         if (idx > -1) {
                             if (projectiles[idx].mesh) scene.remove(projectiles[idx].mesh);
                             world.removeBody(projectiles[idx].body);
                             projectiles.splice(idx, 1);
                         }
                         const contactNormal = new THREE.Vector3(e.contact.ni.x, e.contact.ni.y, e.contact.ni.z);
                         if(e.contact.bi.id === body.id) contactNormal.negate();
                         
                         const spawnPos = new THREE.Vector3(body.position.x, body.position.y, body.position.z).add(contactNormal.multiplyScalar(2));
                         createBlackHole(spawnPos, contactNormal);
                     }
                 });
            } else if (ammoType === 'heavy') {
                // FIXED: Add collision event listener for heavy projectiles
                // This ensures enemies get hit from any angle, even when rolling on ground
                body.addEventListener('collide', (e) => {
                    const otherBody = (e.contact.bi === body) ? e.contact.bj : e.contact.bi;
                    
                    // Skip ground and box collisions (projectiles pass through boxes)
                    if (otherBody.userData && otherBody.userData.isGround) return;
                    
                    // SEPARATED: Only check enemies in defense mode (boxes are handled via proximity force)
                    if (!isDefenseMode) return;
                    
                    // Find the enemy that this body belongs to
                    for (let i = 0; i < defenseEnemies.length; i++) {
                        const enemy = defenseEnemies[i];
                        if (!enemy || !enemy.body || enemy.hp <= 0) continue;
                        
                        if (enemy.body === otherBody) {
                            // Found the enemy! Check if we've already hit it
                            if (!body.userData.hitEnemies) body.userData.hitEnemies = new Set();
                            const enemyId = enemy.body.id || i;
                            
                            if (body.userData.hitEnemies.has(enemyId)) {
                                return; // Already hit this enemy
                            }
                            
                            // Mark as hit
                            body.userData.hitEnemies.add(enemyId);
                            
                            // Calculate damage based on charge level
                            const chargeLevel = (body.userData.chargeLevel !== undefined) ? body.userData.chargeLevel : 0;
                            const baseDmg = 20;
                            // Max damage: 2x (40) without upgrade, 3x (60) with upgrade
                            const maxDmg = hasMaxChargeUpgrade ? 60 : 40;
                            const dmg = baseDmg + (chargeLevel * (maxDmg - baseDmg));
                            
                            // Apply damage
                            if (typeof damageEnemy === 'function') {
                                damageEnemy(enemy, dmg);
                            }
                            
                            break; // Found and damaged, exit loop
                        }
                    }
                });
                
                // Store charge level in body userData for collision handler
                if (!body.userData) body.userData = {};
                body.userData.chargeLevel = chargeLevel;
            }
            
            // FIXED: Add collision listener for smooth box interactions and structure collapse
            // This ensures boxes wake up and structures collapse smoothly when hit
            body.addEventListener('collide', (e) => {
                const otherBody = (e.contact.bi === body) ? e.contact.bj : e.contact.bi;
                
                // Skip ground and player collisions
                if (otherBody.userData && (otherBody.userData.isGround || otherBody === playerBody)) return;
                
                // Box collision handling removed - no structures
            });

            world.addBody(body);

            if (ammoType === 'heavy') {
                const group = new THREE.Group();
                
                const geo = new THREE.IcosahedronGeometry(radius, 1);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: 0x4a5a6a, 
                    metalness: 0.9, 
                    roughness: 0.2,
                    flatShading: true
                });
                const coreMesh = new THREE.Mesh(geo, mat);
                group.add(coreMesh);

                const cageGeo = new THREE.IcosahedronGeometry(radius * 1.02, 1);
                const cageMat = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true, opacity: 0.5 });
                const cageMesh = new THREE.Mesh(cageGeo, cageMat);
                group.add(cageMesh);
                
                mesh = group;
                mesh.userData.wireframeMesh = cageMesh;
                mesh.userData.coreMesh = coreMesh;
                mesh.userData.physicsBody = body;

                mesh.userData.physicsBody = body;

            } else if (ammoType === 'explosive') {
                const group = new THREE.Group();

                const coreGeo = new THREE.IcosahedronGeometry(radius * 0.8, 2);
                const coreMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                group.add(new THREE.Mesh(coreGeo, coreMat));

                const spikeGeo = new THREE.IcosahedronGeometry(radius * 1.2, 0);
                const spikeMat = new THREE.MeshBasicMaterial({ color: 0xff3300, wireframe: true });
                const spike = new THREE.Mesh(spikeGeo, spikeMat);
                group.add(spike);

                const ringGeo = new THREE.TorusGeometry(radius * 1.4, 0.05, 8, 16);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xff8800 });
                const ring1 = new THREE.Mesh(ringGeo, ringMat);
                const ring2 = new THREE.Mesh(ringGeo, ringMat);
                ring2.rotation.y = Math.PI / 2;
                group.add(ring1);
                group.add(ring2);

                const light = new THREE.PointLight(0xff5500, 2, 10);
                group.add(light);
                
                const trailGeo = new THREE.BufferGeometry();
                const trailCount = 30;
                const trailPos = new Float32Array(trailCount * 3);
                for(let i=0; i<trailCount*3; i++) trailPos[i] = 99999;
                
                trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
                const trailMat = new THREE.PointsMaterial({ 
                    color: 0xffaa00, 
                    size: 0.8, 
                    transparent: true, 
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending 
                });
                const trail = new THREE.Points(trailGeo, trailMat);
                scene.add(trail);

                let t = 0;
                let trailIdx = 0;
                
                group.userData = { 
                    update: (dt) => {
                        t += dt * 10;
                        spike.rotation.x = t;
                        spike.rotation.y = t * 0.5;
                        ring1.rotation.x = t * 2;
                        ring2.rotation.y = t * 2;
                        light.intensity = 2 + Math.sin(t) * 1;

                        const currentPos = group.position;
                        trailPos[trailIdx*3] = currentPos.x + (Math.random()-0.5);
                        trailPos[trailIdx*3+1] = currentPos.y + (Math.random()-0.5);
                        trailPos[trailIdx*3+2] = currentPos.z + (Math.random()-0.5);
                        trailIdx = (trailIdx + 1) % trailCount;
                        trail.geometry.attributes.position.needsUpdate = true;
                    },
                    cleanup: () => {
                        scene.remove(trail);
                    }
                };

                mesh = group;

            } else if (ammoType === 'blackhole') {
                 const geo = new THREE.SphereGeometry(radius, 16, 16);
                 const mat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                 mesh = new THREE.Mesh(geo, mat);
                 const gGeo = new THREE.SphereGeometry(radius*1.2, 8, 8);
                 const gMat = new THREE.MeshBasicMaterial({ color: 0x8800ff, wireframe: true });
                 mesh.add(new THREE.Mesh(gGeo, gMat));
                 
                 mesh.userData.physicsBody = body;
            } else {
                 const geo = new THREE.SphereGeometry(radius, 32, 32);
                 const mat = new THREE.MeshStandardMaterial({ color: 0xffffff });
                 mesh = new THREE.Mesh(geo, mat);
                 mesh.userData.physicsBody = body;
            }

            mesh.castShadow = true;
            scene.add(mesh);
            
            if (body.userData && body.userData.canGrab) {
                collidables.push(mesh);
            }
            
            // FIXED: Track which enemies this projectile has hit to prevent multiple hits
            // FIXED: Track which enemies this projectile has hit to prevent multiple hits
            // Store charge level for damage calculation
            const proj = { body: body, mesh: mesh, timerId: null, hitEnemies: new Set(), chargeLevel: chargeLevel || 0 };
            projectiles.push(proj);
            
            proj.timerId = setTimeout(() => {
                const idx = projectiles.indexOf(proj);
                if (idx > -1) {
                    world.removeBody(proj.body);
                    if(proj.mesh.userData.cleanup) proj.mesh.userData.cleanup(); 
                    scene.remove(proj.mesh);
                    
                    if (proj.body.userData && proj.body.userData.canGrab) {
                        const cIdx = collidables.indexOf(proj.mesh);
                        if(cIdx > -1) collidables.splice(cIdx, 1);
                    }

                    projectiles.splice(idx, 1);
                }
            }, 4000);
        }

        
        function explode(pos) {
            // FIXED: 3 second cooldown for explosions
            const now = Date.now();
            if (now - lastExplosionTime < 3000) return; // 3 second cooldown
            lastExplosionTime = now;
            
            SoundManager.playExplosion();

            const blastRadius = 20;
            const blastRadiusSq = blastRadius * blastRadius; 
            const blastForce = 1500;

            createRedesignedExplosion(pos, 1.0);


            for(let i = defenseEnemies.length - 1; i >= 0; i--) {
                const e = defenseEnemies[i];
                const distSq = e.body.position.distanceSquared(pos);
                if (distSq < blastRadiusSq) {
                    e.body.wakeUp();
                    const dir = e.body.position.vsub(pos);
                    dir.normalize();
                    let force = blastForce * (1 - (distSq / blastRadiusSq));
                    if (e.isSplitter) force *= 0.1; // Splitters get 90% less knockback from explosives
                    e.body.applyImpulse(dir.scale(force * 2), e.body.position); 
                    
                    damageEnemy(e, 75); // Changed from 125 to 75 
                }
            }
        }

        // NEW: Special effect when splitter dies and splits apart
        function createSplitterDeathEffect(pos, radius) {
            const group = new THREE.Group();
            group.position.copy(pos);
            scene.add(group);

            // 1. Pinkish flash core
            const flashGeo = new THREE.SphereGeometry(radius * 0.5, 32, 32);
            const flashMat = new THREE.MeshBasicMaterial({ 
                color: 0xff88cc, 
                transparent: true, 
                opacity: 1,
                depthTest: false,
                blending: THREE.AdditiveBlending
            });
            const flash = new THREE.Mesh(flashGeo, flashMat);
            flash.scale.set(0.1, 0.1, 0.1);
            group.add(flash);

            // 2. Expanding pink energy rings
            const ringGeo = new THREE.TorusGeometry(radius * 0.8, radius * 0.1, 16, 64);
            const ringMat = new THREE.MeshBasicMaterial({ 
                color: 0xff88cc,
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            
            const rings = [];
            for (let i = 0; i < 3; i++) {
                const ring = new THREE.Mesh(ringGeo, ringMat.clone());
                ring.rotation.x = Math.PI / 2;
                ring.rotation.y = (i / 3) * Math.PI * 2;
                ring.scale.set(0.1, 0.1, 0.1);
                group.add(ring);
                rings.push(ring);
            }

            // 3. Pink energy particles bursting outward
            const particleCount = 30;
            const particleGeo = new THREE.BufferGeometry();
            const particlePos = new Float32Array(particleCount * 3);
            const particleSizes = new Float32Array(particleCount);
            const particleVel = [];
            
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const speed = 5 + Math.random() * 10;
                
                particlePos[i * 3] = 0;
                particlePos[i * 3 + 1] = 0;
                particlePos[i * 3 + 2] = 0;
                
                particleSizes[i] = radius * 0.1 + Math.random() * radius * 0.1;
                
                particleVel.push({
                    x: Math.sin(phi) * Math.cos(angle) * speed,
                    y: Math.cos(phi) * speed,
                    z: Math.sin(phi) * Math.sin(angle) * speed
                });
            }
            
            particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePos, 3));
            particleGeo.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
            
            const particleMat = new THREE.PointsMaterial({ 
                color: 0xffaadd,
                size: radius * 0.15,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });
            const particles = new THREE.Points(particleGeo, particleMat);
            group.add(particles);

            // 4. Crystalline shards
            const shardCount = 12;
            const shards = [];
            const shardGeo = new THREE.ConeGeometry(radius * 0.15, radius * 0.4, 6);
            const shardMat = new THREE.MeshBasicMaterial({ 
                color: 0xff88cc,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });
            
            for (let i = 0; i < shardCount; i++) {
                const shard = new THREE.Mesh(shardGeo, shardMat.clone());
                const angle = (i / shardCount) * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                shard.position.set(
                    Math.sin(phi) * Math.cos(angle) * radius * 0.5,
                    Math.cos(phi) * radius * 0.5,
                    Math.sin(phi) * Math.sin(angle) * radius * 0.5
                );
                shard.lookAt(shard.position.clone().normalize().multiplyScalar(radius * 2));
                group.add(shard);
                shards.push({
                    mesh: shard,
                    vel: new THREE.Vector3(
                        Math.sin(phi) * Math.cos(angle) * (3 + Math.random() * 5),
                        Math.cos(phi) * (3 + Math.random() * 5),
                        Math.sin(phi) * Math.sin(angle) * (3 + Math.random() * 5)
                    ),
                    rot: new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10
                    )
                });
            }

            // Animation
            let time = 0;
            const duration = 1.5;
            const update = () => {
                time += 0.016;
                const t = Math.min(time / duration, 1);
                const easeOut = 1 - Math.pow(1 - t, 3);

                // Flash expands and fades
                flash.scale.setScalar(0.1 + easeOut * 3);
                flash.material.opacity = 1 - t;

                // Rings expand
                rings.forEach((ring, i) => {
                    ring.scale.setScalar(0.1 + easeOut * 4);
                    ring.material.opacity = (0.8 - t * 0.8) * (1 - i * 0.2);
                    ring.rotation.z += 0.02;
                });

                // Particles burst outward
                for (let i = 0; i < particleCount; i++) {
                    const vel = particleVel[i];
                    particlePos[i * 3] += vel.x * 0.016;
                    particlePos[i * 3 + 1] += vel.y * 0.016;
                    particlePos[i * 3 + 2] += vel.z * 0.016;
                }
                particleGeo.attributes.position.needsUpdate = true;
                particles.material.opacity = 1 - t;

                // Shards fly outward
                shards.forEach(shard => {
                    shard.mesh.position.add(shard.vel.clone().multiplyScalar(0.016));
                    shard.mesh.rotation.x += shard.rot.x * 0.016;
                    shard.mesh.rotation.y += shard.rot.y * 0.016;
                    shard.mesh.rotation.z += shard.rot.z * 0.016;
                    shard.mesh.material.opacity = 0.9 - t;
                });

                if (t < 1) {
                    requestAnimationFrame(update);
                } else {
                    scene.remove(group);
                    flash.geometry.dispose();
                    flash.material.dispose();
                    rings.forEach(r => { r.geometry.dispose(); r.material.dispose(); });
                    particleGeo.dispose();
                    particleMat.dispose();
                    shards.forEach(s => { s.mesh.geometry.dispose(); s.mesh.material.dispose(); });
                }
            };
            update();
        }

        function createRedesignedExplosion(pos, scale = 1.0) {
            const group = new THREE.Group();
            group.position.copy(pos);
            scene.add(group);

            const flashGeo = new THREE.SphereGeometry(1 * scale, 16, 16);
            const flashMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffaa, 
                transparent: true, 
                opacity: 1,
                depthTest: false,
                blending: THREE.AdditiveBlending
            });
            const flash = new THREE.Mesh(flashGeo, flashMat);
            flash.scale.set(0.1, 0.1, 0.1);
            group.add(flash);

            const waveGeo = new THREE.SphereGeometry(1 * scale, 32, 32);
            const waveMat = new THREE.MeshBasicMaterial({ 
                color: 0xff5500,
                transparent: true, 
                opacity: 0.6,
                wireframe: true,
                blending: THREE.AdditiveBlending
            });
            const wave = new THREE.Mesh(waveGeo, waveMat);
            wave.scale.set(0.1, 0.1, 0.1);
            group.add(wave);

            const smokeCount = Math.floor(400 * scale);
            const sparkCount = Math.floor(250 * scale);
            const debrisCount = Math.floor(60 * scale);

            const smokeGeo = new THREE.BufferGeometry();
            const smokePos = new Float32Array(smokeCount * 3);
            const smokeSizes = new Float32Array(smokeCount);
            const smokeVel = [];

            for(let i=0; i<smokeCount; i++) {
                smokePos[i*3] = (Math.random()-0.5)*2 * scale;
                smokePos[i*3+1] = (Math.random()-0.5)*2 * scale;
                smokePos[i*3+2] = (Math.random()-0.5)*2 * scale;
                smokeSizes[i] = (5 + Math.random() * 15) * scale;
                
                const v = new THREE.Vector3(Math.random()-0.5, Math.random()*0.5, Math.random()-0.5);
                v.normalize().multiplyScalar((10 + Math.random() * 30) * scale);
                smokeVel.push(v);
            }
            smokeGeo.setAttribute('position', new THREE.BufferAttribute(smokePos, 3));
            smokeGeo.setAttribute('size', new THREE.BufferAttribute(smokeSizes, 1));
            
            const smokeMat = new THREE.PointsMaterial({ 
                color: 0xff3300, 
                map: smokeTexture, 
                size: 1, 
                transparent: true, 
                opacity: 0.8, 
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                vertexColors: false
            });
            smokeMat.onBeforeCompile = (shader) => {
                shader.vertexShader = shader.vertexShader.replace(
                    'gl_PointSize = size;',
                    'gl_PointSize = size * ( 300.0 / -mvPosition.z );' 
                );
            };
            const smokeParticles = new THREE.Points(smokeGeo, smokeMat);
            group.add(smokeParticles);

            const sparkGeo = new THREE.BufferGeometry();
            const sparkPos = new Float32Array(sparkCount * 3);
            const sparkVel = [];
            for(let i=0; i<sparkCount; i++) {
                const v = new THREE.Vector3(Math.random()-0.5, Math.random()*0.5, Math.random()-0.5); 
                v.normalize().multiplyScalar((30 + Math.random() * 50) * scale);
                sparkVel.push(v);
            }
            sparkGeo.setAttribute('position', new THREE.BufferAttribute(sparkPos, 3));
            const sparkMat = new THREE.PointsMaterial({ 
                color: 0xffff00, 
                size: 0.5 * scale, 
                transparent: true, 
                blending: THREE.AdditiveBlending 
            });
            const sparks = new THREE.Points(sparkGeo, sparkMat);
            group.add(sparks);

            const debrisGeo = new THREE.BufferGeometry();
            const debrisPos = new Float32Array(debrisCount * 3);
            const debrisVel = [];
            for(let i=0; i<debrisCount; i++) {
                debrisPos[i*3] = (Math.random()-0.5)*1 * scale;
                debrisPos[i*3+1] = (Math.random()-0.5)*1 * scale;
                debrisPos[i*3+2] = (Math.random()-0.5)*1 * scale;
                
                const v = new THREE.Vector3(Math.random()-0.5, Math.random()*0.8, Math.random()-0.5);
                v.normalize().multiplyScalar((20 + Math.random() * 40) * scale);
                debrisVel.push(v);
            }
            debrisGeo.setAttribute('position', new THREE.BufferAttribute(debrisPos, 3));
            const debrisMat = new THREE.PointsMaterial({
                color: 0x333333, 
                size: 1.5 * scale,
                transparent: false, 
            });
            const debris = new THREE.Points(debrisGeo, debrisMat);
            group.add(debris);

            const light = new THREE.PointLight(0xff5500, 50 * scale, 60 * scale, 2);
            group.add(light);

            explosions.push({
                group: group,
                flash: flash,
                wave: wave,
                smoke: smokeParticles,
                sparks: sparks,
                debris: debris,
                light: light,
                smokeVel: smokeVel,
                sparkVel: sparkVel,
                debrisVel: debrisVel,
                age: 0,
                life: 1.5, 
                update: function(dt) {
                    this.age += dt;
                    const p = this.age / this.life;
                    const easeOut = 1 - (1-p)*(1-p);
                    const easeIn = p*p;

                    const flashP = Math.min(1, this.age / 0.2);
                    this.flash.scale.setScalar((1 + flashP * 10) * scale);
                    this.flash.material.opacity = 1 - flashP;

                    this.wave.scale.setScalar((1 + easeOut * 50) * scale);
                    this.wave.material.opacity = (1 - p) * 0.6;
                    this.wave.rotation.y += dt * 5;

                    const sPos = this.smoke.geometry.attributes.position.array;
                    const sSizes = this.smoke.geometry.attributes.size.array;
                    for(let i=0; i<smokeCount; i++) {
                        sPos[i*3]   += this.smokeVel[i].x * dt * (1-p);
                        sPos[i*3+1] += this.smokeVel[i].y * dt * (1-p) + dt * 5; 
                        sPos[i*3+2] += this.smokeVel[i].z * dt * (1-p);
                        sSizes[i] *= (1 + dt * 0.5); 
                    }
                    this.smoke.geometry.attributes.position.needsUpdate = true;
                    this.smoke.geometry.attributes.size.needsUpdate = true;
                    this.smoke.material.opacity = (1 - p) * 0.8;
                    const color = new THREE.Color().lerpColors(new THREE.Color(0xff3300), new THREE.Color(0x333333), p);
                    this.smoke.material.color.copy(color);

                    const spPos = this.sparks.geometry.attributes.position.array;
                    for(let i=0; i<sparkCount; i++) {
                        this.sparkVel[i].y -= dt * 50; 
                        spPos[i*3]   += this.sparkVel[i].x * dt;
                        spPos[i*3+1] += this.sparkVel[i].y * dt;
                        spPos[i*3+2] += this.sparkVel[i].z * dt;
                    }
                    this.sparks.geometry.attributes.position.needsUpdate = true;
                    this.sparks.material.opacity = 1 - easeIn;

                    const dPos = this.debris.geometry.attributes.position.array;
                    for(let i=0; i<debrisCount; i++) {
                         this.debrisVel[i].y -= dt * 80; 
                         dPos[i*3]   += this.debrisVel[i].x * dt;
                         dPos[i*3+1] += this.debrisVel[i].y * dt;
                         dPos[i*3+2] += this.debrisVel[i].z * dt;
                         
                         if (dPos[i*3+1] < -48) dPos[i*3+1] = -48;
                    }
                    this.debris.geometry.attributes.position.needsUpdate = true;
                    this.debris.material.opacity = 1 - p*p; 

                    this.light.intensity = 50 * scale * (1 - p*p);

                    return this.age < this.life;
                },
                dispose: function() {
                    scene.remove(this.group);
                    this.smoke.geometry.dispose();
                    this.sparks.geometry.dispose();
                    this.debris.geometry.dispose();
                }
            });
        }

        // NEW: Detailed Boss Death Explosion
        function createBossDeathExplosion(pos, radius) {
            const group = new THREE.Group();
            group.position.copy(pos);
            scene.add(group);

            const scale = radius / 8.64; // Scale based on boss size

            // 1. Massive Central Flash (White to Red)
            const flashGeo = new THREE.SphereGeometry(1 * scale, 32, 32);
            const flashMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 1,
                depthTest: false,
                blending: THREE.AdditiveBlending
            });
            const flash = new THREE.Mesh(flashGeo, flashMat);
            flash.scale.set(0.1, 0.1, 0.1);
            group.add(flash);

            // 2. Multiple Expanding Shockwave Rings
            const rings = [];
            for (let i = 0; i < 5; i++) {
                const ringGeo = new THREE.TorusGeometry(1 * scale, 0.2 * scale, 16, 64);
                const ringMat = new THREE.MeshBasicMaterial({ 
                    color: i < 2 ? 0xff0000 : (i < 4 ? 0xff6600 : 0xffaa00),
                    transparent: true, 
                    opacity: 0.8,
                    wireframe: false,
                    blending: THREE.AdditiveBlending
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                ring.scale.set(0.1, 0.1, 0.1);
                group.add(ring);
                rings.push(ring);
            }

            // 3. Energy Core Explosion (Purple/Red)
            const coreGeo = new THREE.IcosahedronGeometry(1.5 * scale, 1);
            const coreMat = new THREE.MeshBasicMaterial({ 
                color: 0xff00ff, 
                transparent: true, 
                opacity: 1,
                blending: THREE.AdditiveBlending
            });
            const core = new THREE.Mesh(coreGeo, coreMat);
            core.scale.set(0.1, 0.1, 0.1);
            group.add(core);

            // 4. Massive Particle Burst
            const particleCount = Math.floor(800 * scale);
            const particleGeo = new THREE.BufferGeometry();
            const particlePos = new Float32Array(particleCount * 3);
            const particleSizes = new Float32Array(particleCount);
            const particleVel = [];
            const particleColors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const speed = 15 + Math.random() * 25;
                
                particlePos[i * 3] = 0;
                particlePos[i * 3 + 1] = 0;
                particlePos[i * 3 + 2] = 0;
                
                particleSizes[i] = (0.3 + Math.random() * 0.7) * scale;
                
                const vel = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(angle) * speed,
                    Math.cos(phi) * speed,
                    Math.sin(phi) * Math.sin(angle) * speed
                );
                particleVel.push(vel);
                
                // Color gradient: red -> orange -> yellow
                const colorMix = Math.random();
                if (colorMix < 0.33) {
                    particleColors[i * 3] = 1.0; // R
                    particleColors[i * 3 + 1] = colorMix * 3; // G
                    particleColors[i * 3 + 2] = 0; // B
                } else if (colorMix < 0.66) {
                    particleColors[i * 3] = 1.0; // R
                    particleColors[i * 3 + 1] = 0.5 + (colorMix - 0.33) * 1.5; // G
                    particleColors[i * 3 + 2] = 0; // B
                } else {
                    particleColors[i * 3] = 1.0; // R
                    particleColors[i * 3 + 1] = 1.0; // G
                    particleColors[i * 3 + 2] = (colorMix - 0.66) * 3; // B
                }
            }
            
            particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePos, 3));
            particleGeo.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
            particleGeo.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            
            const particleMat = new THREE.PointsMaterial({ 
                size: 2 * scale,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                vertexColors: true
            });
            const particles = new THREE.Points(particleGeo, particleMat);
            group.add(particles);

            // 5. Large Debris Chunks
            const debrisCount = Math.floor(120 * scale);
            const debrisGeo = new THREE.BufferGeometry();
            const debrisPos = new Float32Array(debrisCount * 3);
            const debrisVel = [];
            for (let i = 0; i < debrisCount; i++) {
                debrisPos[i * 3] = (Math.random() - 0.5) * 2 * scale;
                debrisPos[i * 3 + 1] = (Math.random() - 0.5) * 2 * scale;
                debrisPos[i * 3 + 2] = (Math.random() - 0.5) * 2 * scale;
                
                const v = new THREE.Vector3(Math.random() - 0.5, Math.random() * 0.8, Math.random() - 0.5);
                v.normalize().multiplyScalar((25 + Math.random() * 50) * scale);
                debrisVel.push(v);
            }
            debrisGeo.setAttribute('position', new THREE.BufferAttribute(debrisPos, 3));
            const debrisMat = new THREE.PointsMaterial({
                color: 0x1a1a1a, 
                size: 3 * scale,
                transparent: true,
                opacity: 1
            });
            const debris = new THREE.Points(debrisGeo, debrisMat);
            group.add(debris);

            // 6. Energy Tendrils (Lightning-like)
            const tendrilCount = 20;
            const tendrils = [];
            for (let i = 0; i < tendrilCount; i++) {
                const points = [];
                const segments = 8;
                for (let j = 0; j <= segments; j++) {
                    const angle = (i / tendrilCount) * Math.PI * 2 + (j / segments) * 0.5;
                    const dist = (j / segments) * 15 * scale;
                    points.push(new THREE.Vector3(
                        Math.cos(angle) * dist,
                        (Math.random() - 0.5) * 5 * scale,
                        Math.sin(angle) * dist
                    ));
                }
                const curve = new THREE.CatmullRomCurve3(points);
                const geometry = new THREE.TubeGeometry(curve, segments, 0.3 * scale, 8, false);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending
                });
                const tendril = new THREE.Mesh(geometry, material);
                group.add(tendril);
                tendrils.push({ mesh: tendril, curve: curve });
            }

            // 7. Point Lights
            const mainLight = new THREE.PointLight(0xff0000, 200 * scale, 100 * scale, 2);
            group.add(mainLight);
            const secondaryLight = new THREE.PointLight(0xffaa00, 150 * scale, 80 * scale, 2);
            group.add(secondaryLight);

            // Animation
            let time = 0;
            const duration = 3.0;
            const update = () => {
                time += 0.016;
                const t = Math.min(time / duration, 1);
                const easeOut = 1 - Math.pow(1 - t, 3);
                const easeIn = t * t;

                // Flash expands and fades
                flash.scale.setScalar((0.1 + easeOut * 25) * scale);
                const flashColor = new THREE.Color().lerpColors(new THREE.Color(0xffffff), new THREE.Color(0xff0000), t);
                flashMat.color.copy(flashColor);
                flash.material.opacity = 1 - t * 0.8;

                // Rings expand
                rings.forEach((ring, i) => {
                    const ringScale = (0.1 + easeOut * (30 + i * 10)) * scale;
                    ring.scale.set(ringScale, ringScale, ringScale);
                    ring.material.opacity = (0.8 - t * 0.8) * (1 - i * 0.15);
                    ring.rotation.z += 0.05;
                });

                // Core expands and rotates
                core.scale.setScalar((0.1 + easeOut * 8) * scale);
                core.rotation.x += 0.1;
                core.rotation.y += 0.15;
                core.material.opacity = 1 - t;

                // Particles burst outward
                const pPos = particleGeo.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    const vel = particleVel[i];
                    pPos[i * 3] += vel.x * 0.016;
                    pPos[i * 3 + 1] += vel.y * 0.016;
                    pPos[i * 3 + 2] += vel.z * 0.016;
                }
                particleGeo.attributes.position.needsUpdate = true;
                particleMat.opacity = 1 - t;

                // Debris flies outward
                const dPos = debrisGeo.attributes.position.array;
                for (let i = 0; i < debrisCount; i++) {
                    debrisVel[i].y -= 0.016 * 60;
                    dPos[i * 3] += debrisVel[i].x * 0.016;
                    dPos[i * 3 + 1] += debrisVel[i].y * 0.016;
                    dPos[i * 3 + 2] += debrisVel[i].z * 0.016;
                }
                debrisGeo.attributes.position.needsUpdate = true;
                debris.material.opacity = 1 - t * t;

                // Tendrils fade
                tendrils.forEach(tendril => {
                    tendril.mesh.material.opacity = 0.9 - t;
                });

                // Lights fade
                mainLight.intensity = 200 * scale * (1 - t * t);
                secondaryLight.intensity = 150 * scale * (1 - t * t);

                if (t < 1) {
                    requestAnimationFrame(update);
                } else {
                    scene.remove(group);
                    flash.geometry.dispose();
                    flash.material.dispose();
                    rings.forEach(r => { r.geometry.dispose(); r.material.dispose(); });
                    core.geometry.dispose();
                    core.material.dispose();
                    particleGeo.dispose();
                    particleMat.dispose();
                    debrisGeo.dispose();
                    debrisMat.dispose();
                    tendrils.forEach(t => { t.mesh.geometry.dispose(); t.mesh.material.dispose(); });
                }
            };
            update();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            // CRITICAL: Schedule next frame FIRST to prevent blocking
            requestAnimationFrame(animate);

            let dt = Math.min(clock.getDelta(), 0.1);
            
            // Safety check to prevent infinite loops or invalid states
            if (isNaN(dt) || dt <= 0 || dt > 1) {
                dt = 0.016; // Default to ~60fps if invalid
            }
            
            // Update FPS tracker (every 500ms for performance)
            frameCount++;
            const now = Date.now();
            if (now - lastFpsUpdate > 500) {
                currentFPS = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                frameCount = 0;
                lastFpsUpdate = now;
                if (fpsTrackerEl) {
                    fpsTrackerEl.innerText = `FPS: ${currentFPS}`;
                    // Color code: green > 50, yellow 30-50, red < 30
                    if (currentFPS >= 50) {
                        fpsTrackerEl.style.color = 'rgba(0, 255, 0, 0.8)';
                    } else if (currentFPS >= 30) {
                        fpsTrackerEl.style.color = 'rgba(255, 255, 0, 0.8)';
                    } else {
                        fpsTrackerEl.style.color = 'rgba(255, 0, 0, 0.8)';
                    }
                }
            }

            // NEW: Check Decay Timer (Every 12 seconds)
            // NOTE: applyStructureDecay function removed - structures don't decay in current version
            // if (Date.now() - lastDecayTime > 12000) {
            //     lastDecayTime = Date.now();
            //     applyStructureDecay();
            // }
            
            // NEW: Update Placement Ghost
            if (isPlacingBarrier) {
                updatePlacement();
            }

            if (gameState === 'playing') {
                // Apply shop slowdown (70% slowdown = 30% speed)
                const shopSlowdown = isShopOpen ? SHOP_SLOWDOWN : 1.0;
                const combinedSlowdown = (isSlowMo ? CONFIG.slowMoScale : 1.0) * shopSlowdown;
                const slowedDt = dt * combinedSlowdown;
                
                // MULTIPLAYER: Send position updates (throttled inside function)
            if (isMultiplayerEnabled && isDefenseMode && socket && socket.connected) {
                    sendPositionUpdate();
                    
                    // Host syncs game state periodically (every 2 seconds)
                    if (isHost) {
                        const now = Date.now();
                        if (!lastGameStateSync) lastGameStateSync = 0;
                        if (now - lastGameStateSync > 2000) {
                            lastGameStateSync = now;
                            socket.emit('gameStateSync', {
                                wave: defenseWave,
                                coreHealth: defenseCoreHealth,
                                coins: defenseCoins,
                                enemiesToSpawn: enemiesToSpawn,
                                totalEnemiesForWave: totalEnemiesForWave,
                                waveInProgress: waveInProgress
                            });
                        }
                    }
                }
                
                if (isDefenseMode) {
                    updateDefenseGame(slowedDt);
                }

                if (isChargingShockwave) {
                    shockwaveCharge += dt * 0.5; 
                    SoundManager.playCharge(shockwaveCharge); 
                    if (shockwaveCharge > 1) shockwaveCharge = 1;
                    
                    const scale = 0.5 + shockwaveCharge * 1.5;
                    shockwaveChargeMesh.scale.set(scale, scale, scale);
                    
                    const time = Date.now() * 0.005;

                    const pulseScale = 1 + Math.sin(time * 8) * 0.1; 
                    
                    if(shockwaveChargeMesh.userData.core) {
                        shockwaveChargeMesh.userData.core.scale.setScalar(pulseScale);
                        shockwaveChargeMesh.userData.core.material.opacity = 0.8 + Math.sin(time * 4) * 0.2;
                    }
                    
                    if(shockwaveChargeMesh.userData.innerCore) {
                        const innerPulseScale = 1 + Math.sin(time * 12) * 0.15; 
                        shockwaveChargeMesh.userData.innerCore.scale.setScalar(innerPulseScale);
                        shockwaveChargeMesh.userData.innerCore.material.opacity = shockwaveCharge * 0.8 + Math.sin(time * 12) * 0.2;
                    }

                    if(shockwaveChargeMesh.userData.chargeLight) {
                        shockwaveChargeMesh.userData.chargeLight.intensity = (5 + shockwaveCharge * 15) * (1 + Math.sin(time * 10) * 0.1);
                    }
                    
                    if(shockwaveChargeMesh.userData.ringA) shockwaveChargeMesh.userData.ringA.rotation.y += dt * 10; 
                    if(shockwaveChargeMesh.userData.ringB) shockwaveChargeMesh.userData.ringB.rotation.z -= dt * 12; 
                    
                    if(shockwaveChargeMesh.userData.outer) {
                        shockwaveChargeMesh.userData.outer.rotation.y = time * 0.5;
                        shockwaveChargeMesh.userData.outer.rotation.x = time * 0.3;
                    }
                    
                    if(shockwaveChargeMesh.userData.particles) {
                        const positions = shockwaveChargeMesh.userData.particles.geometry.attributes.position.array;
                        for(let i=0; i<positions.length; i+=3) {
                            positions[i]   *= 0.9;
                            positions[i+1] *= 0.9;
                            positions[i+2] *= 0.9;
                            if(Math.abs(positions[i]) < 0.1 && Math.abs(positions[i+1]) < 0.1) {
                                positions[i] = (Math.random()-0.5)*10;
                                positions[i+1] = (Math.random()-0.5)*10;
                                positions[i+2] = (Math.random()-0.5)*10;
                            }
                        }
                        shockwaveChargeMesh.userData.particles.geometry.attributes.position.needsUpdate = true;
                        shockwaveChargeMesh.userData.particles.rotation.z += 0.05;
                    }
                    
                    const shake = shockwaveCharge * 0.05;
                    camera.position.add(new THREE.Vector3(
                        (Math.random()-0.5)*shake, 
                        (Math.random()-0.5)*shake, 
                        (Math.random()-0.5)*shake
                    ));

                    chargeBarFill.style.width = (shockwaveCharge * 100) + '%';
                }

                if (isChargingThrow) {
                    throwCharge += dt * 0.75; 
                    if (throwCharge > 1) throwCharge = 1;
                    
                    SoundManager.playCharge(throwCharge * 0.5); 
                    chargeBarFill.style.width = (throwCharge * 100) + '%';
                    
                    if (grabbedBodies.length > 0) {
                        grabbedBodies.forEach(b => {
                            const shake = throwCharge * 0.2;
                            b.position.x += (Math.random()-0.5) * shake;
                            b.position.y += (Math.random()-0.5) * shake;
                            b.position.z += (Math.random()-0.5) * shake;
                            b.wakeUp();
                        });
                    }
                }

                if (currentAmmo === 'heavy' && isChargingFire) {
                    const duration = (Date.now() - fireChargeStart) / 1000;
                    if (duration > 0.3) {
                        const maxChargeTimeSeconds = 2.2;
                        const t = Math.min((duration - 0.3) / maxChargeTimeSeconds, 1.0); 
                        const scale = 1 + (t * 2); 
                        
                        loadedBall.scale.set(scale, scale, scale);
                        
                        // NEW: Make transparent as it charges
                        // Opacity goes from 1.0 -> 0.2
                        if(loadedBall.userData.ammoMeshes.heavy.userData.core) {
                            const newOp = 1.0 - (t * 0.8);
                            loadedBall.userData.ammoMeshes.heavy.userData.core.material.opacity = newOp;
                            loadedBall.userData.ammoMeshes.heavy.userData.cage.material.opacity = 0.5 * newOp;
                        }
                        
                        if (t >= 1.0) {
                            SoundManager.stopHeavyCharge();
                        } else {
                            SoundManager.updateHeavyCharge(t);
                        }
                        
                        const shake = t * 0.05;
                        
                        const pushForward = t * 5.0; 
                        const rightShift = t * 1.2; 
                        
                        loadedBall.position.x = (2.2 + rightShift) + (Math.random()-0.5)*shake;
                        loadedBall.position.y = -1.4 + (Math.random()-0.5)*shake;
                        // UPDATED: Z Position -5.5 base
                        loadedBall.position.z = (-5.5 - pushForward) + (Math.random()-0.5)*shake;
                    }
                }

                if (loadedBall.userData.ammoMeshes.explosive.visible) {
                    const grp = loadedBall.userData.ammoMeshes.explosive;
                    grp.userData.time += dt * 5;
                    if(grp.userData.light) grp.userData.light.intensity = 2 + Math.sin(grp.userData.time) * 0.5;
                    if(grp.userData.shell) {
                        grp.userData.shell.rotation.x = grp.userData.time * 0.2;
                        grp.userData.shell.rotation.z = grp.userData.time * 0.3;
                    }
                    if(grp.userData.ring1) grp.userData.ring1.rotation.y += dt * 2;
                    if(grp.userData.ring2) grp.userData.ring2.rotation.x -= dt * 2;

                    if(grp.userData.fireParticles) {
                        const fp = grp.userData.fireParticles;
                        const speeds = grp.userData.fireSpeeds;
                        const pos = fp.geometry.attributes.position.array;
                        
                        for(let i=0; i<speeds.length; i++) {
                            pos[i*3+1] += speeds[i].y * dt; 
                            
                            if(pos[i*3+1] > 1.0) {
                                pos[i*3] = (Math.random()-0.5)*0.5;
                                pos[i*3+1] = -0.5;
                                pos[i*3+2] = (Math.random()-0.5)*0.5;
                            }
                        }
                        fp.geometry.attributes.position.needsUpdate = true;
                    }
                }

                if (currentAmmo === 'blackhole' && loadedBall.userData.ammoMeshes.blackhole.visible) {
                    const bhGroup = loadedBall.userData.ammoMeshes.blackhole;
                    const scale = 1 + Math.sin(Date.now() * 0.005) * 0.1;

                    if (bhGroup.userData.orbitRing) {
                        bhGroup.userData.orbitRing.rotation.x += dt * 0.4;
                        bhGroup.userData.orbitRing.rotation.y += dt * 0.6;
                        bhGroup.userData.orbitRing.scale.set(scale, scale, scale);
                    }
                    if (bhGroup.userData.orbitRing2) {
                        bhGroup.userData.orbitRing2.rotation.x -= dt * 0.5;
                        bhGroup.userData.orbitRing2.rotation.y += dt * 0.3;
                        bhGroup.userData.orbitRing2.scale.set(scale, scale, scale);
                    }
                    
                    if (bhGroup.userData.weaponParticles) {
                        const positions = bhGroup.userData.weaponParticles.geometry.attributes.position.array;
                        for(let i=0; i<positions.length; i+=3) {
                            positions[i]   *= 0.98;
                            positions[i+1] *= 0.98;
                            positions[i+2] *= 0.98;
                            
                            if(Math.abs(positions[i]) < 0.1 && Math.abs(positions[i+1]) < 0.1 && Math.abs(positions[i+2]) < 0.1) {
                                const r = 3 + Math.random();
                                const theta = Math.random() * Math.PI * 2;
                                const phi = Math.random() * Math.PI * 2;
                                positions[i] = r * Math.sin(phi) * Math.cos(theta);
                                positions[i+1] = r * Math.sin(phi) * Math.sin(theta);
                                positions[i+2] = r * Math.cos(phi);
                            }
                        }
                        bhGroup.userData.weaponParticles.geometry.attributes.position.needsUpdate = true;
                        bhGroup.userData.weaponParticles.rotation.y += dt * 0.5;
                        bhGroup.userData.weaponParticles.rotation.z += dt * 0.3;
                    }
                }
                
                if (currentAmmo === 'raygun' && loadedBall.userData.ammoMeshes.raygun.visible) {
                    const rayGroup = loadedBall.userData.ammoMeshes.raygun;
                    const { core, shell, coil } = rayGroup.userData;
                    const time = Date.now() * 0.005;

                    coil.rotation.x += dt * 5;  
                    coil.rotation.y += dt * 7;  
                    
                    shell.rotation.y += dt * 0.5; 

                    const pulse = 1 + Math.sin(time * 1) * 0.1; 
                    core.scale.setScalar(CONFIG.ballRadius * 0.7 * pulse);
                    core.material.opacity = 0.8 + Math.sin(time * 2) * 0.2; 

                    shell.scale.setScalar(CONFIG.ballRadius * 0.85 * pulse);
                }

                // Use already calculated slowdown values
                const fixedStep = timeStep * combinedSlowdown;
                let stepDt = slowedDt;
                
                updatePlayerMovement(stepDt); 
                if (isAiming) updateAiming();
                
                updateGravityGun();
                updateShockwaves(stepDt);
                if (isDefenseMode) {
                    updateBossShockwaveRings(stepDt);
                }
                updateBlackHoles(stepDt);
                updateEraser();

                try {
                    // Use stepDt (slowed time) for physics step - this ensures all physics slows down
                    // Cannon.js step signature: step(dt, timeSinceLastCalled, maxSubSteps)
                    world.step(stepDt, 0, 10);
                    
                } catch (e) {
                    console.warn("Physics step failed:", e);
                }
                
                // Box physics removed - no structures

                // FIXED: Make camera offset taller
                if (playerBody) camera.position.copy(playerBody.position).add(new THREE.Vector3(0, 8.5, 0)); // Increased from 6.0 to 8.5
                
                // MULTIPLAYER: Update other players' visibility and make them face camera
                if (isMultiplayerEnabled && isDefenseMode && otherPlayers.size > 0) {
                    otherPlayers.forEach((player, playerId) => {
                        if (player && player.mesh) {
                            // Make sure player is visible
                            player.mesh.visible = true;
                            // Update sprite to always face camera (only every 3rd frame for performance)
                            if (player.sprite && frameCount % 3 === 0) {
                                player.sprite.lookAt(camera.position);
                            }
                            // Make glow pulse slightly (lightweight, can update every frame)
                            if (player.glow) {
                                const pulse = 1 + Math.sin(Date.now() * 0.003) * 0.2;
                                player.glow.scale.setScalar(pulse);
                            }
                        }
                    });
                }

                if (screenShake > 0) {
                    const rx = (Math.random() - 0.5) * screenShake;
                    const ry = (Math.random() - 0.5) * screenShake;
                    const rz = (Math.random() - 0.5) * screenShake;
                    camera.position.add(new THREE.Vector3(rx, ry, rz));
                    
                    screenShake -= stepDt * 1.5; 
                    if (screenShake < 0) screenShake = 0;
                }

                // PERFORMANCE: Optimize cloud updates - only update every few frames
                if(clouds) {
                    const now = Date.now();
                    clouds.forEach((c, idx) => {
                        // Update clouds in batches (every 3rd cloud per frame) for better performance
                        if (idx % 3 === (Math.floor(now / 16) % 3)) {
                        c.position.x += 0.01 * c.userData.speed;
                        if(c.position.x > 800) c.position.x = -800;
                        }
                    });
                }
                
                // Update projectile visuals and physics - PERFORMANCE: Batch updates
                const maxProjectilesPerFrame = 50; // Limit updates per frame for performance
                const projectilesToUpdate = Math.min(projectiles.length, maxProjectilesPerFrame);
                for (let pIdx = 0; pIdx < projectilesToUpdate; pIdx++) {
                    const p = projectiles[pIdx];
                    if (!p || !p.body || !p.mesh) continue;
                    
                    p.mesh.position.copy(p.body.position);
                    p.mesh.quaternion.copy(p.body.quaternion);
                    
                    if(p.mesh.userData.update) p.mesh.userData.update(stepDt);

                    // FIXED: Increased downward force by 45%
                    p.body.applyForce(new CANNON.Vec3(0, -3625, 0), p.body.position); // 2500 * 1.45 = 3625
                    
                    // REMOVED: Proximity force system - using proper collision handling instead
                }

                // Update remaining projectiles in next frame (staggered updates for performance)
                if (projectiles.length > maxProjectilesPerFrame) {
                    const startIdx = maxProjectilesPerFrame;
                    const endIdx = Math.min(projectiles.length, startIdx + maxProjectilesPerFrame);
                    for (let pIdx = startIdx; pIdx < endIdx; pIdx++) {
                        const p = projectiles[pIdx];
                        if (!p || !p.body || !p.mesh) continue;
                        p.mesh.position.copy(p.body.position);
                        p.mesh.quaternion.copy(p.body.quaternion);
                        if(p.mesh.userData.update) p.mesh.userData.update(stepDt);
                        // FIXED: Increased downward force by 45%
                        p.body.applyForce(new CANNON.Vec3(0, -3625, 0), p.body.position); // 2500 * 1.45 = 3625
                        
                        // REMOVED: Proximity force system - using proper collision handling instead
                    }
                }
                
                // CRITICAL: Only check collisions if we're in defense mode (prevents freeze in normal mode)
                // This is wrapped in try-catch to prevent any errors from blocking the render loop
                // DOUBLE CHECK: Make absolutely sure we're in defense mode before running collision detection
                if (gameState === 'playing' && isDefenseMode === true && 
                    typeof defenseEnemies !== 'undefined' && defenseEnemies && 
                    Array.isArray(defenseEnemies) && defenseEnemies.length > 0 && 
                    projectiles.length > 0) {
                    
                    try {
                        const projectilesToRemove = [];
                        const maxCheckDist = 50;
                        const maxCheckDistSq = maxCheckDist * maxCheckDist;
                        const maxChecks = Math.min(projectiles.length, 50); // Limit checks per frame for performance
                        
                        for (let pIdx = 0; pIdx < Math.min(projectiles.length, maxChecks); pIdx++) {
                            const p = projectiles[pIdx];
                            if (!p || !p.body || !p.mesh) continue;
                            if (p.body.userData && (p.body.userData.explosive || p.body.userData.isBlackHole)) continue;
                            
                            const projPos = p.body.position;
                            if (!projPos) continue;
                            
                            // Quick bounds check
                            if (projPos.x < -100 || projPos.x > 100 || 
                                projPos.y < -100 || projPos.y > 100 || 
                                projPos.z < -100 || projPos.z > 100) {
                                continue;
                            }
                            
                            // Get projectile radius
                            let projRadius = 1.5;
                            if (p.body.shapes && p.body.shapes[0] && p.body.shapes[0].boundingSphereRadius) {
                                projRadius = p.body.shapes[0].boundingSphereRadius;
                            }
                            
                            // Check against enemies (limit to prevent performance issues)
                            const maxEnemyChecks = Math.min(defenseEnemies.length, 30);
                            for (let i = defenseEnemies.length - 1; i >= Math.max(0, defenseEnemies.length - maxEnemyChecks); i--) {
                                const e = defenseEnemies[i];
                                if (!e || !e.body || !e.hp || e.hp <= 0) continue;
                                
                                const dx = projPos.x - e.body.position.x;
                                const dy = projPos.y - e.body.position.y;
                                const dz = projPos.z - e.body.position.z;
                                const distSq = dx*dx + dy*dy + dz*dz;
                                
                                if (distSq > maxCheckDistSq) continue;
                                
                                let enemyRadius = 2.6;
                                if (e.body.shapes && e.body.shapes[0] && e.body.shapes[0].boundingSphereRadius) {
                                    enemyRadius = e.body.shapes[0].boundingSphereRadius;
                                }
                                
                                const hitRadiusSq = (projRadius + enemyRadius) * (projRadius + enemyRadius);
                                
                                if (distSq < hitRadiusSq) {
                                    // FIXED: Heavy projectiles use collision events (more reliable)
                                    // This distance-based check serves as a backup
                                    if (p.body.userData && !p.body.userData.explosive && !p.body.userData.isBlackHole) {
                                        // Check if already hit via collision event
                                        const enemyId = e.body.id || i;
                                        if (p.body.userData.hitEnemies && p.body.userData.hitEnemies.has(enemyId)) {
                                            continue; // Already hit via collision event
                                        }
                                        
                                        // Backup: Apply damage if collision event didn't catch it
                                        if (!p.body.userData.hitEnemies) p.body.userData.hitEnemies = new Set();
                                        
                                        if (!p.body.userData.hitEnemies.has(enemyId)) {
                                            p.body.userData.hitEnemies.add(enemyId);
                                            
                                            // Calculate damage
                                            const chargeLevel = (p.body.userData.chargeLevel !== undefined) ? p.body.userData.chargeLevel : 0;
                                            const baseDmg = 20;
                                            // Max damage: 2x (40) without upgrade, 3x (60) with upgrade
                                            const maxDmg = hasMaxChargeUpgrade ? 60 : 40;
                                            const dmg = baseDmg + (chargeLevel * (maxDmg - baseDmg));
                                            
                                            if (typeof damageEnemy === 'function') {
                                                damageEnemy(e, dmg);
                                            }
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                        
                        // Remove hit projectiles (iterate backwards to maintain indices)
                        for (let i = projectilesToRemove.length - 1; i >= 0; i--) {
                            const pIdx = projectilesToRemove[i];
                            const p = projectiles[pIdx];
                            if (p) {
                                try {
                                    world.removeBody(p.body);
                                    if (p.mesh) {
                                        if (p.mesh.userData && p.mesh.userData.cleanup) p.mesh.userData.cleanup();
                                        scene.remove(p.mesh);
                                    }
                                    if (p.body.userData && p.body.userData.canGrab) {
                                        const cIdx = collidables.indexOf(p.mesh);
                                        if (cIdx > -1) collidables.splice(cIdx, 1);
                                    }
                                    projectiles.splice(pIdx, 1);
                                } catch (e) {
                                    // Ignore removal errors
                                }
                            }
                        }
                    } catch (err) {
                        // Silently catch any errors to prevent blocking the render loop
                        console.warn("Projectile collision check error (non-blocking):", err);
                    }
                }

                // Box update code removed - no structures
                
                if(playerBody) {
                    if(playerBody.position.y < -50) {
                        playerBody.position.set(0, 50, 0); playerBody.velocity.set(0,0,0);
                    }
                }
            } else if (gameState === 'paused' || gameState === 'menu') {
            }

            // PERFORMANCE: Limit explosion updates per frame
            const maxExplosionsPerFrame = 10;
            const explosionsToUpdate = Math.min(explosions.length, maxExplosionsPerFrame);
            for(let i=explosions.length-1; i>=Math.max(0, explosions.length-explosionsToUpdate); i--) {
                const alive = explosions[i].update(dt); 
                if(!alive) {
                    explosions[i].dispose();
                    explosions.splice(i, 1);
                }
            }

            // CRITICAL: Always render, even if there were errors above
            // This prevents the screen from freezing
            try {
            renderer.render(scene, camera);
            } catch (err) {
                console.warn("Render error (non-blocking):", err);
                // Try to recover by rendering anyway
                try {
                    renderer.render(scene, camera);
                } catch (e) {
                    // If it still fails, at least we tried
                }
            }
        }

        // Initialize room code input to uppercase
        const roomCodeInput = document.getElementById('room-code-input');
        if (roomCodeInput) {
            roomCodeInput.addEventListener('input', (e) => {
                e.target.value = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
            });
            roomCodeInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    joinRoomByCode();
                }
            });
        }

        init();
        animate();
    </script>
</body>
</html>